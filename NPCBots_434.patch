From 26d3f5ea190ac51f28507256a9fa2988e43daf1b Mon Sep 17 00:00:00 2001
From: trickerer <onlysuffering@gmail.com>
Date: Tue, 13 Aug 2013 20:05:16 +0700
Subject: [PATCH] NPCBots_434

---
 sql/Bots/character_NPC_bots.sql                    |   12 +
 sql/Bots/world_bots.sql                            |  524 ++++
 src/server/game/AI/NpcBots/bot_GridNotifiers.h     |  461 +++
 src/server/game/AI/NpcBots/bot_ai.cpp              | 3287 ++++++++++++++++++++
 src/server/game/AI/NpcBots/bot_ai.h                |  372 +++
 src/server/game/AI/NpcBots/bot_druid_ai.cpp        | 1145 +++++++
 src/server/game/AI/NpcBots/bot_hunter_ai.cpp       |  340 ++
 src/server/game/AI/NpcBots/bot_mage_ai.cpp         |  935 ++++++
 src/server/game/AI/NpcBots/bot_paladin_ai.cpp      | 1049 +++++++
 src/server/game/AI/NpcBots/bot_priest_ai.cpp       |  859 +++++
 src/server/game/AI/NpcBots/bot_rogue_ai.cpp        |  904 ++++++
 src/server/game/AI/NpcBots/bot_shaman_ai.cpp       |  474 +++
 src/server/game/AI/NpcBots/bot_warlock_ai.cpp      |  458 +++
 src/server/game/AI/NpcBots/bot_warrior_ai.cpp      | 1114 +++++++
 src/server/game/AI/NpcBots/botcommands.cpp         |  633 ++++
 src/server/game/AI/NpcBots/bothelper.cpp           |  421 +++
 src/server/game/AI/NpcBots/bothelper.h             |   32 +
 src/server/game/CMakeLists.txt                     |    1 +
 src/server/game/Entities/Creature/Creature.cpp     |  140 +
 src/server/game/Entities/Creature/Creature.h       |   40 +
 .../game/Entities/Creature/TemporarySummon.cpp     |    8 +
 src/server/game/Entities/Object/Object.cpp         |   11 +
 src/server/game/Entities/Player/Player.cpp         |  857 +++++
 src/server/game/Entities/Player/Player.h           |   63 +
 src/server/game/Entities/Unit/StatSystem.cpp       |    4 +
 src/server/game/Entities/Unit/Unit.cpp             |  224 ++
 src/server/game/Groups/Group.cpp                   |   12 +
 src/server/game/Groups/Group.h                     |    3 +
 src/server/game/Handlers/CharacterHandler.cpp      |   25 +
 src/server/game/Handlers/MiscHandler.cpp           |   35 +
 src/server/game/Handlers/NPCHandler.cpp            |   16 +
 src/server/game/Maps/Map.cpp                       |    3 +
 src/server/game/Scripting/ScriptLoader.cpp         |   22 +
 src/server/game/Server/WorldSession.cpp            |   17 +
 src/server/game/Server/WorldSession.h              |   19 +
 src/server/scripts/Spells/spell_priest.cpp         |    4 +
 .../Database/Implementation/CharacterDatabase.cpp  |    7 +
 .../Database/Implementation/CharacterDatabase.h    |    7 +
 .../Database/Implementation/WorldDatabase.cpp      |    4 +
 .../shared/Database/Implementation/WorldDatabase.h |    4 +
 src/server/worldserver/worldserver.conf.dist       |  106 +
 41 files changed, 14652 insertions(+), 0 deletions(-)
 create mode 100644 sql/Bots/character_NPC_bots.sql
 create mode 100644 sql/Bots/world_bots.sql
 create mode 100644 src/server/game/AI/NpcBots/bot_GridNotifiers.h
 create mode 100644 src/server/game/AI/NpcBots/bot_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_ai.h
 create mode 100644 src/server/game/AI/NpcBots/bot_druid_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_hunter_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_mage_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_paladin_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_priest_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_rogue_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_shaman_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_warlock_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_warrior_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/botcommands.cpp
 create mode 100644 src/server/game/AI/NpcBots/bothelper.cpp
 create mode 100644 src/server/game/AI/NpcBots/bothelper.h

diff --git a/sql/Bots/character_NPC_bots.sql b/sql/Bots/character_NPC_bots.sql
new file mode 100644
index 0000000..723043e
--- /dev/null
+++ b/sql/Bots/character_NPC_bots.sql
@@ -0,0 +1,12 @@
+DROP TABLE IF EXISTS `character_npcbot`;
+CREATE TABLE `character_npcbot` (
+  `owner` int(10) default NULL,
+  `entry` int(10) default NULL,
+  `race` tinyint(3) default NULL,
+  `class` tinyint(3) default NULL,
+  `istank` tinyint(3) default NULL,
+  PRIMARY KEY  (`owner`,`entry`)
+)  ENGINE=InnoDB DEFAULT CHARSET=utf8;
+
+
+
diff --git a/sql/Bots/world_bots.sql b/sql/Bots/world_bots.sql
new file mode 100644
index 0000000..65985b9
--- /dev/null
+++ b/sql/Bots/world_bots.sql
@@ -0,0 +1,524 @@
+
+-- GENERAL --
+
+delete from `creature_template` where entry between 70001 and 70238;
+
+insert into `creature_template` 
+(`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, 
+`minlevel`, `maxlevel`, `exp`, `faction_A`, `faction_H`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `dmg_multiplier`, `baseattacktime`, 
+`rangeattacktime`, `unit_class`, `unit_flags`, `unit_flags2`, `dynamicflags`, `family`, `trainer_type`, `trainer_class`, `trainer_race`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`, 
+`type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, 
+`spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `HoverHeight`, `Health_mod`, `Mana_mod`, `Armor_mod`, `RacialLeader`, 
+`questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `WDBVerified`) 
+values 
+('70001','0','0','0','0','0','5001','0','5001','0','Khelden','Mage Bot','','0','85','85','2','12','12','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','8','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70002','0','0','0','0','0','1294','0','1294','0','Zaldimar','Mage Bot','','0','85','85','2','12','12','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','8','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70003','0','0','0','0','0','1484','0','1484','0','Maginor','Mage Bot','','0','85','85','2','12','12','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','8','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70004','0','0','0','0','0','3344','0','3344','0','Anetta','Priest Bot','','0','85','85','2','12','12','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','5','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70005','0','0','0','0','0','1495','0','1495','0','Laurena','Priest Bot','','0','85','85','2','12','12','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','5','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70006','0','0','0','0','0','1295','0','1295','0','Josetta','Priest Bot','','0','85','85','2','12','12','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','5','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70007','0','0','0','0','0','3345','0','3345','0','Drusilla','Warlock Bot','','0','85','85','2','12','12','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','9','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('70008','0','0','0','0','0','1930','0','1930','0','Alamar','Warlock Bot','','0','85','85','2','875','875','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','9','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('70009','0','0','0','0','0','1469','0','1469','0','Demisette','Warlock Bot','','0','85','85','2','12','12','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','9','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('70010','0','0','0','0','0','12749','0','12749','0','Nalesette','Hunter Bot','','0','85','85','2','80','80','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','3','3','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70011','0','0','0','0','0','3401','0','3401','0','Branstock','Priest Bot','','0','85','85','2','55','55','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','5','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70012','0','0','0','0','0','3395','0','3395','0','Thorgas','Hunter Bot','','0','85','85','2','55','55','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','3','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70013','0','0','0','0','0','3343','0','3343','0','Llane','Warrior Bot','','0','85','85','2','12','12','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','1','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70014','0','0','0','0','0','3399','0','3399','0','Thran','Warrior Bot','','0','85','85','2','55','55','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','1','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70015','0','0','0','0','0','1300','0','1300','0','Lyria','Warrior Bot','','0','85','85','2','12','12','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','1','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70016','0','0','0','0','0','3351','0','3351','0','Jorik','Rogue Bot','','0','85','85','2','12','12','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','4','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('70017','0','0','0','0','0','3407','0','3407','0','Solm','Rogue Bot','','0','85','85','2','55','55','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','4','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('70018','0','0','0','0','0','1297','0','1297','0','Keryn','Rogue Bot','','0','85','85','2','12','12','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','4','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('70019','0','0','0','0','0','1507','0','1507','0','Osborne','Rogue Bot','','0','85','85','2','12','12','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','4','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('70020','0','0','0','0','0','3346','0','3346','0','Sammuel','Paladin Bot','','0','85','85','2','12','12','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','2','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('70021','0','0','0','0','0','3393','0','3393','0','Bob','Paladin Bot','','0','85','85','2','55','55','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','2','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('70022','0','0','0','0','0','1299','0','1299','0','Wilhelm','Paladin Bot','','0','85','85','2','12','12','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','2','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('70023','0','0','0','0','0','1499','0','1499','0','Brisombre','Paladin Bot','','0','85','85','2','12','12','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','2','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('70024','0','0','0','0','0','10216','0','10216','0','Marry','Mage Bot','','0','85','85','2','875','875','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','8','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70025','0','0','0','0','0','4552','0','4552','0','Haromm','Shaman Bot','','0','85','85','2','29','29','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','7','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('70026','0','0','0','0','0','4567','0','4567','0','Kartosh','Warlock Bot','','0','85','85','2','29','29','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','9','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('70027','0','0','0','0','0','3429','0','3429','0','MaxanAnvol','Priest Bot','','0','85','85','2','55','55','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','5','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70028','0','0','0','0','0','10215','0','10215','0','Magis','Mage Bot','','0','85','85','2','875','875','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','8','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70029','0','0','0','0','0','3431','0','3431','0','GranVivehache','Warrior Bot','','0','85','85','2','55','55','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','1','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70030','0','0','0','0','0','1622','0','1622','0','Azar','Paladin Bot','','0','85','85','2','55','55','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','2','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('70031','0','0','0','0','0','3436','0','3436','0','Hogral','Rogue Bot','','0','85','85','2','55','55','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','4','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('70032','0','0','0','0','0','3053','0','3053','0','Kelstrum','Warrior Bot','','0','85','85','2','55','55','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','1','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70033','0','0','0','0','0','1578','0','1578','0','Dannal','Warrior Bot','','0','85','85','2','68','68','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','1','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70034','0','0','0','0','0','1579','0','1579','0','SombreDuesten','Priest Bot','','0','85','85','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','5','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70035','0','0','0','0','0','1592','0','1592','0','Isabella','Mage Bot','','0','85','85','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','8','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70036','0','0','0','0','0','1581','0','1581','0','Maximillion','Warlock Bot','','0','85','85','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','9','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('70037','0','0','0','0','0','1604','0','1604','0','Rupert','Warlock Bot','','0','85','85','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','9','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('70038','0','0','0','0','0','1600','0','1600','0','Cain','Mage Bot','','0','85','85','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','8','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70039','0','0','0','0','0','1602','0','1602','0','SombreBeryl','Priest Bot','','0','85','85','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','5','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70041','0','0','0','0','0','10548','0','10548','0','Milituus','Mage Bot','','0','85','85','2','55','55','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','8','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70042','0','0','0','0','0','2810','0','2810','0','Lexington','Mage Bot','','0','85','85','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','8','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70043','0','0','0','0','0','2123','0','2123','0','Siln','Shaman Bot','','0','85','85','2','104','104','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','7','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('70044','0','0','0','0','0','19598','0','19598','0','Umbrua','Shaman Bot','','0','85','85','2','1640','1640','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','7','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('70045','0','0','0','0','0','2102','0','2102','0','Tigor','Shaman Bot','','0','85','85','2','104','104','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','7','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('70046','0','0','0','0','0','2082','0','2082','0','Beram','Shaman Bot','','0','85','85','2','104','104','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','7','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('70047','0','0','0','0','0','2106','0','2106','0','Turak','Druid Bot','','0','85','85','2','104','104','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','11','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('70048','0','0','0','0','0','2121','0','2121','0','Sheal','Druid Bot','','0','85','85','2','104','104','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','11','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('70049','0','0','0','0','0','2115','0','2115','0','Kym','Druid Bot','','0','85','85','2','104','104','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','11','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('70050','0','0','0','0','0','2112','0','2112','0','Kary','Hunter Bot','','0','85','85','2','104','104','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','3','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70051','0','0','0','0','0','2087','0','2087','0','Holt','Hunter Bot','','0','85','85','2','104','104','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','3','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70052','0','0','0','0','0','2105','0','2105','0','Urek','Hunter Bot','','0','85','85','2','104','104','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','3','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70053','0','0','0','0','0','2103','0','2103','0','Torm','Warrior Bot','','0','85','85','2','104','104','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','1','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70054','0','0','0','0','0','2096','0','2096','0','Sark','Warrior Bot','','0','85','85','2','104','104','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','1','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70055','0','0','0','0','0','17211','0','17211','0','Kerra','Warrior Bot','','0','85','85','2','104','104','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','1','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70056','0','0','0','0','0','2139','0','2139','0','Miles Welsh','Priest Bot','','0','85','85','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','5','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70057','0','0','0','0','0','2138','0','2138','0','Malakai','Priest Bot','','0','85','85','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','5','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70058','0','0','0','0','0','2137','0','2137','0','Cobb','Priest Bot','','0','85','85','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','5','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70059','0','0','0','0','0','2134','0','2134','0','Shymm','Mage Bot','','0','85','85','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','8','5','0','0','0','7','1','0','0','0','0','0','0','0','0','0','0','143','145','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70060','0','0','0','0','0','6058','0','6058','0','Ursyn','Mage Bot','','0','85','85','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','8','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70061','0','0','0','0','0','2135','0','2135','0','Thurston','Mage Bot','','0','85','85','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','8','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70062','0','0','0','0','0','3793','0','3793','0','Harutt','Warrior Bot','','0','85','85','2','104','104','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','1','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70063','0','0','0','0','0','3819','0','3819','0','Gart','Druid Bot','','0','85','85','2','104','104','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','11','6','0','0','0','7','8','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('70064','0','0','0','0','0','3810','0','3810','0','Lanka','Hunter Bot','','0','85','85','2','104','104','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','3','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70065','0','0','0','0','0','10180','0','10180','0','Meela','Shaman Bot','','0','85','85','2','104','104','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','7','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('70066','0','0','0','0','0','3794','0','3794','0','Krang','Warrior Bot','','0','85','85','2','104','104','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','1','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70067','0','0','0','0','0','10734','0','10734','0','Gennia','Druid Bot','','0','85','85','2','104','104','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','11','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('70068','0','0','0','0','0','3811','0','3811','0','Yaw','Hunter Bot','','0','85','85','2','104','104','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','3','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70069','0','0','0','0','0','3816','0','3816','0','Narm','Shaman Bot','','0','85','85','2','104','104','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','7','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('70070','0','0','0','0','0','1880','0','1880','0','Frang','Warrior Bot','','0','85','85','2','29','29','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','1','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70071','0','0','0','0','0','1882','0','1882','0','Jenshan','Hunter Bot','','0','85','85','2','126','126','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','3','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70072','0','0','0','0','0','1884','0','1884','0','Nartok','Warlock Bot','','0','85','85','2','29','29','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','9','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('70073','0','0','0','0','0','1878','0','1878','0','Shikrik','Shaman Bot','','0','85','85','2','29','29','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','7','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('70074','0','0','0','0','0','3743','0','3743','0','Tarshaw','Warrior Bot','','0','85','85','2','29','29','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','1','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70075','0','0','0','0','0','3744','0','3744','0','Thotar','Hunter Bot','','0','85','85','2','29','29','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','3','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70076','0','0','0','0','0','3745','0','3745','0','Dhugru','Warlock Bot','','0','85','85','2','29','29','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','9','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('70077','0','0','0','0','0','3746','0','3746','0','Swart','Shaman Bot','','0','85','85','2','29','29','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','7','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('70078','0','0','0','0','0','1324','0','1324','0','Groldar','Warlock Bot','','0','85','85','2','29','29','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','9','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('70079','0','0','0','0','0','1325','0','1325','0','Mirket','Warlock Bot','','0','85','85','2','29','29','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','9','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('70080','0','0','0','0','0','1326','0','1326','0','Zevrost','Warlock Bot','','0','85','85','2','29','29','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','9','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('70081','0','0','0','0','0','1360','0','1360','0','Kardris','Shaman Bot','','0','85','85','2','29','29','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','7','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('70082','0','0','0','0','0','1373','0','1373','0','Ormak','Hunter Bot','','0','85','85','2','29','29','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','3','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70083','0','0','0','0','0','1374','0','1374','0','Grezz','Warrior Bot','','0','85','85','2','29','29','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','1','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70084','0','0','0','0','0','1375','0','1375','0','Sorek','Warrior Bot','','0','85','85','2','29','29','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','1','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70085','0','0','0','0','0','4231','0','4231','0','Siantsu','Shaman Bot','','0','85','85','2','29','29','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','7','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('70086','0','0','0','0','0','4239','0','4239','0','Xorjuul','Hunter Bot','','0','85','85','2','29','29','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','3','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70087','0','0','0','0','0','4241','0','4241','0','Siandur','Hunter Bot','','0','85','85','2','29','29','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','3','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70088','0','0','0','0','0','4242','0','4242','0','Zelmak','Warrior Bot','','0','85','85','2','29','29','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','1','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70089','0','0','0','0','0','7915','0','7915','0','ClaudeErksine','Hunter Bot','','0','85','85','2','55','55','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','3','3','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70090','0','0','0','0','0','1721','0','1721','0','Alyissia','Warrior Bot','','0','85','85','2','80','80','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','1','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70091','0','0','0','0','0','1725','0','1725','0','FrahunMurmombre','Rogue Bot','','0','85','85','2','80','80','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','4','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('70092','0','0','0','0','0','1733','0','1733','0','Shanda','Priest Bot','','0','85','85','2','80','80','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','5','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70093','0','0','0','0','0','1732','0','1732','0','Mardant','Druid Bot','','0','85','85','2','80','80','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','11','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('70094','0','0','0','0','0','1707','0','1707','0','Kyra','Warrior Bot','','0','85','85','2','80','80','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','1','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70095','0','0','0','0','0','1704','0','1704','0','Jannok','Rogue Bot','','0','85','85','2','80','80','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','4','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('70096','0','0','0','0','0','1708','0','1708','0','Laurna','Priest Bot','','0','85','85','2','80','80','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','5','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70097','0','0','0','0','0','1706','0','1706','0','Kal','Druid Bot','','0','85','85','2','80','80','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','11','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('70098','0','0','0','0','0','4296','0','4296','0','Harruk','Hunter Bot','','0','85','85','2','29','29','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','3','3','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70099','0','0','0','0','0','4299','0','4299','0','Reban','Hunter bot','','0','85','85','2','104','104','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','3','3','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70100','0','0','0','0','0','4304','0','4304','0','Bolyun','Hunter Bot','','0','85','85','2','80','80','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','3','3','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70101','0','0','0','0','0','1897','0','1897','0','Taijin','Priest Bot','','0','85','85','2','126','126','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','5','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70102','0','0','0','0','0','4068','0','4068','0','Kenjai','Priest Bot','','0','85','85','2','126','126','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','5','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70103','0','0','0','0','0','2066','0','2066','0','Danlaar','Hunter Bot','','0','85','85','2','80','80','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','3','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70104','0','0','0','0','0','2196','0','2196','0','Ariasta','Warrior Bot','','0','85','85','2','80','80','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','1','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70105','0','0','0','0','0','2198','0','2198','0','Sildanair','Warrior Bot','','0','85','85','2','80','80','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','1','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70106','0','0','0','0','0','2200','0','2200','0','Astarii','Priest Bot','','0','85','85','2','80','80','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','5','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70107','0','0','0','0','0','2201','0','2201','0','Jandria','Priest Bot','','0','85','85','2','80','80','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','5','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70108','0','0','0','0','0','2202','0','2202','0','Lariia','Priest Bot','','0','85','85','2','80','80','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','5','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70109','0','0','0','0','0','2231','0','2231','0','Syurna','Rogue Bot','','0','85','85','2','80','80','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','4','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('70110','0','0','0','0','0','7669','0','7669','0','Elissa','Mage Bot','','0','85','85','2','80','80','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','8','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70111','0','0','0','0','0','2252','0','2252','0','Erion','Rogue Bot','','0','85','85','2','80','80','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','4','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('70112','0','0','0','0','0','2243','0','2243','0','Anishar','Rogue Bot','','0','85','85','2','80','80','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','4','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('70113','0','0','0','0','0','2250','0','2250','0','Denatharion','Druid Bot','','0','85','85','2','80','80','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','11','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('70114','0','0','0','0','0','2255','0','2255','0','Fylerian','Druid Bot','','0','85','85','2','80','80','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','11','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('70115','0','0','0','0','0','2416','0','2416','0','Caelyb','Hunter Bot','','0','85','85','2','80','80','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','3','3','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70116','0','0','0','0','0','2675','0','2675','0','Kaal','Warlock Bot','','0','85','85','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','9','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('70117','0','0','0','0','0','16800','0','16800','0','Lana','Warlock Bot','','0','85','85','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','9','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('70118','0','0','0','0','0','2646','0','2646','0','Richard','Warlock Bot','','0','85','85','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','9','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('70119','0','0','0','0','0','10214','0','10214','0','Kaelystia','Mage Bot','','0','85','85','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','8','5','0','0','0','6','1','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70120','0','0','0','0','0','2644','0','2644','0','Pierce','Mage Bot','','0','85','85','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','8','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70121','0','0','0','0','0','2657','0','2657','0','Anastasia','Mage Bot','','0','85','85','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','8','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70122','0','0','0','0','0','2620','0','2620','0','Chris','Warrior Bot','','0','85','85','2','68','68','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','1','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70123','0','0','0','0','0','2658','0','2658','0','Angela','Warrior Bot','','0','85','85','2','68','68','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','1','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70124','0','0','0','0','0','2614','0','2614','0','Baltus','Warrior Bot','','0','85','85','2','68','68','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','1','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70125','0','0','0','0','0','3054','0','3054','0','Kelv','Warrior Bot','','0','85','85','2','55','55','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','1','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70126','0','0','0','0','0','3055','0','3055','0','Bilban','Warrior Bot','','0','85','85','2','875','875','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','1','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70127','0','0','0','0','0','3056','0','3056','0','Daera','Hunter Bot','','0','85','85','2','55','55','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','3','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70128','0','0','0','0','0','3072','0','3072','0','Olmin','Hunter Bot','','0','85','85','2','55','55','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','3','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70129','0','0','0','0','0','3073','0','3073','0','Regnus','Hunter Bot','','0','85','85','2','55','55','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','3','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70130','0','0','0','0','0','3086','0','3086','0','Theodrus','Priest Bot','','0','85','85','2','55','55','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','5','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70131','0','0','0','0','0','3066','0','3066','0','Braenna','Priest Bot','','0','85','85','2','55','55','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','5','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70132','0','0','0','0','0','3085','0','3085','0','Toldren','Priest Bot','','0','85','85','2','55','55','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','5','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70134','0','0','0','0','0','3108','0','3108','0','Bink','Mage Bot','','0','85','85','2','875','875','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','8','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70135','0','0','0','0','0','10214','0','10214','0','Juli','Mage Bot','','0','85','85','2','875','875','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','8','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70136','0','0','0','0','0','3109','0','3109','0','Nittegousse','Mage Bot','','0','85','85','2','55','55','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','8','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70137','0','0','0','0','0','3089','0','3089','0','Valgar','Paladin Bot','','0','85','85','2','55','55','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','2','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('70138','0','0','0','0','0','3088','0','3088','0','Beldruk','Paladin Bot','','0','85','85','2','55','55','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','2','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('70139','0','0','0','0','0','3087','0','3087','0','Brandur','Paladin Bot','','0','85','85','2','55','55','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','2','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('70140','0','0','0','0','0','3101','0','3101','0','Hulfdan','Rogue Bot','','0','85','85','2','55','55','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','4','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('70141','0','0','0','0','0','3100','0','3100','0','Ormyr','Rogue Bot','','0','85','85','2','55','55','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','4','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('70142','0','0','0','0','0','3113','0','3113','0','Phenwick','Rogue Bot','','0','85','85','2','875','875','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','4','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('70143','0','0','0','0','0','3115','0','3115','0','Coeurdechardon','Warlock Bot','','0','85','85','2','55','55','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','9','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('70144','0','0','0','0','0','3116','0','3116','0','Eglantin','Warlock Bot','','0','85','85','2','875','875','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','9','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('70145','0','0','0','0','0','3122','0','3122','0','Alexander','Warlock Bot','','0','85','85','2','55','55','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','9','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('70146','0','0','0','0','0','3280','0','3280','0','Wu','Warrior Bot','','0','85','85','2','12','12','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','1','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70147','0','0','0','0','0','3287','0','3287','0','Ilsa','Warrior Bot','','0','85','85','2','12','12','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','1','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70148','0','0','0','0','0','3283','0','3283','0','Joshua','Priest Bot','','0','85','85','2','12','12','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','5','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70149','0','0','0','0','0','3284','0','3284','0','Arthur','Paladin Bot','','0','85','85','2','12','12','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','2','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('70150','0','0','0','0','0','3289','0','3289','0','Katherine','Paladin Bot','','0','85','85','2','12','12','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','2','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('70151','0','0','0','0','0','3291','0','3291','0','Deline','Warlock Bot','','0','85','85','2','12','12','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','9','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('70152','0','0','0','0','0','3286','0','3286','0','Sandahl','Warlock Bot','','0','85','85','2','12','12','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','9','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('70153','0','0','0','0','0','3292','0','3292','0','Jennea','Mage Bot','','0','85','85','2','12','12','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','8','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70154','0','0','0','0','0','19803','0','19803','0','Elsharin','Mage Bot','','0','85','85','2','12','12','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','8','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70155','0','0','0','0','0','3299','0','3299','0','Kaerbrus','Hunter Bot','','0','85','85','2','80','80','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','3','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70156','0','0','0','0','0','3300','0','3300','0','Sheldras','Druid Bot','','0','85','85','2','12','12','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','11','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('70157','0','0','0','0','0','3301','0','3301','0','Theridran','Druid Bot','','0','85','85','2','80','80','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','11','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('70158','0','0','0','0','0','3312','0','3312','0','Einris','Hunter Bot','','0','85','85','2','12','12','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','3','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70159','0','0','0','0','0','3309','0','3309','0','Ulfir','Hunter Bot','','0','85','85','2','12','12','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','3','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70160','0','0','0','0','0','3310','0','3310','0','Thorfin','Hunter Bot','','0','85','85','2','12','12','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','3','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70161','0','0','0','0','0','10171','0','10171','0','UnThuwa','Mage Bot','','0','85','85','2','126','126','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','8','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70162','0','0','0','0','0','4524','0','4524','0','Pephredo','Mage Bot','','0','85','85','2','29','29','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','8','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70163','0','0','0','0','0','4522','0','4522','0','Enyo','Mage Bot','','0','85','85','2','29','29','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','8','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70164','0','0','0','0','0','4526','0','4526','0','Mai','Mage Bot','','0','85','85','2','126','126','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','8','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70165','0','0','0','0','0','4523','0','4523','0','Deino','Mage Bot','','0','85','85','2','29','29','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','8','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70166','0','0','0','0','0','4665','0','4665','0','Birgitte','Mage Bot','','0','85','85','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','8','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70167','0','0','0','0','0','12849','0','12849','0','Thuul','Mage Bot','','0','85','85','2','29','29','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','8','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70168','0','0','0','0','0','4690','0','4690','0','Zayus','Priest Bot','','0','85','85','2','29','29','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','5','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70169','0','0','0','0','0','10473','0','10473','0','Xyera','Priest Bot','','0','85','85','2','29','29','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','5','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70170','0','0','0','0','0','4711','0','4711','0','Urkyo','Priest Bot','','0','85','85','2','29','29','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','5','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70171','0','0','0','0','0','6060','0','6060','0','Uthelnay','Mage Bot','','0','85','85','2','126','126','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','8','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70172','0','0','0','0','0','6072','0','6072','0','Dink','Mage Bot','','0','85','85','2','875','875','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','8','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70173','0','0','0','0','0','6071','0','6071','0','Darnath','Warrior Bot','','0','85','85','2','80','80','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','1','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70174','0','0','0','0','0','7356','0','7356','0','Karman','Paladin Bot','','0','85','85','2','894','894','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','2','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('70175','0','0','0','0','0','11037','0','11037','0','Evencane','Warrior Bot','','0','85','85','2','894','894','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','1','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70176','0','0','0','0','0','7357','0','7357','0','Jannos','Druid Bot','','0','85','85','2','104','104','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','11','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('70177','0','0','0','0','0','7538','0','7538','0','Alenndaar','Hunter Bot','','0','85','85','2','1076','1076','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','3','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70178','0','0','0','0','0','10738','0','10738','0','Golhine','Druid Bot','','0','85','85','2','80','80','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','11','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('70179','0','0','0','0','0','9337','0','9337','0','Hesuwa','Hunter Bot','','0','85','85','2','104','104','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','3','3','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70180','0','0','0','0','0','9336','0','9336','0','Xao\'tsu','Hunter Bot','','0','85','85','2','29','29','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','3','3','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70181','0','0','0','0','0','9338','0','9338','0','Belia','Hunter Bot','','0','85','85','2','55','55','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','3','3','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70182','0','0','0','0','0','10245','0','10245','0','Dargh','Hunter Bot','','0','85','85','2','55','55','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','3','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70183','0','0','0','0','0','11044','0','11044','0','Meideros','Priest Bot','','0','85','85','2','80','80','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','5','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70184','0','0','0','0','0','11048','0','11048','0','Presse','Priest Bot','','0','85','85','2','1076','1076','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','5','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70185','0','0','0','0','0','11053','0','11053','0','Rohan','Priest Bot','','0','85','85','2','122','122','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','5','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70186','0','0','0','0','0','12053','0','12053','0','Loganaar','Druid Bot','','0','85','85','2','994','994','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','11','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('70187','0','0','0','0','0','13171','0','13171','0','Romano','Rogue Bot','','0','85','85','2','12','12','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','4','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('70188','0','0','0','0','0','13341','0','13341','0','Sagorne','Shaman Bot','','0','85','85','2','104','104','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','7','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('70189','0','0','0','0','0','15522','0','15522','0','Julia','Mage Bot','','0','85','85','2','1604','1604','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','8','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70190','0','0','0','0','0','15511','0','15511','0','Jesthenis','Paladin Bot','','0','85','85','2','1604','1604','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','2','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('70191','0','0','0','0','0','15524','0','15524','0','Invocateur','Warlock Bot','','0','85','85','2','1604','1604','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','9','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('70192','0','0','0','0','0','15518','0','15518','0','Matrone','Priest Bot','','0','85','85','2','1604','1604','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','5','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70193','0','0','0','0','0','2659','0','2659','0','Eclaireur','Rogue Bot','','0','85','85','2','68','68','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','4','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('70194','0','0','0','0','0','15520','0','15520','0','Sallina','Hunter Bot','','0','85','85','2','1604','1604','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','3','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70195','0','0','0','0','0','16685','0','16685','0','Noellene','Paladin Bot','','0','85','85','2','1604','1604','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','2','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('70196','0','0','0','0','0','16707','0','16707','0','Ponaris','Priest Bot','','0','85','85','2','1604','1604','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','5','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70197','0','0','0','0','0','16222','0','16222','0','Keilnei','Hunter Bot','','0','85','85','2','1638','1638','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','3','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70198','0','0','0','0','0','16223','0','16223','0','Valaatu','Mage Bot','','0','85','85','2','1638','1638','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','8','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70199','0','0','0','0','0','16224','0','16224','0','Aurelon','Paladin Bot','','0','85','85','2','1638','1638','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','2','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('70200','0','0','0','0','0','16225','0','16225','0','Zalduun','Priest Bot','','0','85','85','2','1638','1638','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','5','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70201','0','0','0','0','0','16226','0','16226','0','Kore','Warrior Bot','','0','85','85','2','1638','1638','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','1','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70202','0','0','0','0','0','16787','0','16787','0','Alamma','Warlock Bot','','0','85','85','2','1604','1604','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','9','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('70203','0','0','0','0','0','16800','0','16800','0','Talionia','Warlock Bot','','0','85','85','2','1604','1604','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','9','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('70204','0','0','0','0','0','16831','0','16831','0','Zanien','Hunter Bot','','0','85','85','2','1604','1604','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','9','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70205','0','0','0','0','0','16781','0','16781','0','Zaedana','Mage Bot','','0','85','85','2','1604','1604','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','8','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70206','0','0','0','0','0','16824','0','16824','0','Quithas','Mage Bot','','0','85','85','2','1604','1604','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','8','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70207','0','0','0','0','0','16739','0','16739','0','Harene','Druid Bot','','0','85','85','2','1604','1604','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','11','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('70208','0','0','0','0','0','16778','0','16778','0','Tana','Hunter Bot','','0','85','85','2','1604','1604','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','3','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70209','0','0','0','0','0','16816','0','16816','0','Oninath','Hunter Bot','','0','85','85','2','1604','1604','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','3','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70210','0','0','0','0','0','16829','0','16829','0','Bachi','Paladin Bot','','0','85','85','2','1604','1604','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','2','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('70211','0','0','0','0','0','16767','0','16767','0','Zelanis','Rogue Bot','','0','85','85','2','1604','1604','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','4','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('70212','0','0','0','0','0','16798','0','16798','0','Elara','Rogue Bot','','0','85','85','2','1604','1604','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','4','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('70213','0','0','0','0','0','16858','0','16858','0','Shalannius','Druid Bot','','0','85','85','2','1638','1638','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','11','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('70214','0','0','0','0','0','17434','0','17434','0','Deremiis','Hunter Bot','','0','85','85','2','1638','1638','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','3','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70215','0','0','0','0','0','17247','0','17247','0','Caedmos','Priest Bot','','0','85','85','2','1638','1638','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','5','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70216','0','0','0','0','0','17225','0','17225','0','Baatun','Paladin Bot','','0','85','85','2','1638','1638','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','2','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('70217','0','0','0','0','0','17212','0','17212','0','Ahonan','Warrior Bot','','0','85','85','2','1638','1638','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','1','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70218','0','0','0','0','0','17598','0','17598','0','Firmanvaar','Shaman Bot','','0','85','85','2','1638','1638','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','7','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('70219','0','0','0','0','0','16860','0','16860','0','Actron','Hunter Bot','','0','85','85','2','1638','1638','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','3','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70220','0','0','0','0','0','17213','0','17213','0','Behomat','Warrior Bot','','0','85','85','2','1638','1638','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','1','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70221','0','0','0','0','0','17600','0','17600','0','Nobundo','Shaman Bot','','0','85','85','2','1638','1638','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','7','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('70222','0','0','0','0','0','17599','0','17599','0','Tuluun','Shaman Bot','','0','85','85','2','1638','1638','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','7','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('70223','0','0','0','0','0','16914','0','16914','0','Sulaa','Shaman Bot','','0','85','85','2','1638','1638','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','7','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('70224','0','0','0','0','0','17215','0','17215','0','Ruada','Warrior Bot','','0','85','85','2','1638','1638','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','1','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70225','0','0','0','0','0','17233','0','17233','0','Semid','Mage Bot','','0','85','85','2','1638','1638','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','8','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70226','0','0','0','0','0','17232','0','17232','0','Guvan','Priest Bot','','0','85','85','2','1638','1638','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','5','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70227','0','0','0','0','0','17234','0','17234','0','Tullas','Paladin Bot','','0','85','85','2','1638','1638','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','2','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('70228','0','0','0','0','0','17488','0','17488','0','Killac','Hunter bot','','0','85','85','2','1638','1638','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','3','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70229','0','0','0','0','0','17226','0','17226','0','Jol','Paladin Bot','','0','85','85','2','1638','1638','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','2','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('70230','0','0','0','0','0','17248','0','17248','0','Fallat','Priest Bot','','0','85','85','2','1638','1638','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','5','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70231','0','0','0','0','0','17243','0','17243','0','Harnan','Mage Bot','','0','85','85','2','1638','1638','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','8','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70232','0','0','0','0','0','17241','0','17241','0','Bati','Mage Bot','','0','85','85','2','1638','1638','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','8','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70233','0','0','0','0','0','17792','0','17792','0','Hobahken','Shaman Bot','','0','85','85','2','1638','1638','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','7','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('70234','0','0','0','0','0','6820','0','6820','0','Gurrag','Shaman Bot','','0','85','85','2','1638','1638','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','7','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('70235','0','0','0','0','0','19596','0','19596','0','Auberose','Paladin Bot','','0','85','85','2','1602','1602','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','2','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('70236','0','0','0','0','0','10335','10335','10335','10335','Afina','Priest Bot','','0','85','85','2','35','35','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','5','2','0','0','0','7','1','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','1','1','1048688','priest_bot','0'),
+('70237','0','0','0','0','0','1132','0','1132','0','Voidwalker','Warlock\'s Pet Bot',NULL,'0','85','85','2','14','14','0','1.2','1.3','1','0','2','3','0','0','1','2000','2000','1','0','0','0','16','0','1','0','0','0','0','3','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','1','1','1048688','voidwalker_bot','0'),
+('70238','0','0','0','0','0','1105','0','0','0','Hunter\'s Pet',NULL,NULL,'0','85','85','0','14','14','0','1.1','1.14286','1','0','87','117','0','214','1','2000','0','1','0','0','0','7','0','1','0','61','90','21','1','1','0','0','0','0','0','0','0','0','0','5708','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','149','1','0','0','','0');
+
+-- EQUIPS --
+
+delete from `creature_equip_template` where entry between 70001 and 70238;
+
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70001','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70002','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70003','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70004','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70005','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70006','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70007','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70008','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70009','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70010','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70011','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70012','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70013','1','18002','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70014','1','27903','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70015','1','7723','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70016','1','13984','6448','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70017','1','13984','6448','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70018','1','6633','820','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70019','1','13984','6448','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70020','1','12584','18825','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70021','1','18876','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70022','1','12584','18825','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70023','1','18876','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70024','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70025','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70026','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70027','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70028','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70029','1','28367','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70030','1','12584','18825','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70031','1','13984','6448','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70032','1','27903','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70033','1','18002','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70034','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70035','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70036','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70037','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70038','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70039','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70041','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70042','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70043','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70044','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70045','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70046','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70047','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70048','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70049','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70050','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70051','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70052','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70053','1','18002','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70054','1','27903','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70055','1','28367','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70056','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70057','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70058','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70059','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70060','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70061','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70062','1','28367','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70063','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70064','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70065','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70066','1','18002','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70067','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70068','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70069','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70070','1','27903','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70071','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70072','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70073','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70074','1','18002','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70075','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70076','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70077','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70078','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70079','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70080','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70081','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70082','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70083','1','7723','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70084','1','18002','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70085','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70086','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70087','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70088','1','27903','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70089','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70090','1','28367','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70091','1','6633','820','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70092','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70093','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70094','1','18002','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70095','1','13984','6448','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70096','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70097','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70098','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70099','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70100','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70101','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70102','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70103','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70104','1','7723','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70105','1','18002','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70106','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70107','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70108','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70109','1','13984','6448','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70110','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70111','1','6633','820','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70112','1','13984','6448','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70113','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70114','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70115','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70116','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70117','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70118','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70119','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70120','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70121','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70122','1','27903','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70123','1','18002','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70124','1','7723','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70125','1','18002','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70126','1','28367','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70127','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70128','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70129','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70130','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70131','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70132','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70134','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70135','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70136','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70137','1','18876','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70138','1','12584','18825','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70139','1','18876','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70140','1','6633','820','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70141','1','13984','6448','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70142','1','6633','820','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70143','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70144','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70145','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70146','1','27903','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70147','1','18002','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70148','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70149','1','12584','18825','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70150','1','18876','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70151','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70152','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70153','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70154','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70155','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70156','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70157','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70158','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70159','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70160','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70161','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70162','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70163','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70164','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70165','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70166','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70167','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70168','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70169','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70170','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70171','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70172','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70173','1','28367','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70174','1','12584','18825','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70175','1','7723','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70176','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70177','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70178','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70179','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70180','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70181','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70182','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70183','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70184','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70185','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70186','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70187','1','13984','6448','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70188','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70189','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70191','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70192','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70193','1','13984','6448','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70194','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70195','1','12584','18826','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70196','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70197','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70198','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70199','1','18876','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70200','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70201','1','27903','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70202','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70203','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70204','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70205','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70206','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70207','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70208','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70209','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70210','1','12584','18826','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70211','1','6633','820','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70212','1','13984','6448','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70213','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70214','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70215','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70216','1','18876','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70217','1','28367','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70218','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70219','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70220','1','18002','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70221','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70222','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70223','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70224','1','27903','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70225','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70226','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70227','1','12584','18825','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70229','1','18876','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70230','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70231','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70232','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70233','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70234','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70235','1','29175','18826','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70236','1','31289','0','0');
+
+
+
+-- Customize section
+-- You can create your own values to be in line with your own server if these are not acceptable.
+
+-- Add flags_extra
+SET @EX_NO_BLOCK = 16;
+SET @EX_NO_CRUSH = 32;
+SET @EX_NO_XP = 64;
+SET @EX_DIMINISH = 1048576;
+SET @FLAGS_EX = @EX_NO_BLOCK | @EX_NO_CRUSH | @EX_NO_XP | @EX_DIMINISH;
+
+-- minions
+UPDATE `creature_template` SET exp:=3, dmg_multiplier:=1.0, attackpower:=0, mindmg:=2, maxdmg:=4, minlevel:=85, maxlevel:=85, baseattacktime:=2200, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, AIName='' where entry >= 70000 && entry < 70239 and subname='Druid Bot';
+UPDATE `creature_template` SET exp:=3, dmg_multiplier:=1.0, attackpower:=0, mindmg:=2, maxdmg:=3, minlevel:=85, maxlevel:=85, baseattacktime:=2800, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, AIName='' where entry >= 70000 && entry < 70239 and subname='Hunter Bot';
+UPDATE `creature_template` SET exp:=3, dmg_multiplier:=1.0, attackpower:=0, mindmg:=1, maxdmg:=1, minlevel:=85, maxlevel:=85, baseattacktime:=3800, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, AIName='' where entry >= 70000 && entry < 70239 and subname='Mage Bot';
+UPDATE `creature_template` SET exp:=3, dmg_multiplier:=1.0, attackpower:=0, mindmg:=2, maxdmg:=4, minlevel:=85, maxlevel:=85, baseattacktime:=2300, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, AIName='' where entry >= 70000 && entry < 70239 and subname='Paladin Bot';
+UPDATE `creature_template` SET exp:=3, dmg_multiplier:=1.0, attackpower:=0, mindmg:=1, maxdmg:=1, minlevel:=85, maxlevel:=85, baseattacktime:=3600, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, AIName='' where entry >= 70000 && entry < 70239 and subname='Priest Bot';
+UPDATE `creature_template` SET exp:=3, dmg_multiplier:=1.0, attackpower:=0, mindmg:=1, maxdmg:=2, minlevel:=85, maxlevel:=85, baseattacktime:=1600, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, AIName='' where entry >= 70000 && entry < 70239 and subname='Rogue Bot';
+UPDATE `creature_template` SET exp:=3, dmg_multiplier:=1.0, attackpower:=0, mindmg:=1, maxdmg:=2, minlevel:=85, maxlevel:=85, baseattacktime:=2600, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, AIName='' where entry >= 70000 && entry < 70239 and subname='Shaman Bot';
+UPDATE `creature_template` SET exp:=3, dmg_multiplier:=1.0, attackpower:=0, mindmg:=1, maxdmg:=1, minlevel:=85, maxlevel:=85, baseattacktime:=3500, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, AIName='' where entry >= 70000 && entry < 70239 and subname='Warlock Bot';
+UPDATE `creature_template` SET exp:=3, dmg_multiplier:=1.0, attackpower:=0, mindmg:=3, maxdmg:=5, minlevel:=85, maxlevel:=85, baseattacktime:=3400, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, AIName='' where entry >= 70000 && entry < 70239 and subname='Warrior Bot';
+
+-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		
+-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	
+-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		
+-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	
+-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		
+-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		
+-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	
+-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	
+-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	
+
+-- pets
+UPDATE `creature_template` SET exp:=3, dmg_multiplier:=1.0, attackpower:=0, mindmg:= 2, maxdmg:= 3, minlevel:=85, maxlevel:=85, baseattacktime:=2000, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, AIName='' where entry between 70001 and 70239 and name='Voidwalker';
+
+
diff --git a/src/server/game/AI/NpcBots/bot_GridNotifiers.h b/src/server/game/AI/NpcBots/bot_GridNotifiers.h
new file mode 100644
index 0000000..70637f8
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_GridNotifiers.h
@@ -0,0 +1,461 @@
+/*
+Name: bot_GridNotifiers
+%Complete: 91+
+Comment: Custom grid notifiers for Bot system by Graff (onlysuffering@gmail.com)
+Category: creature_cripts/custom/bots/grids
+*/
+
+#ifndef _BOT_GRIDNOTIFIERS_H
+#define _BOT_GRIDNOTIFIERS_H
+
+#include "Group.h"
+#include "Player.h"
+#include "SpellAuras.h"
+#include "bot_ai.h"
+
+class NearestHostileUnitCheck
+{
+    public:
+        explicit NearestHostileUnitCheck(Unit const* unit, float dist, bool magic, bot_ai const* m_ai, bool targetCCed = false) : 
+        me(unit), m_range(dist), byspell(magic), ai(m_ai), AttackCCed(targetCCed) { }
+        bool operator()(Unit* u)
+        {
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (!ai->CanBotAttack(u, byspell))
+                return false;
+            if (ai->InDuel(u))
+                return false;
+            if (!AttackCCed && (u->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING | UNIT_STATE_DISTRACTED | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE)))
+                return false;//do not allow CCed units if checked
+            //if (u->HasUnitState(UNIT_STATE_CASTING) && (u->GetTypeId() == TYPEID_PLAYER || u->IsPet()))
+            //    for (uint8 i = 0; i != CURRENT_MAX_SPELL; ++i)
+            //        if (Spell* spell = u->GetCurrentSpell(i))
+            //            if (ai->IsInBotParty(spell->m_targets.GetUnitTarget()))
+            //                return true;
+            if (!ai->IsInBotParty(u->GetVictim()))
+                return false;
+
+            m_range = me->GetDistance(u);   // use found unit range as new range limit for next check
+            return true;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        bool byspell;
+        bot_ai const* ai;
+        bool AttackCCed;
+        NearestHostileUnitCheck(NearestHostileUnitCheck const&);
+};
+
+class HostileDispelTargetCheck
+{
+    public:
+        explicit HostileDispelTargetCheck(Unit const* unit, float dist = 30, bool stealable = false, bot_ai const* m_ai = NULL) : 
+        me(unit), m_range(dist), checksteal(stealable), ai(m_ai) { }
+        bool operator()(Unit* u)
+        {
+            if (u->IsWithinDistInMap(me, m_range) && 
+                u->IsAlive() && 
+                u->InSamePhase(me) && 
+                u->IsInCombat() && 
+                u->isTargetableForAttack() && 
+                u->IsVisible() && 
+                u->GetReactionTo(me) < REP_NEUTRAL && 
+                ai->IsInBotParty(u->GetVictim()))
+            {
+                if (checksteal && u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(30449))) return false;//immune to steal
+                if (!checksteal)
+                {
+                    if (me->getLevel() >= 70 && u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(32375))) return false;//immune to mass dispel
+                    if (me->getLevel() < 70 && u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(527))) return false;//immune to direct dispel
+                }
+                Unit::AuraMap const &Auras = u->GetOwnedAuras();
+                for (Unit::AuraMap::const_iterator itr = Auras.begin(); itr != Auras.end(); ++itr)
+                {
+                    Aura* aura = itr->second;
+                    SpellInfo const* Info = aura->GetSpellInfo();
+                    if (Info->Dispel != DISPEL_MAGIC) continue;
+                    if (Info->Attributes & (SPELL_ATTR0_PASSIVE | SPELL_ATTR0_HIDDEN_CLIENTSIDE)) continue;
+                    if (checksteal && (Info->AttributesEx4 & SPELL_ATTR4_NOT_STEALABLE)) continue;
+                    AuraApplication* aurApp = aura->GetApplicationOfTarget(u->GetGUID());
+                    if (aurApp && aurApp->IsPositive())
+                    {
+                        const std::string name = Info->SpellName;
+                        if (name == "Vengeance" || name == "Bloody Vengeance")
+                            continue;
+                        return true;
+                    }
+                }
+            }
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        bool checksteal;
+        bot_ai const* ai;
+        HostileDispelTargetCheck(HostileDispelTargetCheck const&);
+};
+
+class AffectedTargetCheck
+{
+    public:
+        explicit AffectedTargetCheck(uint64 casterguid, float dist, uint32 spellId, Player const* groupCheck = 0, uint8 hostileCheckType = 0) : 
+        caster(casterguid), m_range(dist), spell(spellId), checker(groupCheck), needhostile(hostileCheckType)
+        { if (checker->GetTypeId() != TYPEID_PLAYER) return; gr = checker->GetGroup(); }
+        bool operator()(Unit* u)
+        {
+            if (caster && u->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE))
+                return false;
+            if (needhostile == 0 && !u->IsHostileTo(checker)) return false;
+            if (needhostile == 1 && !(gr && gr->IsMember(u->GetGUID()) && u->GetTypeId() == TYPEID_PLAYER)) return false;
+            if (needhostile == 2 && !(gr && gr->IsMember(u->GetGUID()))) return false;
+            if (needhostile == 3 && !u->IsFriendlyTo(checker)) return false;
+
+            if (u->IsAlive() && checker->IsWithinDistInMap(u, m_range))
+            {
+                Unit::AuraMap const &Auras = u->GetOwnedAuras();
+                for (Unit::AuraMap::const_iterator itr = Auras.begin(); itr != Auras.end(); ++itr)
+                {
+                    Aura* aura = itr->second;
+                    if (aura->GetId() == spell)
+                        if (caster == 0 || aura->GetCasterGUID() == caster)
+                            return true;
+                }
+            }
+            return false;
+        }
+    private:
+        uint64 const caster;
+        float m_range;
+        uint32 const spell;
+        Player const* checker;
+        uint8 needhostile;
+        Group const* gr;
+        AffectedTargetCheck(AffectedTargetCheck const&);
+};
+
+class PolyUnitCheck
+{
+    public:
+        explicit PolyUnitCheck(Unit const* unit, float dist, Unit const* currTarget) : me(unit), m_range(dist), mytar(currTarget) {}
+        bool operator()(Unit* u)
+        {
+            if (u == mytar)
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->IsInCombat() || !u->IsAlive() || !u->GetVictim())
+                return false;
+            if (u->GetCreatureType() != CREATURE_TYPE_HUMANOID && 
+                u->GetCreatureType() != CREATURE_TYPE_BEAST)
+                return false;
+            if (me->GetDistance(u) < 6 || mytar->GetDistance(u) < 5 || u->GetHealthPct() < 70)
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (!u->getAttackers().empty())
+                return false;
+            if (!u->IsHostileTo(me))
+                return false;
+            if (u->IsPolymorphed() || 
+                u->isFrozen() || 
+                u->isInRoots() || 
+                u->HasAura(51514)/*hex*/ || 
+                u->HasAura(20066)/*repentance*/ || 
+                //u->HasAuraTypeWithAffectMask(SPELL_AURA_PERIODIC_DAMAGE, sSpellMgr->GetSpellInfo(339)) || //entangling roots
+                //u->HasAuraTypeWithAffectMask(SPELL_AURA_PERIODIC_DAMAGE, sSpellMgr->GetSpellInfo(16914)) || //hurricane
+                //u->HasAuraTypeWithAffectMask(SPELL_AURA_PERIODIC_DAMAGE, sSpellMgr->GetSpellInfo(10)) || //blizzard
+                //u->HasAuraTypeWithAffectMask(SPELL_AURA_PERIODIC_DAMAGE, sSpellMgr->GetSpellInfo(2121)) || //flamestrike
+                //u->HasAuraTypeWithAffectMask(SPELL_AURA_PERIODIC_DAMAGE, sSpellMgr->GetSpellInfo(20116)) || //consecration
+                u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+                return false;
+            if (!u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(12826)))//Polymorph rank 4
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        Unit const* mytar;
+        PolyUnitCheck(PolyUnitCheck const&);
+};
+
+class FearUnitCheck
+{
+    public:
+        explicit FearUnitCheck(Unit const* unit, float dist = 30) : me(unit), m_range(dist) {}
+        bool operator()(Unit* u)
+        {
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (u->GetCreatureType() == CREATURE_TYPE_UNDEAD)
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (u->getAttackers().size() > 1 && u->GetVictim() != me)
+                return false;
+            if (u->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING | UNIT_STATE_DISTRACTED | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE))
+                return false;
+            if (u->isFeared())
+                return false;
+            if (u->GetReactionTo(me) > REP_NEUTRAL)
+                return false;
+            
+            if (!u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(5782)))//fear rank1
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        FearUnitCheck(FearUnitCheck const&);
+};
+
+class StunUnitCheck
+{
+    public:
+        explicit StunUnitCheck(Unit const* unit, float dist = 20) : me(unit), m_range(dist) {}
+        bool operator()(Unit* u)
+        {
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (me->GetVictim() == u)
+                return false;
+            if (me->GetTypeId() == TYPEID_UNIT)
+                if (Player* mymaster = me->ToCreature()->GetBotOwner())
+                    if (mymaster->GetVictim() == u)
+                        return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (u->GetReactionTo(me) > REP_NEUTRAL)
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            if (!u->getAttackers().empty())
+                return false;
+            if (u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+                return false;
+            if (!(u->GetCreatureType() == CREATURE_TYPE_HUMANOID || 
+                u->GetCreatureType() == CREATURE_TYPE_DEMON || 
+                u->GetCreatureType() == CREATURE_TYPE_DRAGONKIN || 
+                u->GetCreatureType() == CREATURE_TYPE_GIANT || 
+                u->GetCreatureType() == CREATURE_TYPE_UNDEAD))
+                return false;
+            if (me->GetDistance(u) < 10)//do not allow close cast to prevent break due to consecration
+                return false;
+            if (u->IsPolymorphed() || 
+                u->HasAura(51514)/*hex*/ || 
+                u->HasAura(20066)/*repentance*/ || 
+                u->HasAuraWithMechanic(1<<MECHANIC_SHACKLE)/*shackleundead*/)
+                return false;
+            if (!u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(20066)))//repentance
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        StunUnitCheck(StunUnitCheck const&);
+};
+
+class UndeadCCUnitCheck
+{
+    public:
+        explicit UndeadCCUnitCheck(Unit const* unit, float dist = 30, uint32 spell = 0) : me(unit), m_range(dist), m_spellId(spell) { if (!spell) return; }
+        bool operator()(Unit* u)
+        {
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (u->GetReactionTo(me) > REP_NEUTRAL)
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (me->GetVictim() == u && u->GetVictim() == me)
+                return false;
+            if (!u->getAttackers().empty())
+                return false;
+            if (u->GetCreatureType() != CREATURE_TYPE_UNDEAD && 
+                (m_spellId == 9484 || m_spellId == 9485 || m_spellId == 10955))//shackle undead
+                return false;
+            //most horrible hacks
+            if (u->GetCreatureType() != CREATURE_TYPE_UNDEAD && 
+                u->GetCreatureType() != CREATURE_TYPE_DEMON && 
+                (m_spellId == 2812 || m_spellId == 10318 || //holy
+                m_spellId == 27139 || m_spellId == 48816 || //wra
+                m_spellId == 48817 ||                       //th or
+                m_spellId == 10326))                        //turn evil
+                return false;
+            if (u->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING | UNIT_STATE_DISTRACTED | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE))
+                return false;
+            if (u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) && 
+                (m_spellId == 9484 || m_spellId == 9485 || m_spellId == 10955))//shackle undead
+                return false;
+            if (!u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(m_spellId)))
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        uint32 m_spellId;
+        UndeadCCUnitCheck(UndeadCCUnitCheck const&);
+};
+
+class RootUnitCheck
+{
+    public:
+        explicit RootUnitCheck(Unit const* unit, Unit const* mytarget, float dist = 30, uint32 spell = 0) : me(unit), curtar(mytarget), m_range(dist), m_spellId(spell)
+        { if (!spell) return; }
+        bool operator()(Unit* u)
+        {
+            if (u == curtar)
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (me->GetDistance(u) < 8)
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            if (u->GetReactionTo(me) > REP_NEUTRAL)
+                return false;
+            if (u->isFrozen() || u->isInRoots())
+                return false;
+            if (!u->getAttackers().empty())
+                return false;
+            if (u->IsPolymorphed() || 
+                u->HasAura(51514)/*hex*/ || 
+                u->HasAura(20066)/*repentance*/ || 
+                u->HasAuraWithMechanic(1<<MECHANIC_SHACKLE)/*shackleundead*/)
+                return false;
+            if (!u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(m_spellId)))
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        Unit const* curtar;
+        float m_range;
+        uint32 m_spellId;
+        RootUnitCheck(RootUnitCheck const&);
+};
+
+class CastingUnitCheck
+{
+    public:
+        explicit CastingUnitCheck(Unit const* unit, float dist = 30, bool friendly = false, uint32 spell = 0) : me(unit), m_range(dist), m_friend(friendly), m_spell(spell) { if (!m_spell) return; }
+        bool operator()(Unit* u)
+        {
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (!m_friend && !u->isTargetableForAttack())
+                return false;
+            //if (!m_friend && u->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SILENCED))//prevent double silence
+            //    return false;
+            if (!u->IsNonMeleeSpellCasted(false))
+                return false;
+            if (m_friend == (u->GetReactionTo(me) < REP_FRIENDLY))
+                return false;
+            if (m_spell == 10326 && //turn evil
+                u->GetCreatureType() != CREATURE_TYPE_UNDEAD && 
+                u->GetCreatureType() != CREATURE_TYPE_DEMON)
+                return false;
+            if (m_spell == 20066 && //repentance
+                !(u->GetCreatureType() == CREATURE_TYPE_HUMANOID || 
+                u->GetCreatureType() == CREATURE_TYPE_DEMON || 
+                u->GetCreatureType() == CREATURE_TYPE_DRAGONKIN || 
+                u->GetCreatureType() == CREATURE_TYPE_GIANT || 
+                u->GetCreatureType() == CREATURE_TYPE_UNDEAD))
+                return false;
+            if (!m_spell || !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(m_spell)))
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        bool m_friend;
+        uint32 m_spell;
+        CastingUnitCheck(CastingUnitCheck const&);
+};
+
+class SecondEnemyCheck
+{
+    public:
+        explicit SecondEnemyCheck(Unit const* unit, float dist, Unit const* currtarget, bot_ai const* m_ai) : me(unit), m_range(dist), mytar(currtarget), ai(m_ai) {}
+        bool operator()(Unit* u)
+        {
+            if (u == mytar)
+                return false;//We need to find SECONDARY target
+            if (!u->IsInCombat())
+                return false;
+            if (u->isMoving() != mytar->isMoving())//only when both targets idle or both moving
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range + 1.f))//distance check
+                return false;
+            if (mytar->GetDistance(u) > 4)//not close enough to each other
+                return false;
+
+            if (ai->CanBotAttack(u))
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        Unit const* mytar;
+        bot_ai const* ai;
+        SecondEnemyCheck(SecondEnemyCheck const&);
+};
+
+#endif
diff --git a/src/server/game/AI/NpcBots/bot_ai.cpp b/src/server/game/AI/NpcBots/bot_ai.cpp
new file mode 100644
index 0000000..91b6372
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_ai.cpp
@@ -0,0 +1,3287 @@
+/*
+NpcBot System by Graff (onlysuffering@gmail.com)
+Original patch from: LordPsyan https://bitbucket.org/lordpsyan/trinitycore-patches/src/3b8b9072280e/Individual/11185-BOTS-NPCBots.patch
+TODO:
+Convert doCast events (CD etc.) into SpellHit()- and SpellHitTarget()-based
+Implement heal/tank/DD modes
+Implement Racial Abilities
+Implement Equipment Change (maybe)
+I NEED MORE
+*/
+
+#include "bot_ai.h"
+#include "bot_GridNotifiers.h"
+#include "CellImpl.h"
+#include "Chat.h"
+#include "Config.h"
+#include "GridNotifiers.h"
+#include "GridNotifiersImpl.h"
+#include "ScriptedGossip.h"
+#include "SpellAuraEffects.h"
+
+const uint8 GroupIconsFlags[TARGETICONCOUNT] =
+{
+    /*STAR        = */0x001,
+    /*CIRCLE      = */0x002,
+    /*DIAMOND     = */0x004,
+    /*TRIANGLE    = */0x008,
+    /*MOON        = */0x010,
+    /*SQUARE      = */0x020,
+    /*CROSS       = */0x040,
+    /*SKULL       = */0x080
+};
+
+bot_minion_ai::bot_minion_ai(Creature* creature): bot_ai(creature)
+{
+    Potion_cd = 0;
+    pvpTrinket_cd = 30000;
+    rezz_cd = 0;
+    evade_cd = 0;
+    myangle = 0.f;
+}
+bot_minion_ai::~bot_minion_ai() {}
+
+bot_pet_ai::bot_pet_ai(Creature* creature): bot_ai(creature)
+{
+    m_creatureOwner = me->GetCreatureOwner();
+    basearmor = 0;
+}
+bot_pet_ai::~bot_pet_ai(){}
+
+bot_ai::bot_ai(Creature* creature) : ScriptedAI(creature)
+{
+    master = me->GetBotOwner();
+    m_spellpower = 0;
+    haste = 0;
+    hit = 0.f;
+    regen_mp5 = 0.f;
+    m_TankGuid = 0;
+    tank = NULL;
+    extank = NULL;
+    info = NULL;
+    clear_cd = 2;
+    temptimer = 0;
+    wait = 15;
+    GC_Timer = 0;
+    checkAurasTimer = 20;
+    cost = 0;
+    doHealth = false;
+    doMana = false;
+    //shouldUpdateStats = true;
+    pos.m_positionX = 0.f;
+    pos.m_positionY = 0.f;
+    pos.m_positionZ = 0.f;
+    aftercastTargetGuid = 0;
+    currentSpell = 0;
+    tempMana = 0;
+    dmgmult_melee = sConfigMgr->GetFloatDefault("Bot.DamageMult.Melee", 1.0);
+    dmgmult_spell = sConfigMgr->GetFloatDefault("Bot.DamageMult.Spell", 1.0);
+    dmgmult_melee = std::max(dmgmult_melee, 0.01f);
+    dmgmult_spell = std::max(dmgmult_spell, 0.01f);
+    dmgmult_melee = std::min(dmgmult_melee, 10.f);
+    dmgmult_spell = std::min(dmgmult_spell, 10.f);
+    dmgmod_melee = Creature::_GetDamageMod(me->GetCreatureTemplate()->rank);
+    dmgmod_spell = me->GetSpellDamageMod(me->GetCreatureTemplate()->rank);
+    healTargetIconFlags = sConfigMgr->GetIntDefault("Bot.HealTargetIconsMask", 8);
+}
+bot_ai::~bot_ai(){}
+
+SpellCastResult bot_ai::checkBotCast(Unit* victim, uint32 spellId, uint8 botclass) const
+{
+    if (spellId == 0)
+        return SPELL_FAILED_DONT_REPORT;
+
+    if (InDuel(victim))
+        return SPELL_FAILED_DONT_REPORT;
+
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!spellInfo)
+        return SPELL_FAILED_DONT_REPORT;
+
+    if (!CheckImmunities(spellId, victim))
+        return SPELL_FAILED_DONT_REPORT;
+
+    if (Powers(spellInfo->PowerType) == me->getPowerType() &&
+        me->GetPower(me->getPowerType()) < spellInfo->CalcPowerCost(me, spellInfo->GetSchoolMask()))
+        return SPELL_FAILED_DONT_REPORT;
+
+    switch (botclass)
+    {
+        case CLASS_PALADIN:
+        case CLASS_MAGE:
+        case CLASS_PRIEST:
+        case CLASS_DRUID:
+        case CLASS_WARLOCK:
+        case CLASS_SHAMAN:
+            if (Feasting() && !master->IsInCombat() && !master->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+                return SPELL_FAILED_DONT_REPORT;
+            break;
+        case CLASS_WARRIOR:
+            //BladeStorm
+            if (me->HasAura(46924/*67541*/))
+                return SPELL_FAILED_DONT_REPORT;
+            break;
+        case CLASS_ROGUE:
+        case CLASS_HUNTER:
+        case CLASS_DEATH_KNIGHT:
+        default:
+            break;
+    }
+
+    return SPELL_CAST_OK;
+}
+
+bool bot_ai::doCast(Unit* victim, uint32 spellId, bool triggered, uint64 originalCaster)
+{
+    if (spellId == 0) return false;
+    if (me->IsMounted()) return false;
+    if (IsCasting()) return false;
+    if (!victim || !victim->IsInWorld() || me->GetMap() != victim->FindMap()) return false;
+
+    info = sSpellMgr->GetSpellInfo(spellId);
+    if (!info)
+        return false;
+
+    if (spellId == MANAPOTION)
+    {
+        value = urand(me->GetMaxPower(POWER_MANA)/4, me->GetMaxPower(POWER_MANA)/2);
+        me->CastCustomSpell(victim, spellId, &value, 0, 0, true);
+        return true;
+    }
+
+    //remove shapeshifts manually to restore powers/stats
+    if (me->GetShapeshiftForm() != FORM_NONE)
+    {
+        if (info->CheckShapeshift(me->GetShapeshiftForm()) != SPELL_CAST_OK)
+            removeFeralForm(true);
+    }
+
+    if (spellId != HEALINGPOTION && spellId != MANAPOTION)
+        me->SetStandState(UNIT_STAND_STATE_STAND);
+
+    if (!victim->IsWithinLOSInMap(me) && IsInBotParty(victim))
+    {
+        //std::ostringstream msg;
+        //msg << "casting " << spellInfo->SpellName[0] << " on " << victim->GetName();
+        //me->MonsterWhisper(msg.str().c_str(), master->GetGUID());
+        me->Relocate(victim);
+    }
+
+    TriggerCastFlags flags = triggered ? TRIGGERED_FULL_MASK : TRIGGERED_NONE;
+    SpellCastTargets targets;
+    targets.SetUnitTarget(victim);
+    Spell* spell = new Spell(me, info, flags, originalCaster);
+    spell->prepare(&targets); //sets current spell if succeed
+
+    bool casted = triggered; //triggered casts are casted immediately
+    for (uint8 i = 0; i != CURRENT_MAX_SPELL; ++i)
+    {
+        if (me->GetCurrentSpell(i) == spell)
+        {
+            casted = true;
+            break;
+        }
+    }
+
+    if (!casted)
+    {
+        //failed to cast
+        //delete spell; //crash due to invalid event added to master's eventmap
+        return false;
+    }
+
+    currentSpell = spellId;
+
+    switch (me->GetBotClass())
+    {
+        case CLASS_ROGUE:
+        case CAT:
+            value = int32(1000.f - 1000.f*(float(haste) / 100.f));
+            break;
+        default:
+            value = int32(1500.f - 1500.f*(float(haste) / 100.f));
+            break;
+    }
+    GC_Timer = std::max<uint32>(value, 500);
+
+    return true;
+}
+//Follow point calculation
+void bot_minion_ai::CalculatePos(Position & pos)
+{
+    uint8 followdist = master->GetBotFollowDist();
+    Unit* followTarget = master;
+    float mydist, angle;
+    if (master->GetBotTankGuid() == me->GetGUID())
+    {
+        mydist = frand(3.5f, 6.5f); //stand a bit farther
+        angle = (M_PI/2.f) / 16.f * frand(-3.f, 3.f); //in front +-pi/5
+    }
+    else
+    {
+        switch (me->GetBotClass())
+        {
+            case CLASS_WARRIOR: case CLASS_DEATH_KNIGHT: case CLASS_PALADIN: case BEAR:
+                mydist = frand(0.2f, 1.f);
+                angle = (M_PI/2.f) / 8.f * RAND(frand(5.f, 10.f), frand(-10.f, -5.f)); //to the sides +-(pi/3 to pi/1.6)
+                break;
+            case CLASS_WARLOCK: case CLASS_PRIEST: case CLASS_MAGE: case CAT:
+                mydist = frand(0.15f, 0.8f);
+                angle = (M_PI/2.f) / 6.f * frand(10.5f, 13.5f); //behind pi+-pi/4.5
+                break;
+            default:
+                mydist = frand(0.3f, 1.2f);
+                angle = (M_PI/2.f) / 6.f * frand(9.f, 15.f); //behind pi+-pi/3
+                break;
+        }
+    }
+    //myangle = angle used last time
+    //if difference between last angle and cur angle is too big, use new angle
+    //else use last angle (prevent constant struggling)
+    if (abs(abs(myangle) - abs(angle)) > M_PI/3.f)
+        myangle = angle;
+    else
+        angle = myangle;
+    mydist += followdist > 10 ? float(followdist - 10)/4.f : 0.f; //distance from 10+ is reduced
+    mydist = std::min<float>(mydist, 35.f); //do not spread bots too much
+    angle += followTarget->GetOrientation();
+    float x(0),y(0),z(0);
+    float size = me->GetObjectSize()/3.f;
+    bool over = false;
+    for (uint8 i = 0; i != 5 + over; ++i)
+    {
+        if (over)
+        {
+            mydist *= 0.2f;
+            break;
+        }
+        followTarget->GetNearPoint(me, x, y, z, size, mydist, angle);
+        if (!master->IsWithinLOS(x,y,z)) //try to get much closer to master
+        {
+            mydist *= 0.4f - float(i*0.07f);
+            size *= 0.1f;
+            if (size < 0.1)
+                size = 0.f;
+            if (size == 0.f && me->GetPositionZ() < followTarget->GetPositionZ())
+                z += 0.25f; //prevent going underground
+        }
+        else
+            over = true;
+    }
+    pos.m_positionX = x;
+    pos.m_positionY = y;
+    pos.m_positionZ = z;
+
+    //            T   
+    //           TTT
+    //    mmmmmmmm mmmmmmmm 
+    //   mmmmmmm MMM mmmmmmm 
+    //   mmmmm rrrrrrr mmmmm 
+    //    ddd rrrrrrrrr ddd
+    //     ddddddddddddddd
+    //       ddddddddddd
+    //         
+    //MMM - player
+    //TTT - bot tank
+    //m - melee (warrior, paladin, deathknight)
+    //d - default (druid, shaman, rogue, hunter)
+    //r - ranged/support (priest, warlock, mage)
+}
+// Movement set
+void bot_minion_ai::SetBotCommandState(CommandStates st, bool force, Position* newpos)
+{
+    if (me->isDead() || IAmDead())
+        return;
+    if (st == COMMAND_FOLLOW && ((!me->isMoving() && !IsCasting() && master->IsAlive()) || force))
+    {
+        if (CCed(me, true)/* || master->HasUnitState(UNIT_STATE_FLEEING)*/) return;
+        if (me->isMoving() && Rand() > 25) return;
+        if (!newpos)
+            CalculatePos(pos);
+        else
+        {
+            pos.m_positionX = newpos->m_positionX;
+            pos.m_positionY = newpos->m_positionY;
+            pos.m_positionZ = newpos->m_positionZ;
+        }
+        if (me->getStandState() == UNIT_STAND_STATE_SIT && !Feasting())
+            me->SetStandState(UNIT_STAND_STATE_STAND);
+        me->GetMotionMaster()->MovePoint(master->GetMapId(), pos);
+        //me->GetMotionMaster()->MoveFollow(master, mydist, angle);
+    }
+    else if (st == COMMAND_STAY)
+    {
+        me->StopMoving();
+        me->GetMotionMaster()->Clear();
+        me->GetMotionMaster()->MoveIdle();
+    }
+    else if (st == COMMAND_ATTACK)
+    { }
+    m_botCommandState = st;
+    if (Creature* m_botsPet = me->GetBotsPet())
+        m_botsPet->SetBotCommandState(st, force);
+}
+
+void bot_pet_ai::SetBotCommandState(CommandStates st, bool force, Position* /*newpos*/)
+{
+    if (me->isDead() || IAmDead())
+        return;
+    if (st == COMMAND_FOLLOW && ((!me->isMoving() && !IsCasting() && master->IsAlive()) || force))
+    {
+        if (CCed(me, true)) return;
+        if (me->isMoving() && Rand() > 25) return;
+        Unit* followtarget = m_creatureOwner;
+        if (CCed(m_creatureOwner))
+            followtarget = master;
+        if (followtarget == m_creatureOwner)
+        {
+            if (!me->HasUnitState(UNIT_STATE_FOLLOW) || me->GetDistance(master)*0.75f < me->GetDistance(m_creatureOwner))
+                me->GetMotionMaster()->MoveFollow(m_creatureOwner, PET_FOLLOW_DIST, PET_FOLLOW_ANGLE);
+        }
+        else
+            if (!me->HasUnitState(UNIT_STATE_FOLLOW) || me->GetDistance(m_creatureOwner)*0.75f < me->GetDistance(master))
+                me->GetMotionMaster()->MoveFollow(master, PET_FOLLOW_DIST, PET_FOLLOW_ANGLE);
+    }
+    else if (st == COMMAND_STAY)//NUY
+    {
+        me->StopMoving();
+        me->GetMotionMaster()->Clear();
+        me->GetMotionMaster()->MoveIdle();
+    }
+    else if (st == COMMAND_ATTACK)
+    { }
+    m_botCommandState = st;
+}
+// Get Maintank
+void bot_ai::FindTank()
+{
+    if (tank == me)
+        extank = me;
+    //check group flags in DB
+    tank = _GetBotGroupMainTank(master->GetGroup());
+    //check if master has set tank
+    if (!tank)
+        tank = master->GetBotTankGuid() != 0 ? sObjectAccessor->GetObjectInWorld(master->GetBotTankGuid(), (Unit*)NULL) : NULL;
+    //check if we have tank flag in master's motmap
+    if (!tank)
+        tank = master->GetBotTank(me->GetEntry());
+    //at last try to find tank by class if master is too lazy to set it
+    if (!tank)
+    {
+        Player* owner = master;
+        uint8 Class = owner->getClass();
+        if (owner->IsAlive() && 
+            (Class == CLASS_WARRIOR || Class == CLASS_PALADIN || Class == CLASS_DEATH_KNIGHT))
+            tank = owner;
+        else if (owner != master && master->IsAlive())
+        {
+            Class = master->getClass();
+            if (Class == CLASS_WARRIOR || Class == CLASS_PALADIN || Class == CLASS_DEATH_KNIGHT)
+                tank = master;
+        }
+    }
+    //it happens to every bot so they all will know who the tank is
+    if (tank != extank)
+        me->SetBotTank(tank);
+    if (tank == me)
+    {
+        //if tank set by entry let master get right guid and set tank in botmap
+        if (master->GetBotTankGuid() != me->GetGUID())
+            master->SetBotTank(me->GetGUID());
+    }
+}
+//Get Group maintank
+Unit* bot_ai::_GetBotGroupMainTank(Group* group)
+{
+    if (!group)
+        return NULL;
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_MAINTANK);
+    stmt->setUInt32(0, group->GetGUID());
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+    //QueryResult result = CharacterDatabase.PQuery("SELECT memberGuid, memberFlags FROM `group_member` WHERE `guid`='%u'", group->GetGUID());
+    if (!result)
+        return NULL;
+    Unit* unit = NULL;
+    do
+    {
+        Field* field = result->Fetch();
+        uint32 lowGuid = field[0].GetInt32();
+        uint8 flags = field[1].GetInt8();
+        if (flags & MEMBER_FLAG_MAINTANK)
+        {
+            Group::MemberSlotList const &members = group->GetMemberSlots();
+            for (Group::MemberSlotList::const_iterator itr = members.begin(); itr != members.end(); ++itr)
+                if (GUID_LOPART(itr->guid) == lowGuid)
+                    unit = ObjectAccessor::FindUnit(itr->guid);
+        }
+    } while (result->NextRow() && !unit);
+    return unit;
+}
+// Buffs And Heal (really)
+void bot_minion_ai::BuffAndHealGroup(Player* gPlayer, uint32 diff)
+{
+    if (GC_Timer > diff) return;
+    if (me->IsMounted()) return;
+    if (IsCasting() || Feasting()) return;
+
+    Group* pGroup = gPlayer->GetGroup();
+    if (!pGroup)
+    {
+        if (!master->IsInWorld() || master->IsBeingTeleported())
+            return;
+        if (HealTarget(master, GetHealthPCT(master), diff))
+            return;
+        if (BuffTarget(master, diff))
+            return;
+        for (Unit::ControlList::const_iterator itr = master->m_Controlled.begin(); itr != master->m_Controlled.end(); ++itr)
+        {
+            Unit* u = *itr;
+            if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || u->isDead()) continue;
+            if (HealTarget(u, GetHealthPCT(u), diff))
+                return;
+            if (Creature* cre = u->ToCreature())
+                if (cre->GetIAmABot() || cre->IsPet())
+                    if (BuffTarget(u, diff))
+                        return;
+        }
+        return;
+    }
+    bool Bots = false;
+    for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player* tPlayer = itr->GetSource();
+        if (tPlayer == NULL) continue;
+        if (me->GetMap() != tPlayer->FindMap()) continue;
+        if (!tPlayer->m_Controlled.empty())
+            Bots = true;
+        if (tPlayer->isDead()) continue;
+        if (HealTarget(tPlayer, GetHealthPCT(tPlayer), diff))
+            return;
+        if (BuffTarget(tPlayer, diff))
+            return;
+    }
+    if (Bots)
+    {
+        for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            Player* tPlayer = itr->GetSource();
+            if (tPlayer == NULL || tPlayer->m_Controlled.empty()) continue;
+            if (me->GetMap() != tPlayer->FindMap()) continue;
+            for (Unit::ControlList::const_iterator itr = tPlayer->m_Controlled.begin(); itr != tPlayer->m_Controlled.end(); ++itr)
+            {
+                Unit* u = *itr;
+                if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || u->isDead()) continue;
+                if (HealTarget(u, GetHealthPCT(u), diff))
+                    return;
+                if (Creature* cre = u->ToCreature())
+                    if (cre->GetIAmABot() || cre->IsPet())
+                        if (BuffTarget(u, diff))
+                            return;
+            }
+        }
+    }
+    //check if we have pointed heal target
+    for (uint8 i = 0; i != TARGETICONCOUNT; ++i)
+    {
+        if (healTargetIconFlags & GroupIconsFlags[i])
+        {
+            if (uint64 guid = pGroup->GetTargetIcons()[i])//check this one
+            {
+                if (Unit* unit = sObjectAccessor->FindUnit(guid))
+                {
+                    if (unit->IsAlive() && me->GetMap() == unit->FindMap() && 
+                        master->GetVictim() != unit && unit->GetVictim() != master && 
+                        unit->GetReactionTo(master) >= REP_NEUTRAL)
+                    {
+                        HealTarget(unit, GetHealthPCT(unit), diff);
+                        //CureTarget(unit, getCureSpell(), diff);
+                    }
+                }
+            }
+        }
+    }
+}
+// Attempt to resurrect dead players using class spells
+// Target is either player or its corpse
+void bot_minion_ai::RezGroup(uint32 REZZ, Player* gPlayer)
+{
+    if (!REZZ || !gPlayer || me->IsMounted()) return;
+    if (IsCasting()) return;
+    if (rezz_cd > 0) return;
+
+    //sLog->outBasic("RezGroup by %s", me->GetName().c_str());
+    Group* pGroup = gPlayer->GetGroup();
+    if (!pGroup)
+    {
+        Unit* target = master;
+        if (master->IsAlive()) return;
+        if (master->IsRessurectRequested()) return; //resurrected
+        if (master->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+            target = (Unit*)master->GetCorpse();
+        if (!target || !target->IsInWorld()) return;
+        if (me->GetMap() != target->FindMap()) return;
+        if (me->GetDistance(target) > 30)
+        {
+            me->GetMotionMaster()->MovePoint(master->GetMapId(), *target);
+            rezz_cd = 3;//6-9 sec reset
+            return;
+        }
+        else if (!target->IsWithinLOSInMap(me))
+            me->Relocate(*target);
+
+        if (doCast(target, REZZ))//rezzing it
+        {
+            me->MonsterWhisper("Rezzing You", master->GetGUID());
+            rezz_cd = 60;
+        }
+        return;
+    }
+    for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player* tPlayer = itr->GetSource();
+        Unit* target = tPlayer;
+        if (!tPlayer || tPlayer->IsAlive()) continue;
+        if (tPlayer->IsRessurectRequested()) continue; //resurrected
+        if (Rand() > 5) continue;
+        if (tPlayer->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+            target = (Unit*)tPlayer->GetCorpse();
+        if (!target || !target->IsInWorld()) continue;
+        if (master->GetMap() != target->FindMap()) continue;
+        if (me->GetDistance(target) > 30)
+        {
+            me->GetMotionMaster()->MovePoint(master->GetMapId(), *target);
+            rezz_cd = 3;//6-9 sec reset
+            return;
+        }
+        else if (!target->IsWithinLOSInMap(me))
+            me->Relocate(*target);
+
+        if (doCast(target, REZZ))//rezzing it
+        {
+            me->MonsterWhisper("Rezzing You", tPlayer->GetGUID());
+            if (tPlayer != master)
+            {
+                std::string rezstr = "Rezzing ";
+                rezstr += tPlayer->GetName();
+                me->MonsterWhisper(rezstr.c_str(), master->GetGUID());
+            }
+            rezz_cd = 60;
+            return;
+        }
+    }
+}
+// CURES
+//cycle through the group sending members for cure
+void bot_minion_ai::CureGroup(Player* pTarget, uint32 cureSpell, uint32 diff)
+{
+    if (!cureSpell || GC_Timer > diff) return;
+    if (me->getLevel() < 10 || pTarget->getLevel() < 10) return;
+    if (me->IsMounted()) return;
+    if (IsCasting() || Feasting()) return;
+    if (!master->GetMap()->IsRaid() && Rand() > 75) return;
+    //sLog->outBasic("%s: CureGroup() on %s", me->GetName().c_str(), pTarget->GetName().c_str());
+    Group* pGroup = pTarget->GetGroup();
+    if (!pGroup)
+    {
+        if (CureTarget(master, cureSpell, diff))
+            return;
+        for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
+        {
+            Creature* cre = master->GetBotMap(i)->_Cre();
+            if (!cre || !cre->IsInWorld() || me->GetDistance(cre) > 30) continue;
+            if (CureTarget(cre, cureSpell, diff))
+                return;
+        }
+    }
+    else
+    {
+        bool Bots = false;
+        for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            Player* tPlayer = itr->GetSource();
+            if (!tPlayer || (tPlayer->isDead() && !tPlayer->HaveBot())) continue;
+            if (!Bots && tPlayer->HaveBot())
+                Bots = true;
+            if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+            if (me->GetMap() != tPlayer->FindMap()) continue;
+            if (me->GetDistance(tPlayer) > 30) continue;
+            if (CureTarget(tPlayer, cureSpell, diff))
+                return;
+        }
+        if (!Bots) return;
+        for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            Player* tPlayer = itr->GetSource();
+            if (tPlayer == NULL || !tPlayer->HaveBot()) continue;
+            if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+            if (me->GetMap() != tPlayer->FindMap()) continue;
+            for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+            {
+                Creature* cre = tPlayer->GetBotMap(i)->_Cre();
+                if (!cre || !cre->IsInWorld() || me->GetDistance(cre) > 30) continue;
+                if (CureTarget(cre, cureSpell, diff))
+                    return;
+            }
+        }
+    }
+}
+
+bool bot_minion_ai::CureTarget(Unit* target, uint32 cureSpell, uint32 diff)
+{
+    return CanCureTarget(target, cureSpell, diff) ? doCast(target, cureSpell) : false;
+}
+// determines if unit has something to cure
+bool bot_minion_ai::CanCureTarget(Unit* target, uint32 cureSpell, uint32 diff) const
+{
+    if (!cureSpell || GC_Timer > diff) return false;
+    if (!target || target->isDead()) return false;
+    if (me->getLevel() < 10 || target->getLevel() < 10) return false;
+    if (me->IsMounted()) return false;
+    if (IsCasting() || Feasting()) return false;
+    if (me->GetDistance(target) > 30) return false;
+    if (!IsInBotParty(target)) return false;
+
+    SpellInfo const* info = sSpellMgr->GetSpellInfo(cureSpell);
+    if (!info)
+        return false;
+
+    uint32 dispelMask = 0;
+    for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+        if (info->Effects[i].Effect == SPELL_EFFECT_DISPEL)
+            dispelMask |= SpellInfo::GetDispelMask(DispelType(info->Effects[i].MiscValue));
+
+    //debug - fix Remove Corruption: prevent from trying to dispel magic
+    if (cureSpell == 2782)
+        dispelMask &= ~(1 << DISPEL_MAGIC);
+
+    if (dispelMask == 0)
+        return false;
+
+    DispelChargesList dispel_list;
+    GetBotDispellableAuraList(target, me, dispelMask, dispel_list);
+
+    return !(dispel_list.empty());
+}
+
+void bot_minion_ai::GetBotDispellableAuraList(Unit* target, Unit* caster, uint32 dispelMask, DispelChargesList& dispelList) const
+{
+    if (dispelMask & (1 << DISPEL_DISEASE) && target->HasAura(50536))
+        dispelMask &= ~(1 << DISPEL_DISEASE);
+
+    Unit::AuraMap const& auras = target->GetOwnedAuras();
+    for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+    {
+        Aura* aura = itr->second;
+
+        if (aura->IsPassive())
+            continue;
+
+        AuraApplication* aurApp = aura->GetApplicationOfTarget(target->GetGUID());
+        if (!aurApp)
+            continue;
+
+        if (aura->GetSpellInfo()->GetDispelMask() & dispelMask)
+        {
+            if (aurApp->IsPositive() == target->IsFriendlyTo(caster))
+                continue;
+
+            uint8 charges = (aura->GetSpellInfo()->AttributesEx7 & SPELL_ATTR7_DISPEL_CHARGES) ? aura->GetCharges() : aura->GetStackAmount();
+            if (charges > 0)
+                dispelList.push_back(std::make_pair(aura, charges));
+        }
+    }
+}
+
+bool bot_ai::HasAuraName(Unit* unit, uint32 spellId, uint64 casterGuid, bool exclude) const
+{
+    if (!spellId) return false;
+    SpellInfo const* pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!pSpellInfo) return false;
+
+    const std::string name = pSpellInfo->SpellName;
+    if (name.length() == 0) return false;
+
+    return HasAuraName(unit, name, casterGuid, exclude);
+}
+
+bool bot_ai::HasAuraName(Unit* unit, const std::string spell, uint64 casterGuid, bool exclude) const
+{
+    if (spell.length() == 0) return false;
+
+    if (!unit || unit->isDead()) return false;
+
+    Unit::AuraMap const& vAuras = unit->GetOwnedAuras();
+    for (Unit::AuraMap::const_iterator itr = vAuras.begin(); itr != vAuras.end(); ++itr)
+    {
+        SpellInfo const* spellInfo = itr->second->GetSpellInfo();
+        const std::string name = spellInfo->SpellName;
+        if (spell == name)
+            if (casterGuid == 0 || (casterGuid != 0 && exclude == (casterGuid != itr->second->GetCasterGUID())))
+                return true;
+    }
+    return false;
+}
+//LIST AURAS
+// Debug: Returns bot's info to called player
+void bot_ai::listAuras(Player* player, Unit* unit) const
+{
+    if (!IsInBotParty(player)) return;
+    if (!IsInBotParty(unit)) return;
+    ChatHandler ch(player->GetSession());
+    std::ostringstream botstring;
+    if (unit->GetTypeId() == TYPEID_PLAYER)
+        botstring << "player";
+    else if (unit->GetTypeId() == TYPEID_UNIT)
+    {
+        if (unit->ToCreature()->GetIAmABot())
+        {
+            botstring << "minion bot, master: ";
+            std::string const& ownername = unit->ToCreature()->GetBotOwner()->GetName();
+            botstring << ownername;
+        }
+        else if (unit->ToCreature()->GetIAmABotsPet())
+        {
+            Player* owner = unit->ToCreature()->GetBotOwner();
+            Creature* creowner = unit->ToCreature()->GetBotPetAI()->GetCreatureOwner();
+            std::string const& ownername = owner ? owner->GetName() : "none";
+            std::string const& creownername = creowner ? creowner->GetName() : "none";
+            botstring << "pet bot, master: ";
+            botstring << ownername;
+            botstring << ", creature owner: ";
+            botstring << creownername;
+            if (creowner)
+                botstring << " (" << creowner->GetGUIDLow() << ')';
+        }
+    }
+    ch.PSendSysMessage("ListAuras for %s, %s", unit->GetName().c_str(), botstring.str().c_str());
+    uint8 locale = player->GetSession()->GetSessionDbcLocale();
+    Unit::AuraMap const &vAuras = unit->GetOwnedAuras();
+    for (Unit::AuraMap::const_iterator itr = vAuras.begin(); itr != vAuras.end(); ++itr)
+    {
+        SpellInfo const* spellInfo = itr->second->GetSpellInfo();
+        if (!spellInfo)
+            continue;
+        uint32 id = spellInfo->Id;
+        SpellInfo const* learnSpellInfo = sSpellMgr->GetSpellInfo(spellInfo->Effects[0].TriggerSpell);
+        const std::string name = spellInfo->SpellName;
+        std::ostringstream spellmsg;
+        spellmsg << id << " - |cffffffff|Hspell:" << id << "|h[" << name;
+        spellmsg << ' ' << localeNames[locale] << "]|h|r";
+        uint32 talentcost = GetTalentSpellCost(id);
+        uint32 rank = 0;
+        if (talentcost > 0 && spellInfo->GetNextRankSpell())
+            rank = talentcost;
+        else if (learnSpellInfo && learnSpellInfo->GetNextRankSpell())
+            rank = spellInfo->GetRank();
+        if (rank > 0)
+            spellmsg << " Rank " << rank;
+        if (talentcost > 0)
+            spellmsg << " [talent]";
+        if (spellInfo->IsPassive())
+            spellmsg << " [passive]";
+        if (unit->GetTypeId() == TYPEID_PLAYER && unit->ToPlayer()->HasSpell(id))
+            spellmsg << " [known]";
+
+        ch.PSendSysMessage(spellmsg.str().c_str());
+    }
+    for (uint8 i = STAT_STRENGTH; i != MAX_STATS; ++i)
+    {
+        std::string mystat;
+        switch (i)
+        {
+            case STAT_STRENGTH: mystat = "str"; break;
+            case STAT_AGILITY: mystat = "agi"; break;
+            case STAT_STAMINA: mystat = "sta"; break;
+            case STAT_INTELLECT: mystat = "int"; break;
+            case STAT_SPIRIT: mystat = "spi"; break;
+            default: mystat = "unk stat"; break;
+        }
+        ch.PSendSysMessage("%s: %f", mystat.c_str(), unit->GetTotalStatValue(Stats(i)));
+    }
+    ch.PSendSysMessage("Melee AP: %f", unit->GetTotalAttackPowerValue(BASE_ATTACK));
+    ch.PSendSysMessage("Ranged AP: %f", unit->GetTotalAttackPowerValue(RANGED_ATTACK));
+    ch.PSendSysMessage("armor: %u", unit->GetArmor());
+    ch.PSendSysMessage("crit: %f pct", unit->GetUnitCriticalChance(BASE_ATTACK, me));
+    ch.PSendSysMessage("dodge: %f pct", unit->GetUnitDodgeChance());
+    ch.PSendSysMessage("parry: %f pct", unit->GetUnitParryChance());
+    ch.PSendSysMessage("Damage taken melee: %f", unit->GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELL_SCHOOL_MASK_NORMAL));
+    ch.PSendSysMessage("Damage taken spell: %f", unit->GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELL_SCHOOL_MASK_MAGIC));
+    ch.PSendSysMessage("Damage range mainhand: min: %f, max: %f", unit->GetFloatValue(UNIT_FIELD_MINDAMAGE), unit->GetFloatValue(UNIT_FIELD_MAXDAMAGE));
+    ch.PSendSysMessage("Damage range offhand: min: %f, max: %f", unit->GetFloatValue(UNIT_FIELD_MINOFFHANDDAMAGE), unit->GetFloatValue(UNIT_FIELD_MAXOFFHANDDAMAGE));
+    ch.PSendSysMessage("Damage range ranged: min: %f, max: %f", unit->GetFloatValue(UNIT_FIELD_MINRANGEDDAMAGE), unit->GetFloatValue(UNIT_FIELD_MAXRANGEDDAMAGE));
+    ch.PSendSysMessage("Damage mult mainhand: %f", unit->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, BASE_PCT)*unit->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_PCT));
+    ch.PSendSysMessage("Damage mult offhand: %f", unit->GetModifierValue(UNIT_MOD_DAMAGE_OFFHAND, BASE_PCT)*unit->GetModifierValue(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_PCT));
+    ch.PSendSysMessage("Damage mult ranged: %f", unit->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, BASE_PCT)*unit->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, TOTAL_PCT));
+    ch.PSendSysMessage("Attack time mainhand: %f", float(unit->GetAttackTime(BASE_ATTACK))/1000.f);
+    ch.PSendSysMessage("Attack time offhand: %f", float(unit->GetAttackTime(OFF_ATTACK))/1000.f);
+    ch.PSendSysMessage("Attack time ranged: %f", float(unit->GetAttackTime(RANGED_ATTACK))/1000.f);
+    if (unit == me)
+        ch.PSendSysMessage("melee damage mult: %f", dmgmult_melee);
+    ch.PSendSysMessage("base hp: %u", unit->GetCreateHealth());
+    ch.PSendSysMessage("total hp: %u", unit->GetMaxHealth());
+    ch.PSendSysMessage("base mana: %u", unit->GetCreateMana());
+    ch.PSendSysMessage("total mana: %u", unit->GetMaxPower(POWER_MANA));
+    //DEBUG1
+    //ch.PSendSysMessage("STATS: ");
+    //ch.PSendSysMessage("Health");
+    //ch.PSendSysMessage("base value: %f", unit->GetModifierValue(UNIT_MOD_HEALTH, BASE_VALUE));
+    //ch.PSendSysMessage("base pct: %f", unit->GetModifierValue(UNIT_MOD_HEALTH, BASE_PCT));
+    //ch.PSendSysMessage("total value: %f", unit->GetModifierValue(UNIT_MOD_HEALTH, TOTAL_VALUE));
+    //ch.PSendSysMessage("total pct: %f", unit->GetModifierValue(UNIT_MOD_HEALTH, TOTAL_PCT));
+    //ch.PSendSysMessage("Mana");
+    //ch.PSendSysMessage("base value: %f", unit->GetModifierValue(UNIT_MOD_MANA, BASE_VALUE));
+    //ch.PSendSysMessage("base pct: %f", unit->GetModifierValue(UNIT_MOD_MANA, BASE_PCT));
+    //ch.PSendSysMessage("total value: %f", unit->GetModifierValue(UNIT_MOD_MANA, TOTAL_VALUE));
+    //ch.PSendSysMessage("total pct: %f", unit->GetModifierValue(UNIT_MOD_MANA, TOTAL_PCT));
+    //ch.PSendSysMessage("Stamina");
+    //ch.PSendSysMessage("base value: %f", unit->GetModifierValue(UNIT_MOD_STAT_STAMINA, BASE_VALUE));
+    //ch.PSendSysMessage("base pct: %f", unit->GetModifierValue(UNIT_MOD_STAT_STAMINA, BASE_PCT));
+    //ch.PSendSysMessage("total value: %f", unit->GetModifierValue(UNIT_MOD_STAT_STAMINA, TOTAL_VALUE));
+    //ch.PSendSysMessage("total pct: %f", unit->GetModifierValue(UNIT_MOD_STAT_STAMINA, TOTAL_PCT));
+    //ch.PSendSysMessage("Intellect");
+    //ch.PSendSysMessage("base value: %f", unit->GetModifierValue(UNIT_MOD_STAT_INTELLECT, BASE_VALUE));
+    //ch.PSendSysMessage("base pct: %f", unit->GetModifierValue(UNIT_MOD_STAT_INTELLECT, BASE_PCT));
+    //ch.PSendSysMessage("total value: %f", unit->GetModifierValue(UNIT_MOD_STAT_INTELLECT, TOTAL_VALUE));
+    //ch.PSendSysMessage("total pct: %f", unit->GetModifierValue(UNIT_MOD_STAT_INTELLECT, TOTAL_PCT));
+    //ch.PSendSysMessage("Spirit");
+    //ch.PSendSysMessage("base value: %f", unit->GetModifierValue(UNIT_MOD_STAT_SPIRIT, BASE_VALUE));
+    //ch.PSendSysMessage("base pct: %f", unit->GetModifierValue(UNIT_MOD_STAT_SPIRIT, BASE_PCT));
+    //ch.PSendSysMessage("total value: %f", unit->GetModifierValue(UNIT_MOD_STAT_SPIRIT, TOTAL_VALUE));
+    //ch.PSendSysMessage("total pct: %f", unit->GetModifierValue(UNIT_MOD_STAT_SPIRIT, TOTAL_PCT));
+    //END DEBUG1
+    if (unit == me)
+    {
+        ch.PSendSysMessage("spellpower: %u", m_spellpower - m_spellpower % 50);
+        ch.PSendSysMessage("spell damage mult: %f", dmgmult_spell);
+        ch.PSendSysMessage("mana regen: %f", regen_mp5 - (int32(regen_mp5) % 45));
+        ch.PSendSysMessage("haste: %u *10 pct", haste);
+        for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
+        {
+            const char* resist = NULL;
+            switch (i)
+            {
+                case 1: resist = "holy";   break;
+                case 2: resist = "fire";   break;
+                case 3: resist = "nature"; break;
+                case 4: resist = "frost";  break;
+                case 5: resist = "shadow"; break;
+                case 6: resist = "arcane"; break;
+            }
+            ch.PSendSysMessage("Resistance %s: %u", resist, me->GetResistance(SpellSchools(i)));
+        }
+        ch.PSendSysMessage("BotCommandState: %s", m_botCommandState == COMMAND_FOLLOW ? "Follow" : m_botCommandState == COMMAND_ATTACK ? "Attack" : m_botCommandState == COMMAND_STAY ? "Stay" : m_botCommandState == COMMAND_ABANDON ? "Reset" : "none");
+        ch.PSendSysMessage("Follow distance: %u", master->GetBotFollowDist());
+        //ch.PSendSysMessage("healTargetIconFlags: %u", healTargetIconFlags);
+        if (tank != NULL && tank->IsInWorld())
+        {
+            if (tank == me)
+                ch.PSendSysMessage("Is a MainTank!");
+            else
+                ch.PSendSysMessage("Maintank is %s", tank->GetName().c_str());
+        }
+        //debug
+        //if (IsPetAI()) GetPetAI()->ListSpells(&ch);
+    }
+}
+//SETSTATS
+// Health, Armor, Powers, Combat Ratings, and global update setup
+void bot_minion_ai::setStats(uint8 myclass, uint8 myrace, uint8 mylevel, bool force, bool shapeshift)
+{
+    if (myrace == 0 || myclass == 0) return;
+    if (myclass != BEAR && myclass != CAT && (master->isDead() || (!shouldUpdateStats && !force))) return;
+    /*sLog->outBasic("setStats(): Updating bot %s, class: %u, race: %u, level %u, master: %s",
+        me->GetName().c_str(), myclass, myrace, mylevel, master->GetName().c_str());*/
+
+    mylevel = std::min<uint8>(mylevel, 85);
+
+    //LEVEL
+    if (me->getLevel() != mylevel)
+    {
+        me->SetLevel(mylevel);
+        force = true; //restore powers on lvl update
+    }
+    if (force)
+    {
+        InitSpells();
+        //ApplyPassives(me->GetBotClass());
+
+        //need to find a way to remove all passives before reapply (except levelups)
+        //!!!this is only for gm's (players are not supposed to lower their level)
+        ApplyClassPassives();
+    }
+
+    //PHASE
+    if (!me->InSamePhase(master))
+        me->SetPhaseMask(master->GetPhaseMask(), true);
+    //INIT STATS
+    //partially receive master's stats and get base class stats, we'll need all this later
+    uint8 tempclass = myclass == BEAR || myclass == CAT ? CLASS_DRUID : myclass;
+    sObjectMgr->GetPlayerClassLevelInfo(tempclass, mylevel, classinfo.basehealth, classinfo.basemana);
+    const CreatureBaseStats* const classstats = sObjectMgr->GetCreatureBaseStats(mylevel, me->getClass());//use creature class
+    float value;
+    if (force)
+        for (uint8 i = STAT_STAMINA; i < MAX_STATS; i++)
+            me->SetCreateStat(Stats(i), master->GetCreateStat(Stats(i)));
+
+    //MAXSTAT
+    for (uint8 i = 0; i < MAX_STATS; ++i)
+    {
+        value = master->GetTotalStatValue(Stats(i));
+        if (i == 0 || value > stat)
+            stat = value;//Get Hightest stat (on first cycle just set base value)
+    }
+    stat = std::max(stat - 18.f, 0.f); //base value for all stats is 18 (isn't counted in any way)
+
+    //INIT CLASS MODIFIERS
+    switch (myclass)
+    {
+        case CLASS_WARRIOR:      ap_mod = 1.3f;  spp_mod = 0.0f; armor_mod = 1.4f;  crit_mod = 1.0f; haste_mod = 0.75f; dodge_mod = 0.75f; parry_mod = 1.75f; break;
+        case CLASS_DEATH_KNIGHT: ap_mod = 1.2f;  spp_mod = 1.0f; armor_mod = 1.15f; crit_mod = 0.9f; haste_mod = 0.65f; dodge_mod = 0.8f;  parry_mod = 2.0f;  break;//NYI
+        case CLASS_PALADIN:      ap_mod = 1.0f;  spp_mod = 0.8f; armor_mod = 1.2f;  crit_mod = 0.8f; haste_mod = 0.85f; dodge_mod = 0.7f;  parry_mod = 1.5f;  break;
+        case CLASS_ROGUE:        ap_mod = 1.5f;  spp_mod = 0.0f; armor_mod = 0.7f;  crit_mod = 1.5f; haste_mod = 1.35f; dodge_mod = 1.5f;  parry_mod = 0.8f;  break;//NYI
+        case CLASS_HUNTER:       ap_mod = 1.15f; spp_mod = 0.0f; armor_mod = 0.85f; crit_mod = 1.2f; haste_mod = 1.25f; dodge_mod = 1.2f;  parry_mod = 1.2f;  break;//NYI
+        case CLASS_SHAMAN:       ap_mod = 0.9f;  spp_mod = 1.0f; armor_mod = 0.9f;  crit_mod = 1.2f; haste_mod = 1.65f; dodge_mod = 0.8f;  parry_mod = 0.5f;  break;//NYI
+        case CLASS_DRUID:        ap_mod = 0.0f;  spp_mod = 1.3f; armor_mod = 0.7f;  crit_mod = 0.7f; haste_mod = 1.95f; dodge_mod = 0.5f;  parry_mod = 0.0f;  break;
+        case CLASS_MAGE:         ap_mod = 0.0f;  spp_mod = 0.8f; armor_mod = 0.5f;  crit_mod = 0.7f; haste_mod = 1.75f; dodge_mod = 0.5f;  parry_mod = 0.0f;  break;          
+        case CLASS_PRIEST:       ap_mod = 0.0f;  spp_mod = 1.2f; armor_mod = 0.5f;  crit_mod = 0.7f; haste_mod = 1.75f; dodge_mod = 0.5f;  parry_mod = 0.0f;  break;
+        case CLASS_WARLOCK:      ap_mod = 0.0f;  spp_mod = 1.0f; armor_mod = 0.5f;  crit_mod = 0.7f; haste_mod = 1.75f; dodge_mod = 0.5f;  parry_mod = 0.0f;  break;
+        case BEAR:               ap_mod = 2.0f;  spp_mod = 1.3f; armor_mod = 2.25f; crit_mod = 1.0f; haste_mod = 0.75f; dodge_mod = 2.5f;  parry_mod = 0.0f;  break;
+        case CAT:                ap_mod = 1.5f;  spp_mod = 1.3f; armor_mod = 1.1f;  crit_mod = 1.5f; haste_mod = 2.25f; dodge_mod = 1.35f; parry_mod = 0.0f;  break;
+        default:                 ap_mod = 0.0f;  spp_mod = 0.0f; armor_mod = 0.0f;  crit_mod = 0.0f; haste_mod = 0.00f; dodge_mod = 0.0f;  parry_mod = 0.0f;  break;
+    }
+    if (spp_mod != 0.f && mylevel > 39)
+        spp_mod *= (float(mylevel - 39))/41.f;// gain spell power slowly
+
+    //DAMAGE
+    _OnMeleeDamageUpdate(myclass);
+    
+    //ARMOR
+    //sLog->outBasic("Unpdating %s's ARMOR: ", me->GetName().c_str());
+    //sLog->outBasic("armor mod: %f", armor_mod);
+    armor_mod *= (master->GetModifierValue(UNIT_MOD_ARMOR, BASE_PCT) + master->GetModifierValue(UNIT_MOD_ARMOR, TOTAL_PCT))/2.f;
+    //sLog->outBasic("armor mod * master's modifier: %f", armor_mod);
+    value = float(classstats->BaseArmor);
+    //sLog->outBasic("base armor: %f", value);
+    value += float(master->GetArmor())/5.f;
+    //sLog->outBasic("base armor + 1/5 of master's armor: %f", value);
+    value *= armor_mod;
+    //sLog->outBasic("multiplied by armor mod (total base armor): %f", value);
+    me->SetModifierValue(UNIT_MOD_ARMOR, BASE_VALUE, value);
+    me->UpdateArmor();//buffs will be took in consideration here
+
+    //RESISTANCES
+    //sLog->outBasic("Unpdating %s's RESISTANCES: ", me->GetName().c_str());
+    for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
+    {
+        value = float(master->GetResistance(SpellSchools(i)));
+        //sLog->outBasic("master's resistance %u: %f, setting %f (triple) to bot", uint32(UNIT_MOD_RESISTANCE_START + i), value, value*3);
+        me->SetModifierValue(UnitMods(UNIT_MOD_RESISTANCE_START + i), BASE_VALUE, value*2.5f + float(mylevel*2));
+        //me->SetModifierValue(UnitMods(UNIT_MOD_RESISTANCE_START + i), BASE_PCT, 1.f);
+        me->UpdateResistances(i);
+    }
+    //DAMAGE TAKEN
+    float directReduction = master->GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELL_SCHOOL_MASK_NORMAL);
+    float magicReduction = master->GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELL_SCHOOL_MASK_MAGIC);
+    value = (directReduction + magicReduction)/2.f;// average
+    if (value > 1.f)
+        value -= 1.f;
+    else
+        value = 1.f - value;//get reduction even if master's is 1.0+
+    value = std::min(0.42f, value);
+    value/= 0.01f; //here we get percent like 0.42/0.01 = 42% (value * 100.f)
+    if (mylevel > 77)
+        value += float(mylevel - 77)*6.f;// + 3 stacks for high level
+    RefreshAura(DMG_TAKEN, int8(value/6.f));//so max aura count = 10
+
+    //HEALTH
+    _OnHealthUpdate(myclass, mylevel);
+
+    //HASTE
+    value = 0.f;
+    for (uint8 i = CR_HASTE_MELEE; i != CR_HASTE_SPELL + 1; ++i)
+        if (float rating = master->GetRatingBonusValue(CombatRating(i)))
+            if (rating > value)//master got some haste
+                value = rating;//get hightest pct
+    for (uint8 i = EQUIPMENT_SLOT_BACK; i < EQUIPMENT_SLOT_END; ++i)
+        if (Item* item = master->GetItemByPos(0, i))//inventory weapons
+            if (item->GetTemplate()->ItemLevel >= 277)//bears ICC 25H LK items or Wrathful items
+                value += 9.f;//only weapons so we can add 1 to 3 stacks (rogue, warr, sham...)
+    value *= haste_mod;
+    if (isMeleeClass(myclass))
+        value *= 0.67f;//nerf melee haste by 1/3
+    value = value/3.f + float(mylevel/42);//get bonus at 84
+    if (myclass == CAT)//give cat lots of haste
+        value += float(mylevel/17);//or 20 (+ 4-5 stacks);
+    RefreshAura(HASTE,  uint8(value));//spell haste
+    RefreshAura(HASTE2, uint8(value) + uint8(myclass == CLASS_ROGUE));//melee haste
+    haste = uint8(value);//for show only
+
+    //HIT
+    int32 melee_hit = master->GetTotalAuraModifier(SPELL_AURA_MOD_HIT_CHANCE) + master->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_MELEE_HIT_CHANCE);
+    int32 spell_hit = master->GetTotalAuraModifier(SPELL_AURA_MOD_HIT_CHANCE) + master->GetTotalAuraModifier(SPELL_AURA_MOD_SPELL_HIT_CHANCE);
+    value = float(melee_hit > spell_hit ? melee_hit : spell_hit)*1.5f;//hightest, buff hit chance for bots
+    hit = value/3.f;
+    //RefreshAura(PRECISION,  int8(hit) + mylevel/42);//melee
+    RefreshAura(PRECISION);
+    RefreshAura(PRECISION2, int8(hit) + mylevel/42);//spell
+
+    //CRIT
+    //chose melee or ranged cuz crit rating increases melee/spell, and hunter benefits from agility
+    value = master->GetUnitCriticalChance((master->getClass() == CLASS_HUNTER ? RANGED_ATTACK : BASE_ATTACK), me);
+    value = value > 5.f ? value - 5.f : 0.f;//remove base chance if can
+    value *= crit_mod;
+    RefreshAura(CRITS, int8(value/3.f) + mylevel/42);
+    if (myclass == CLASS_PRIEST)
+        RefreshAura(HOLYCRIT, int8(value/6.f));//add holy crit to healers
+
+    //PARRY
+    value = master->GetFloatValue(PLAYER_PARRY_PERCENTAGE);
+    value = value > 5.f ? value - 5.f : 0.f;//remove base chance if possible
+    value *= parry_mod;
+    if (master->GetBotTankGuid() == me->GetGUID() && myclass != CAT && myclass != BEAR)//feral cannot parry so let it be base 5%
+        value += 10.f;
+    if (value > 55.f)
+        value = 55.f;
+    float parryAndDodge = value;//set temp value, this is needed to keep total avoidance within 65%
+    RefreshAura(PARRY, int8(value/6.f));//6% per stack aplied
+
+    //DODGE
+    value = master->GetUnitDodgeChance();
+    value = value > 5.f ? value - 5.f : 0.f;//remove base chance if possible
+    value *= dodge_mod;
+    if (master->GetBotTankGuid() == me->GetGUID())
+        value += 10.f;
+    if (value > 55.f)
+        value = 55.f;
+    if (parryAndDodge + value > 55.f)
+        value = 55.f - parryAndDodge;//do not allow avoidance to be more than 65% (base 5+5)
+    if (myclass == CLASS_ROGUE)
+        value += 6.f;
+    RefreshAura(DODGE, int8(value/5.f));
+
+    //MANA
+    _OnManaUpdate(myclass, mylevel, shapeshift);
+
+    //MANA REGEN
+    if (mylevel >= 40 && me->getPowerType() == POWER_MANA)
+    {
+        regen_mp5 = master->GetFloatValue(UNIT_FIELD_POWER_REGEN_FLAT_MODIFIER);
+        //TOO COMPLICATED
+        //regen_mp5 = (master->GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_POWER_REGEN, POWER_MANA) + sqrt(master->GetStat(STAT_INTELLECT)) * master->OCTRegenMPPerSpirit()) / 5.f;
+        //Unit::AuraEffectList const& regenAura = master->GetAuraEffectsByType(SPELL_AURA_MOD_MANA_REGEN_FROM_STAT);
+        //for (Unit::AuraEffectList::const_iterator i = regenAura.begin(); i != regenAura.end(); ++i)
+        //    regen_mp5 += master->GetStat(Stats((*i)->GetMiscValue())) * (*i)->GetAmount() / 500.f;
+        //regen_mp5 *= 0.8f;//custom modifier
+        float regen_mp5_a = stat * 0.2f;
+        //regen_mp5 += master->GetTotalStatValue(STAT_SPIRIT) * 0.1f;
+        regen_mp5 = regen_mp5 > regen_mp5_a ? regen_mp5 : regen_mp5_a;
+        if (regen_mp5 >= 45.f)
+        {
+            me->RemoveAurasDueToSpell(MANAREGEN100);
+            me->RemoveAurasDueToSpell(MANAREGEN45);
+            if      (regen_mp5 > 200.f)   RefreshAura(MANAREGEN100,int8(regen_mp5/100.f) + mylevel/20);
+            else/*if (regen_mp5 > 150.f)*/RefreshAura(MANAREGEN45, int8(regen_mp5/45.f)  + mylevel/20);
+        }
+    }
+
+    //SPELL POWER
+    if (mylevel >= 40 && spp_mod != 0.f)
+    {
+        //sLog->outBasic("Updating spellpower for %s:", me->GetName().c_str());
+        //sLog->outBasic("spp_mod: %f", spp_mod);
+        for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
+        {
+            int32 power = master->SpellBaseDamageBonusDone(SpellSchoolMask(1 << i));
+            if (power > sppower || i == SPELL_SCHOOL_HOLY)
+                sppower = power;
+        }
+        //sppower = master->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC);//"Spell Power" stat
+        //sLog->outBasic("Master's spell power: %i", sppower);
+        atpower = master->GetTotalAttackPowerValue(master->getClass() == CLASS_HUNTER ? RANGED_ATTACK : BASE_ATTACK);
+        atpower *= 0.67f;
+        //sLog->outBasic("Master's 2/3 of attack power: %f", atpower);
+        m_spellpower = sppower > atpower ? sppower : atpower;
+        //sLog->outBasic("Chosen stat value: %i", m_spellpower);
+        m_spellpower = int32(float(m_spellpower)*spp_mod);
+        //sLog->outBasic("spellpower * mod: %i", m_spellpower);
+        if (myclass == CLASS_MAGE)
+            RefreshAura(FIREDAM_86, m_spellpower/4/86 + (mylevel >= 78)*2); //(86,172,258,344,430,516,602,688...) // fire spp, do not touch this
+        me->RemoveAurasDueToSpell(SPELL_BONUS_250);
+        me->RemoveAurasDueToSpell(SPELL_BONUS_150);
+        me->RemoveAurasDueToSpell(SPELL_BONUS_50);
+        if      (mylevel < 60) RefreshAura(SPELL_BONUS_50,  m_spellpower/50);
+        else if (mylevel < 85) RefreshAura(SPELL_BONUS_150, m_spellpower/150 + 1);
+        else                   RefreshAura(SPELL_BONUS_250, m_spellpower/250 + 2);
+    }
+
+    if (force)
+    {
+        me->SetFullHealth();
+        me->SetPower(POWER_MANA, me->GetMaxPower(POWER_MANA));
+    }
+
+    //SetStats for pet
+    if (Creature* pet = me->GetBotsPet())
+        if (bot_pet_ai* petai = pet->GetBotPetAI())
+            petai->setStats(mylevel, bot_pet_ai::GetPetType(pet), force);
+
+    shouldUpdateStats = false;
+}
+void bot_pet_ai::setStats(uint8 mylevel, uint8 petType, bool force)
+{
+    if (petType == PET_TYPE_NONE || petType >= MAX_PET_TYPES) return;
+    if (!shouldUpdateStats && !force) return;
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "setStats(): Updating pet bot %s, type: %u, level %u, owner: %s, master: %s", me->GetName().c_str(), petType, mylevel, m_creatureOwner->GetName().c_str(), master->GetName().c_str());
+
+    //LEVEL
+    if (me->getLevel() != mylevel)
+    {
+        me->SetLevel(mylevel);
+        force = true; //restore powers on lvl update
+    }
+    if (force)
+        InitSpells();
+
+    //PHASE
+    if (!me->InSamePhase(master))
+        me->SetPhaseMask(master->GetPhaseMask(), true);
+
+    ////INIT STATS
+    uint8 botclass = m_creatureOwner->GetBotClass();
+    if (botclass == BEAR || botclass == CAT)
+        botclass = CLASS_DRUID;
+    //sObjectMgr->GetPlayerClassLevelInfo(botclass, m_creatureOwner->getLevel(), &classinfo);
+    //const CreatureBaseStats* const classstats = sObjectMgr->GetCreatureBaseStats(mylevel, me->GetBotClass());//use creature class
+    //if (force)
+    //    for (uint8 i = STAT_STRENGTH; i < MAX_STATS; i++)
+    //        me->SetCreateStat(Stats(i), master->GetCreateStat(Stats(i))*0.5f);
+
+    //MAXSTAT
+    float value;
+    for (uint8 i = 0; i < MAX_STATS; ++i)
+    {
+        value = master->GetTotalStatValue(Stats(i));
+        if (i == 0 || value > stat)
+            stat = value;//Get Hightest stat (on first cycle just set base value)
+    }
+    stat = std::max(stat - 18.f, 0.f);//remove base
+
+    //INIT CLASS MODIFIERS
+    //STAT -- 'mod' -- used stat values to apply
+    //WARLOCK
+    //Stamina x0.3  -- health
+    //Armor   x0.35 -- armor
+    //Int     x0.3  -- crit/mana
+    //Spd     x0.15 -- spd (if has mana)
+    //AP      x0.57 -- attack power (if melee pet)
+    //Resist  x0.4  -- resistances
+    //MAGE
+    //
+    //SHAMAN
+    //
+    //HUNTER
+    //Other   x1.0  -- use as default
+    switch (petType)
+    {
+        case PET_TYPE_VOIDWALKER:       ap_mod = 0.57f; spp_mod = 0.15f; crit_mod = 1.0f; break;
+        //case PET_TYPE_FELHUNTER:        ap_mod = 0.57f; spp_mod = 0.15f; crit_mod = 1.0f; break;//NYI
+        //case PET_TYPE_FELGUARD:         ap_mod = 0.57f; spp_mod = 0.15f; crit_mod = 1.0f; break;//NYI
+        //case PET_TYPE_SUCCUBUS:         ap_mod = 0.57f; spp_mod = 0.15f; crit_mod = 1.0f; break;//NYI
+        //case PET_TYPE_IMP:              ap_mod = 0.f;   spp_mod = 0.15f; crit_mod = 1.0f; break;//NYI
+
+        //case PET_TYPE_WATER_ELEMENTAL:  ap_mod = 0.0f;  spp_mod = 0.0f; crit_mod = 0.0f; break;//NYI
+
+        //case PET_TYPE_FIRE_ELEMENTAL:   ap_mod = 0.0f;  spp_mod = 0.0f; crit_mod = 0.0f; break;//NYI
+        //case PET_TYPE_EARTH_ELEMENTAL:  ap_mod = 0.0f;  spp_mod = 0.0f; crit_mod = 0.0f; break;//NYI
+
+        //case PET_TYPE_VULTURE:          ap_mod = 0.9f;  spp_mod = 1.0f; crit_mod = 1.2f; break;//NYI
+        default:                        ap_mod = 0.0f;  spp_mod = 0.0f; crit_mod = 0.0f; break;
+    }
+    //case CLASS_WARRIOR:      ap_mod = 1.3f;  spp_mod = 0.0f; armor_mod = 1.4f;  crit_mod = 1.0f; haste_mod = 0.75f; dodge_mod = 0.75f; parry_mod = 1.75f; break;
+    //case CLASS_DEATH_KNIGHT: ap_mod = 1.2f;  spp_mod = 1.0f; armor_mod = 1.15f; crit_mod = 0.9f; haste_mod = 0.65f; dodge_mod = 0.8f;  parry_mod = 2.0f;  break;//NYI
+    //case CLASS_PALADIN:      ap_mod = 1.0f;  spp_mod = 0.8f; armor_mod = 1.2f;  crit_mod = 0.8f; haste_mod = 0.85f; dodge_mod = 0.7f;  parry_mod = 1.5f;  break;
+    //case CLASS_ROGUE:        ap_mod = 1.5f;  spp_mod = 0.0f; armor_mod = 0.7f;  crit_mod = 1.5f; haste_mod = 1.35f; dodge_mod = 1.5f;  parry_mod = 0.8f;  break;//NYI
+    //case CLASS_HUNTER:       ap_mod = 1.15f; spp_mod = 0.0f; armor_mod = 0.85f; crit_mod = 1.2f; haste_mod = 1.25f; dodge_mod = 1.2f;  parry_mod = 1.2f;  break;//NYI
+    //case CLASS_SHAMAN:       ap_mod = 0.9f;  spp_mod = 1.0f; armor_mod = 0.9f;  crit_mod = 1.2f; haste_mod = 1.65f; dodge_mod = 0.8f;  parry_mod = 0.5f;  break;//NYI
+    //case CLASS_DRUID:        ap_mod = 0.0f;  spp_mod = 1.3f; armor_mod = 0.7f;  crit_mod = 0.7f; haste_mod = 1.95f; dodge_mod = 0.5f;  parry_mod = 0.0f;  break;
+    //case CLASS_MAGE:         ap_mod = 0.0f;  spp_mod = 0.8f; armor_mod = 0.5f;  crit_mod = 0.7f; haste_mod = 1.75f; dodge_mod = 0.5f;  parry_mod = 0.0f;  break;          
+    //case CLASS_PRIEST:       ap_mod = 0.0f;  spp_mod = 1.2f; armor_mod = 0.5f;  crit_mod = 0.7f; haste_mod = 1.75f; dodge_mod = 0.5f;  parry_mod = 0.0f;  break;
+    //case CLASS_WARLOCK:      ap_mod = 0.0f;  spp_mod = 1.0f; armor_mod = 0.5f;  crit_mod = 0.7f; haste_mod = 1.75f; dodge_mod = 0.5f;  parry_mod = 0.0f;  break;
+    //case BEAR:               ap_mod = 2.0f;  spp_mod = 1.3f; armor_mod = 2.25f; crit_mod = 1.0f; haste_mod = 0.75f; dodge_mod = 2.5f;  parry_mod = 0.0f;  break;
+    //case CAT:                ap_mod = 1.5f;  spp_mod = 1.3f; armor_mod = 1.1f;  crit_mod = 1.5f; haste_mod = 2.25f; dodge_mod = 1.35f; parry_mod = 0.0f;  break;
+
+    if (spp_mod != 0.f && mylevel > 39)
+        spp_mod *= (float(mylevel - 39))/41.f;// gain spell power slowly
+
+    //DAMAGE
+    if (ap_mod > 0.f)//do not bother casters
+    {
+        switch (m_creatureOwner->GetBotClass())
+        {
+            case CLASS_WARLOCK:
+                value = float(m_creatureOwner->GetBotAI()->GetSpellPower());
+                break;
+            default://some weird class or NYI
+                value = 0.f;
+                break;
+        }
+        //Calculate ap
+        //set base strength
+        me->SetModifierValue(UNIT_MOD_STAT_STRENGTH, BASE_VALUE, me->GetCreateStat(STAT_STRENGTH) - 9.f);
+        //calc attack power (strength and minion's spd)
+        atpower = me->GetTotalAuraModValue(UNIT_MOD_STAT_STRENGTH)*2.f + value*ap_mod;
+        //set value
+        me->SetModifierValue(UNIT_MOD_ATTACK_POWER, BASE_VALUE, atpower);
+        me->UpdateAttackPowerAndDamage();
+    }
+    
+    //ARMOR
+    value = float(basearmor);
+    //get minion's armor and give 35% to pet (just as for real pets)
+    value += m_creatureOwner->GetModifierValue(UNIT_MOD_ARMOR, BASE_VALUE)*0.35f;
+    me->SetModifierValue(UNIT_MOD_ARMOR, BASE_VALUE, value);
+    me->UpdateArmor();//buffs will be took in consideration here
+
+    //RESISTANCES
+    //based on minion's resistances gain x0.4
+    for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
+    {
+        value = float(master->GetResistance(SpellSchools(i)));
+        me->SetModifierValue(UnitMods(UNIT_MOD_RESISTANCE_START + i), BASE_VALUE, 0.4f*(value*2.5f + float(mylevel*2)));
+        me->UpdateResistances(i);
+    }
+
+    //DAMAGE TAKEN
+    //just get minion's reduction and apply to pet
+    value = m_creatureOwner->GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELL_SCHOOL_MASK_NORMAL);
+    if (value > 1.f)
+        value -= 1.f;
+    else
+        value = 1.f - value;//get reduction even if owner's is 1.0+
+    value = std::min(0.42f, value);
+    value/= 0.01f; //here we get percent like 0.42/0.01 = 42% (value * 100.f)
+    RefreshAura(DMG_TAKEN, int8(value/6.f));//so max aura count = 10
+
+    //HEALTH
+    _OnHealthUpdate(petType, mylevel);
+
+//////RATINGS//////
+    //ok now, pet receives 100% of its master's ratings
+
+    //HASTE
+    haste = m_creatureOwner->GetBotAI()->GetHaste();
+    RefreshAura(HASTE,  haste);//spell haste
+    RefreshAura(HASTE2, haste);//melee haste
+
+    //HIT
+    hit = m_creatureOwner->GetBotAI()->GetHitRating();
+    //RefreshAura(PRECISION,  int8(hit) + mylevel/42);//melee
+    RefreshAura(PRECISION);
+    RefreshAura(PRECISION2, int8(hit) + mylevel/42);//spell
+
+    //CRIT
+    //chose melee or ranged cuz crit rating increases melee/spell, and hunter benefits from agility
+    value = master->GetUnitCriticalChance((master->getClass() == CLASS_HUNTER ? RANGED_ATTACK : BASE_ATTACK), me);
+    if (crit_mod != 1.0f)
+        value *= crit_mod;
+    RefreshAura(CRITS, int8(value/3.f) + mylevel/42);
+
+    //PARRY
+    value = master->GetFloatValue(PLAYER_PARRY_PERCENTAGE);
+    if (master->GetBotTankGuid() == me->GetGUID())//feral cannot parry so let it be base 5%
+        value += 10.f;
+    if (value > 65.f)
+        value = 65.f;
+    float parryAndDodge = value;//set temp value, this is needed to keep total avoidance within 75%
+    RefreshAura(PARRY, int8(value/6.f));
+
+    //DODGE
+    value = master->GetUnitDodgeChance();
+    value = value > 5.f ? value - 5.f : 0.f;//remove base chance if possible
+    if (master->GetBotTankGuid() == me->GetGUID())
+        value += 10.f;
+    if (value > 65.f)
+        value = 65.f;
+    if (parryAndDodge + value > 65.f)
+        value = 65.f - parryAndDodge;//do not allow avoidance to be more than 75% (base 5+5)
+    RefreshAura(DODGE, int8(value/5.f));
+
+    //MANA
+    _OnManaUpdate(petType, mylevel, false);
+
+    //MANA REGEN
+    if (mylevel >= 40 && me->getPowerType() == POWER_MANA)
+    {
+        //let regen rate be same as stats rate x0.3
+        regen_mp5 = m_creatureOwner->GetBotAI()->GetManaRegen()*0.3f;
+        if (regen_mp5 >= 45.f)
+        {
+            me->RemoveAurasDueToSpell(MANAREGEN100);
+            me->RemoveAurasDueToSpell(MANAREGEN45);
+            if      (regen_mp5 > 200.f)   RefreshAura(MANAREGEN100,int8(regen_mp5/100.f) + mylevel/20);
+            else/*if (regen_mp5 > 150.f)*/RefreshAura(MANAREGEN45, int8(regen_mp5/45.f)  + mylevel/20);
+        }
+    }
+
+    //SPELL POWER
+    if (mylevel >= 40 && spp_mod != 0.f)
+    {
+        switch (m_creatureOwner->GetBotClass())
+        {
+            case CLASS_WARLOCK:
+                value = float(m_creatureOwner->GetBotAI()->GetSpellPower());
+                break;
+            default://some weird class or NYI
+                value = 0.f;
+                break;
+        }
+        m_spellpower = int32(value*spp_mod);
+        me->RemoveAurasDueToSpell(SPELL_BONUS_250);
+        me->RemoveAurasDueToSpell(SPELL_BONUS_150);
+        me->RemoveAurasDueToSpell(SPELL_BONUS_50);
+        if      (mylevel < 60) RefreshAura(SPELL_BONUS_50,  m_spellpower/50);
+        else if (mylevel < 85) RefreshAura(SPELL_BONUS_150, m_spellpower/150 + 1);
+        else                   RefreshAura(SPELL_BONUS_250, m_spellpower/250 + 2);
+    }
+
+    if (force)
+    {
+        me->SetFullHealth();
+        me->SetPower(POWER_MANA, me->GetMaxPower(POWER_MANA));
+    }
+
+    shouldUpdateStats = false;
+}
+//Emotion-based action 
+void bot_ai::ReceiveEmote(Player* player, uint32 emote)
+{
+    switch (emote)
+    {
+        case TEXT_EMOTE_BONK:
+            listAuras(player, me);
+            break;
+        case TEXT_EMOTE_SALUTE:
+            listAuras(player, player);
+            break;
+        case TEXT_EMOTE_STAND:
+            if (!IsMinionAI())
+                return;
+            if (master != player)
+            {
+                me->HandleEmoteCommand(EMOTE_ONESHOT_RUDE);
+                return;
+            }
+            SetBotCommandState(COMMAND_STAY);
+            me->MonsterWhisper("Standing Still.", player->GetGUID());
+            break;
+        case TEXT_EMOTE_WAVE:
+            if (!IsMinionAI())
+                return;
+            if (master != player)
+            {
+                me->HandleEmoteCommand(EMOTE_ONESHOT_RUDE);
+                return;
+            }
+            SetBotCommandState(COMMAND_FOLLOW, true);
+            me->MonsterWhisper("Following!", player->GetGUID());
+            break;
+        default:
+            break;
+    }
+}
+
+//ISINBOTPARTY
+//Returns group members (and their npcbots too)
+//For now all your puppets are in your group automatically
+bool bot_ai::IsInBotParty(Unit* unit) const
+{
+    if (!unit) return false;
+    if (unit == me || unit == master) return true;
+
+    //cheap check
+    if (Group* gr = master->GetGroup())
+    {
+        //group member case
+        if (gr->IsMember(unit->GetGUID()))
+            return true;
+        //pointed target case
+        for (uint8 i = 0; i != TARGETICONCOUNT; ++i)
+            if (healTargetIconFlags & GroupIconsFlags[i])
+                if (uint64 guid = gr->GetTargetIcons()[i])//check this one
+                    if (guid == unit->GetGUID())
+                        if (unit->GetReactionTo(master) >= REP_NEUTRAL && 
+                            master->GetVictim() != unit && 
+                            unit->GetVictim() != master)
+                            return true;
+    }
+
+    //Player-controlled creature case
+    if (Creature* cre = unit->ToCreature())
+    {
+        //npcbot/npcbot's pet case
+        if (Player* owner = cre->GetBotOwner())
+        {
+            if (owner == master)
+                return true;
+        }
+        //pets, minions, guardians etc.
+        else
+        {
+            uint64 ownerGuid = unit->GetOwnerGUID();
+            //controlled by group member
+            if (Group* gr = master->GetGroup())
+                if (gr->IsMember(ownerGuid))
+                    return true;
+        }
+    }
+
+    return false;
+}
+
+//REFRESHAURA
+//Applies/reapplies aura stacks
+bool bot_ai::RefreshAura(uint32 spell, int8 count, Unit* target) const
+{
+    if (!spell)
+        return false;
+    if (!target)
+        target = me;
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spell);
+    if (!spellInfo)
+        return false;
+    //if (!spellInfo->IsPassive())
+    //{
+    //    TC_LOG_ERROR(LOG_FILTER_PLAYER, "bot_ai::RefreshAura(): %s received spell %u (%s) which is not a passive spell!", target->GetName().c_str(), spell, spellInfo->SpellName[0]);
+    //    //return false;
+    //}
+    if (target->HasAura(spell))
+        target->RemoveAurasDueToSpell(spell);
+
+    //if (count > 15)
+    //    TC_LOG_ERROR(LOG_FILTER_PLAYER, "bot_ai::RefreshAura(): %s's aura count for spell %u (%s) is greater than 15... (%i)", target->GetName().c_str(), spell, spellInfo->SpellName, count);
+
+    for (uint8 i = 0; i < count; ++i)
+        target->AddAura(spellInfo, MAX_EFFECT_MASK, target);
+    return true;
+}
+//CHECKAURAS
+//Updates bot's condition once a while
+void bot_minion_ai::CheckAuras(bool force)
+{
+    if (checkAurasTimer > 0 && !force) return;
+    opponent = me->GetVictim(); //safe
+    if (checkAurasTimer == 0)
+    {
+        checkAurasTimer = 10 + master->GetNpcBotsCount()/2;
+        if (m_botCommandState != COMMAND_FOLLOW && m_botCommandState != COMMAND_STAY)
+        {
+            if (opponent)
+            {
+                switch (me->GetBotClass())
+                {
+                    case CLASS_MAGE: case CLASS_DRUID: case CLASS_WARLOCK: case CLASS_PRIEST:/* case CLASS_SHAMAN:*/
+                        CalculateAttackPos(opponent, attackpos);
+                        if (me->GetDistance(attackpos) > 8)
+                            GetInPosition(true, true, opponent, &attackpos);
+                        break;
+                    default:
+                        if (me->GetDistance(opponent) > 1.5f)
+                            GetInPosition(true, false);
+                        break;
+                }
+            }
+        }
+        if (shouldUpdateStats)
+            setStats(me->GetBotClass(), me->getRace(), master->getLevel());
+        else
+        {
+            UpdateHealth();
+            UpdateMana();
+        }
+        if (rezz_cd > 0)
+            --rezz_cd;
+        if (clear_cd > 0)
+            --clear_cd;
+        else
+        {
+            FindTank();
+            clear_cd = 15;
+        }
+        return;
+    }
+    else if (force)
+    {
+        if (!opponent)
+        {
+            if (master->isDead())
+            {
+                //If ghost move to corpse, else move to dead player
+                if (master->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+                {
+                    Corpse* corpse = master->GetCorpse();
+                    if (corpse && me->GetMap() == corpse->FindMap() && !me->IsInCombat() && !me->HasUnitState(UNIT_STATE_MOVING) && !IsCasting() && !CCed(me) && me->GetDistance(corpse) > 5)
+                        me->GetMotionMaster()->MovePoint(corpse->GetMapId(), *corpse);
+                }
+                else
+                {
+                    if (m_botCommandState != COMMAND_FOLLOW || me->GetDistance(master) > 30 - 20 * (!me->IsWithinLOSInMap(master)))
+                        Follow(true);
+                }
+            }
+            else if (m_botCommandState != COMMAND_STAY && !IsCasting())
+            {
+                CalculatePos(pos);
+                uint8 followdist = master->GetBotFollowDist();
+                if (me->GetExactDist(&pos) > (followdist > 8 ? 4 + followdist/2*(!master->isMoving()) : 8))
+                    Follow(true, &pos); // check if doing nothing
+            }
+        }
+        if (!IsCasting())
+        {
+            if (me->IsInCombat())
+            {
+                if (me->GetSheath() != SHEATH_STATE_MELEE)
+                    me->SetSheath(SHEATH_STATE_MELEE);
+            }
+            else if (me->IsStandState() && me->GetSheath() != SHEATH_STATE_UNARMED && Rand() < 50)
+                me->SetSheath(SHEATH_STATE_UNARMED);
+        }
+        UpdateMountedState();
+        UpdateStandState();
+        UpdateRations();
+    }
+}
+void bot_pet_ai::CheckAuras(bool /*force*/)
+{
+    if (checkAurasTimer > 0) return;
+    checkAurasTimer = 10 + master->GetNpcBotsCount()/2;
+    if (m_botCommandState != COMMAND_FOLLOW && m_botCommandState != COMMAND_STAY)
+    {
+        opponent = me->GetVictim();
+        if (opponent)
+        {
+            switch (GetPetType(me))
+            {
+                case PET_TYPE_IMP:
+                    CalculateAttackPos(opponent, attackpos);
+                    if (me->GetDistance(attackpos) > 8)
+                        GetInPosition(true, true, opponent, &attackpos);
+                    break;
+                default:
+                    if (me->GetDistance(opponent) > 1.5f)
+                        GetInPosition(true, false);
+                    break;
+            }
+        }
+    }
+    if (clear_cd > 0)
+        --clear_cd;
+    else
+    {
+        FindTank();
+        clear_cd = 15;
+    }
+    return;
+}
+
+bool bot_ai::CanBotAttack(Unit* target, int8 byspell) const
+{
+    if (!target) return false;
+    uint8 followdist = master->GetBotFollowDist();
+    float foldist = _getAttackDistance(float(followdist));
+    return
+       (target->IsAlive() &&
+       target->IsVisible() &&
+       (master->isDead() || target->GetTypeId() == TYPEID_PLAYER || target->IsPet() ||
+       (target->GetDistance(master) < foldist && me->GetDistance(master) < followdist)) &&//if master is killed pursue to the end
+        target->isTargetableForAttack() &&
+        !IsInBotParty(target) &&
+        (target->IsHostileTo(master) ||
+        (target->GetReactionTo(master) < REP_FRIENDLY && master->GetVictim() == target && (master->IsInCombat() || target->IsInCombat())) ||//master has pointed this target
+        target->IsHostileTo(me)) &&//if master is controlled
+        //target->IsWithinLOSInMap(me) &&
+        (byspell == -1 || !target->IsImmunedToDamage(byspell ? SPELL_SCHOOL_MASK_MAGIC : SPELL_SCHOOL_MASK_NORMAL)));
+}
+//GETTARGET
+//Returns attack target or 'no target'
+//uses follow distance if range isn't set
+Unit* bot_ai::getTarget(bool byspell, bool ranged, bool &reset) const
+{
+    //check if no need to change target
+    Unit* u = master->GetVictim();
+    Unit* mytar = me->GetVictim();
+    if (!mytar && IsMinionAI())
+        if (Creature* pet = me->GetBotsPet())
+            mytar = pet->GetVictim();
+
+    if (u && u == mytar)
+    {
+        //TC_LOG_ERROR(LOG_FILTER_PLAYER, "bot %s continues attack common target %s", me->GetName().c_str(), u->GetName().c_str());
+        return u;//forced
+    }
+    //Follow if...
+    uint8 followdist = master->GetBotFollowDist();
+    float foldist = _getAttackDistance(float(followdist));
+    if (!u && master->IsAlive() && (me->GetDistance(master) > foldist || (mytar && master->GetDistance(mytar) > foldist && me->GetDistance(master) > foldist)))
+    {
+        //TC_LOG_ERROR(LOG_FILTER_PLAYER, "bot %s cannot attack target %s, too far away", me->GetName().c_str(), mytar ? mytar->GetName().c_str() : "");
+        return NULL;
+    }
+
+    if (u && (master->IsInCombat() || u->IsInCombat()) && !InDuel(u) && !IsInBotParty(u))
+    {
+        //TC_LOG_ERROR(LOG_FILTER_PLAYER, "bot %s starts attack master's target %s", me->GetName().c_str(), u->GetName().c_str());
+        return u;
+    }
+
+    if (CanBotAttack(mytar, byspell) && !InDuel(mytar))
+    {
+        //TC_LOG_ERROR(LOG_FILTER_PLAYER, "bot %s continues attack its target %s", me->GetName().c_str(), mytar->GetName().c_str());
+        if (me->GetDistance(mytar) > (ranged ? 20.f : 5.f) && m_botCommandState != COMMAND_STAY && m_botCommandState != COMMAND_FOLLOW)
+            reset = true;
+        return mytar;
+    }
+
+    if (followdist == 0 && master->IsAlive())
+        return NULL; //do not bother
+
+    //check group
+    Group* gr = master->GetGroup();
+    if (!gr)
+    {
+        for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
+        {
+            Creature* bot = master->GetBotMap(i)->_Cre();
+            if (!bot || !bot->InSamePhase(me) || bot == me) continue;
+            u = bot->GetVictim();
+            if (u && CanBotAttack(u, byspell) && 
+                (bot->IsInCombat() || u->IsInCombat()) && 
+                (master->isDead() || master->GetDistance(u) < foldist))
+            {
+                //TC_LOG_ERROR(LOG_FILTER_PLAYER, "bot %s hooked %s's victim %s", me->GetName().c_str(), bot->GetName().c_str(), u->GetName().c_str());
+                return u;
+            }
+            Creature* pet = bot->GetIAmABot() ? bot->GetBotsPet() : NULL;
+            if (!pet || !pet->InSamePhase(me)) continue;
+            u = pet->GetVictim();
+            if (u && CanBotAttack(u, byspell) && 
+                (pet->IsInCombat() || u->IsInCombat()) && 
+                (master->isDead() || master->GetDistance(u) < foldist))
+            {
+                //TC_LOG_ERROR(LOG_FILTER_PLAYER, "bot %s hooked %s's victim %s", me->GetName().c_str(), pet->GetName().c_str(), u->GetName().c_str());
+                return u;
+            }
+        }
+    }
+    else
+    {
+        for (GroupReference* ref = gr->GetFirstMember(); ref != NULL; ref = ref->next())
+        {
+            Player* pl = ref->GetSource();
+            if (!pl || !pl->IsInWorld() || pl->IsBeingTeleported()) continue;
+            if (me->GetMap() != pl->FindMap() || !pl->InSamePhase(me)) continue;
+            u = pl->GetVictim();
+            if (u && pl != master && CanBotAttack(u, byspell) && 
+                (pl->IsInCombat() || u->IsInCombat()) && 
+                (master->isDead() || master->GetDistance(u) < foldist))
+            {
+                //TC_LOG_ERROR(LOG_FILTER_PLAYER, "bot %s hooked %s's victim %s", me->GetName().c_str(), pl->GetName().c_str(), u->GetName().c_str());
+                return u;
+            }
+            if (!pl->HaveBot()) continue;
+            for (uint8 i = 0; i != pl->GetMaxNpcBots(); ++i)
+            {
+                Creature* bot = pl->GetBotMap(i)->_Cre();
+                if (!bot || !bot->InSamePhase(me) || bot == me) continue;
+                if (!bot->IsInWorld()) continue;
+                if (me->GetMap() != bot->FindMap()) continue;
+                u = bot->GetVictim();
+                if (u && CanBotAttack(u, byspell) && 
+                    (bot->IsInCombat() || u->IsInCombat()) && 
+                    (master->isDead() || master->GetDistance(u) < foldist))
+                {
+                    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "bot %s hooked %s's victim %s", me->GetName().c_str(), bot->GetName().c_str(), u->GetName().c_str());
+                    return u;
+                }
+                Creature* pet = bot->GetIAmABot() ? bot->GetBotsPet() : NULL;
+                if (!pet || !pet->InSamePhase(me)) continue;
+                if (!pet->IsInWorld()) continue;
+                if (me->GetMap() != pet->FindMap()) continue;
+                u = pet->GetVictim();
+                if (u && CanBotAttack(u, byspell) && 
+                    (pet->IsInCombat() || u->IsInCombat()) && 
+                    (master->isDead() || master->GetDistance(u) < foldist))
+                {
+                    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "bot %s hooked %s's victim %s", me->GetName().c_str(), pet->GetName().c_str(), u->GetName().c_str());
+                    return u;
+                }
+            }
+        }
+    }
+
+    //check targets around
+    Unit* t = NULL;
+    float maxdist = InitAttackRange(float(followdist), ranged);
+    //first cycle we search non-cced target, then, if not found, check all
+    for (uint8 i = 0; i != 2; ++i)
+    {
+        if (!t)
+        {
+            bool attackCC = i;
+
+            CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+            Cell cell(p);
+            cell.SetNoCreate();
+
+            NearestHostileUnitCheck check(me, maxdist, byspell, this, attackCC);
+            Trinity::UnitLastSearcher <NearestHostileUnitCheck> searcher(master, t, check);
+            me->VisitNearbyObject(maxdist, searcher);
+        }
+    }
+
+    if (t && opponent && t != opponent)
+    {
+        //TC_LOG_ERROR(LOG_FILTER_PLAYER, "bot %s has Found new target %s", me->GetName().c_str(), t->GetName().c_str());
+        reset = true;
+    }
+    return t;
+}
+//'CanAttack' function
+bool bot_ai::CheckAttackTarget(uint8 botOrPetType)
+{
+    bool byspell = false, ranged = false, reset = false;
+    if (IsMinionAI())
+    {
+        switch (botOrPetType)
+        {
+            case CLASS_DRUID:
+                byspell = me->GetShapeshiftForm() == FORM_NONE || 
+                    me->GetShapeshiftForm() == FORM_TREE || 
+                    me->GetShapeshiftForm() == FORM_MOONKIN;
+                ranged = byspell;
+                break;
+            case CLASS_PRIEST:
+            case CLASS_MAGE:
+            case CLASS_WARLOCK:
+            case CLASS_SHAMAN:
+                byspell = true;
+                ranged = true;
+                break;
+            case CLASS_HUNTER:
+                ranged = true;
+                break;
+            default:
+                break;
+        }
+    }
+    else
+    {
+        switch (botOrPetType)
+        {
+            case PET_TYPE_IMP:
+                byspell = true;
+                ranged = true;
+                break;
+            default:
+                break;
+        }
+    }
+
+    opponent = getTarget(byspell, ranged, reset);
+    if (!opponent)
+    {
+        me->AttackStop();
+        return false;
+    }
+
+    if (reset)
+        m_botCommandState = COMMAND_ABANDON;//reset AttackStart()
+
+    if (opponent != me->GetVictim())
+        me->Attack(opponent, !ranged);
+    return true;
+}
+//POSITION
+void bot_ai::CalculateAttackPos(Unit* target, Position& pos) const
+{
+    uint8 followdist = master->GetBotFollowDist();
+    float x(0),y(0),z(0),
+        dist = float(6 + urand(followdist/4, followdist/3)),
+        angle = target->GetAngle(me);
+    dist = std::min(dist, 20.f);
+    if (me->GetIAmABotsPet())
+        dist *= 0.5f;
+    float clockwise = RAND(1.f,-1.f);
+    for (uint8 i = 0; i != 5; ++i)
+    {
+        target->GetNearPoint(me, x, y, z, me->GetObjectSize()/2.f, dist, angle);
+        bool toofaraway = master->GetDistance(x,y,z) > (followdist > 30 ? 30.f : followdist < 20 ? 20.f : float(followdist));
+        bool outoflos = !target->IsWithinLOS(x,y,z);
+        if (toofaraway || outoflos)
+        {
+            if (toofaraway)
+                angle = target->GetAngle(master) + frand(0.f, M_PI*0.5f) * clockwise;
+            if (outoflos)
+                dist *= 0.5f;
+        }
+        else
+        {
+            dist *= 0.75f;
+            break;
+        }
+    }
+    pos.m_positionX = x;
+    pos.m_positionY = y;
+    pos.m_positionZ = z;
+}
+// Forces bot to chase opponent (if ranged then distance depends on follow distance)
+void bot_ai::GetInPosition(bool force, bool ranged, Unit* newtarget, Position* mypos)
+{
+    if (me->HasUnitState(UNIT_STATE_ROOT)) return;
+    if (!newtarget)
+        newtarget = me->GetVictim();
+    if (!newtarget)
+        return;
+    if ((!newtarget->IsInCombat() || m_botCommandState == COMMAND_STAY) && !force)
+        return;
+    if (IsCasting())
+        return;
+    uint8 followdist = master->GetBotFollowDist();
+    if (ranged)
+    {
+        if (newtarget->GetTypeId() == TYPEID_PLAYER && 
+            me->GetDistance(newtarget) < 6 + urand(followdist/4, followdist/3)) return;//do not allow constant runaway from player
+        if (!mypos)
+            CalculateAttackPos(newtarget, attackpos);
+        else
+        {
+            attackpos.m_positionX = mypos->m_positionX;
+            attackpos.m_positionY = mypos->m_positionY;
+            attackpos.m_positionZ = mypos->m_positionZ;
+        }
+        if (me->GetDistance(attackpos) > 8)
+            me->GetMotionMaster()->MovePoint(newtarget->GetMapId(), attackpos);
+    }
+    else
+        me->GetMotionMaster()->MoveChase(newtarget);
+    if (newtarget != me->GetVictim())
+        me->Attack(newtarget, !ranged);
+}
+
+bool bot_ai::MoveBehind(Unit& target) const
+{
+    if (me->HasUnitState(UNIT_STATE_ROOT)) return false;
+    if (target.IsWithinCombatRange(me, ATTACK_DISTANCE) &&
+        target.HasInArc(M_PI, me)                       &&
+        tank != me &&
+        (me->GetBotClass() == CLASS_ROGUE ? target.GetVictim() != me || CCed(&target) : target.GetVictim() != me && !CCed(&target)))
+    {
+        float x(0),y(0),z(0);
+        target.GetNearPoint(me, x, y, z, me->GetObjectSize()/3, 0.1f, me->GetAngle(&target));
+        me->GetMotionMaster()->MovePoint(target.GetMapId(), x, y, z);
+        return true;
+    }
+    return false;
+}
+//MOUNT SUPPORT
+void bot_minion_ai::UpdateMountedState()
+{
+    //DEBUG
+    if (master->IsMounted() && me->IsMounted())
+    {
+        if ((master->HasAuraType(SPELL_AURA_FLY) || master->HasUnitMovementFlag(MOVEMENTFLAG_CAN_FLY) || master->HasUnitMovementFlag(MOVEMENTFLAG_FLYING)))
+        {
+            //creature don't benefit from mount flight speed, so force it
+            if (me->GetSpeed(MOVE_FLIGHT) != master->GetSpeed(MOVE_FLIGHT)/2)
+            me->SetSpeed(MOVE_FLIGHT, master->GetSpeed(MOVE_FLIGHT)/2);
+        }
+        return;
+    }
+    bool aura = me->HasAuraType(SPELL_AURA_MOUNTED);
+    bool mounted = me->IsMounted();
+    if ((!master->IsMounted() || aura != mounted || (me->IsInCombat() && opponent)) && (aura || mounted))
+    {
+        me->RemoveAurasByType(SPELL_AURA_MOUNTED);
+        me->Dismount();
+        return;
+    }
+    //END DEBUG
+    if (me->IsInCombat() || IsCasting() || me->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING)) //IsInWater() is too much calculations
+        return;
+    //fly
+    //if ((master->IsMounted() && master->HasAuraType(SPELL_AURA_FLY))/* || master->HasUnitMovementFlag(MOVEMENTFLAG_CAN_FLY) || master->HasUnitMovementFlag(MOVEMENTFLAG_FLYING)*/)
+    //{
+    //    if (!me->IsMounted() || !me->HasAuraType(SPELL_AURA_FLY))
+    //    {
+    //        //if (me->GetBotClass() == CLASS_DRUID && InitSpell(FLY_FORM))//TODO
+    //        //{
+    //        //}
+    //        //else
+    //        {
+    //            uint32 mount = 0;
+    //            Unit::AuraEffectList const &mounts = master->GetAuraEffectsByType(SPELL_AURA_MOUNTED);
+    //            if (!mounts.empty())
+    //                mount = mounts.front()->GetId();
+    //            if (mount)
+    //            {
+    //                if (me->HasAuraType(SPELL_AURA_MOUNTED))
+    //                        me->RemoveAurasByType(SPELL_AURA_MOUNTED);
+    //                if (doCast(me, mount))
+    //                {
+    //                    if (Feasting())
+    //                    {
+    //                        me->RemoveAurasDueToSpell(DRINK);
+    //                        me->RemoveAurasDueToSpell(EAT);
+    //                    }
+    //                }
+    //            }
+    //        }
+    //    }
+    //}
+    ////ground
+    /*else */
+    if (master->IsMounted() && !me->IsMounted() && !master->IsInCombat() && !me->IsInCombat() && !me->GetVictim())
+    {
+        uint32 mount = 0;
+        Unit::AuraEffectList const &mounts = master->GetAuraEffectsByType(SPELL_AURA_MOUNTED);
+        if (!mounts.empty())
+            mount = mounts.front()->GetId();
+        if (mount)
+        {
+            if (me->HasAuraType(SPELL_AURA_MOUNTED))
+                me->RemoveAurasByType(SPELL_AURA_MOUNTED);
+            if (Feasting())
+            {
+                me->RemoveAurasDueToSpell(DRINK);
+                me->RemoveAurasDueToSpell(EAT);
+            }
+            if (doCast(me, mount))
+            {
+                return;
+            }
+        }
+    }
+}
+//STANDSTATE
+void bot_minion_ai::UpdateStandState() const
+{
+    if (master->getStandState() == UNIT_STAND_STATE_STAND && 
+        me->getStandState() == UNIT_STAND_STATE_SIT && 
+        !(me->GetInterruptMask() & AURA_INTERRUPT_FLAG_NOT_SEATED))
+        me->SetStandState(UNIT_STAND_STATE_STAND);
+    if ((master->getStandState() == UNIT_STAND_STATE_SIT || Feasting()) && !me->IsInCombat() && !me->isMoving() && 
+        me->getStandState() == UNIT_STAND_STATE_STAND)
+        me->SetStandState(UNIT_STAND_STATE_SIT);
+
+}
+//RATIONS
+void bot_minion_ai::UpdateRations() const
+{
+    if (me->IsInCombat() || CCed(me))
+    {
+        if (me->HasAura(EAT))   me->RemoveAurasDueToSpell(EAT);
+        if (me->HasAura(DRINK)) me->RemoveAurasDueToSpell(DRINK);
+    }
+
+    //drink
+    if (me->getPowerType() == POWER_MANA && !me->IsMounted() && !me->isMoving() && !CCed(me) && 
+        !me->IsInCombat() && !IsCasting() && urand(0, 100) < 20 && GetManaPCT(me) < 80 && 
+        !me->HasAura(DRINK))
+    {
+        me->CastSpell(me, DRINK);
+        me->SetStandState(UNIT_STAND_STATE_SIT);
+    }
+    if (me->GetPower(POWER_MANA) < me->GetMaxPower(POWER_MANA) && me->HasAura(DRINK))
+        me->ModifyPower(POWER_MANA, me->GetCreateMana()/20);
+
+    //eat
+    if (!me->IsMounted() && !me->isMoving() && !CCed(me) && 
+        !me->IsInCombat() && !IsCasting() && urand(0, 100) < 20 && GetHealthPCT(me) < 80 && 
+        !me->HasAura(EAT))
+    {
+        me->CastSpell(me, EAT);
+        me->SetStandState(UNIT_STAND_STATE_SIT);
+    }
+    if (me->GetHealth() < me->GetMaxHealth() && me->HasAura(EAT))
+        me->SetHealth(me->GetHealth() + me->GetCreateHealth()/20);
+
+    //check
+    if (me->GetHealth() >= me->GetMaxHealth() && me->HasAura(EAT))
+        me->RemoveAurasDueToSpell(EAT);
+
+    if (me->getPowerType() == POWER_MANA && 
+        me->GetPower(POWER_MANA) >= me->GetMaxPower(POWER_MANA) && 
+        me->HasAura(DRINK))
+        me->RemoveAurasDueToSpell(DRINK);
+}
+//PASSIVES
+// Used to apply common passives (run once)
+void bot_ai::ApplyPassives(uint8 botOrPetType) const
+{
+    //me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_TAUNT, true);
+    //me->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_ATTACK_ME, true);
+
+    //apply +healing taken
+    if (master->getLevel() >= 60)
+        RefreshAura(BOR);//+40%
+
+    if (IsPetAI())
+    {
+        switch (botOrPetType)
+        {
+            case PET_TYPE_VOIDWALKER:
+                RefreshAura(DEFENSIVE_STANCE_PASSIVE);
+                break;
+            default:
+                break;
+        }
+    }
+}
+//check if our party players are in duel. if so - ignore them, their opponents and any bots they have
+bool bot_ai::InDuel(Unit* target) const
+{
+    if (!target) return false;
+    bool isbot = target->GetTypeId() == TYPEID_UNIT && (target->ToCreature()->GetIAmABot() || target->ToCreature()->GetIAmABotsPet());
+    Player* player = target->GetTypeId() == TYPEID_PLAYER ? target->ToPlayer() : isbot ? target->ToCreature()->GetBotOwner() : NULL;
+    if (!player)
+    {
+        if (!target->IsControlledByPlayer())
+            return false;
+        player = target->GetCharmerOrOwnerPlayerOrPlayerItself();
+    }
+
+    return (player && player->duel && (IsInBotParty(player) || IsInBotParty(player->duel->opponent)));
+}
+//Used to find target for priest's dispels and mage's spellsteal (also shaman's purge in future)
+//Returns dispellable/stealable 'Any Hostile Unit Attacking BotParty'
+Unit* bot_minion_ai::FindHostileDispelTarget(float dist, bool stealable) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    HostileDispelTargetCheck check(me, dist, stealable, this);
+    Trinity::UnitLastSearcher <HostileDispelTargetCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <HostileDispelTargetCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <HostileDispelTargetCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//Finds single target affected by given spell (and given caster if is)
+//Can check:
+//    hostile targets  (hostile = 0) <default>
+//    our party players (hostile = 1)
+//    our party members  (hostile = 2)
+//    any friendly target (hostile = 3)
+//    any target in range  (hostile = any other value)
+Unit* bot_minion_ai::FindAffectedTarget(uint32 spellId, uint64 caster, float dist, uint8 hostile) const
+{
+    if (master->GetMap()->Instanceable())
+        dist = DEFAULT_VISIBILITY_INSTANCE;
+
+    CellCoord p(Trinity::ComputeCellCoord(master->GetPositionX(), master->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    AffectedTargetCheck check(caster, dist, spellId, master, hostile);
+    Trinity::UnitLastSearcher <AffectedTargetCheck> searcher(master, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <AffectedTargetCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <AffectedTargetCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *master->GetMap(), *master, dist);
+    cell.Visit(p, grid_unit_searcher, *master->GetMap(), *master, dist);
+
+    return unit;
+}
+//Finds target for mage's polymorph (maybe for Hex in future)
+Unit* bot_minion_ai::FindPolyTarget(float dist, Unit* currTarget) const
+{
+    if (!currTarget)
+        return NULL;
+
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    PolyUnitCheck check(me, dist, currTarget);
+    Trinity::UnitLastSearcher <PolyUnitCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <PolyUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <PolyUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//Finds target for direct fear (warlock)
+Unit* bot_minion_ai::FindFearTarget(float dist) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    FearUnitCheck check(me, dist);
+    Trinity::UnitLastSearcher <FearUnitCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <FearUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <FearUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//Finds target for paladin's repentance
+Unit* bot_minion_ai::FindRepentanceTarget(float dist) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    StunUnitCheck check(me, dist);
+    Trinity::UnitLastSearcher <StunUnitCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <StunUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <StunUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//Finds target for priest's shackles
+Unit* bot_minion_ai::FindUndeadCCTarget(float dist, uint32 spellId/* = 0*/) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    UndeadCCUnitCheck check(me, dist, spellId);
+    Trinity::UnitLastSearcher <UndeadCCUnitCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <UndeadCCUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <UndeadCCUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//Finds target for druid's Entangling Roots
+Unit* bot_minion_ai::FindRootTarget(float dist, uint32 spellId) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    RootUnitCheck check(me, me->GetVictim(), dist, spellId);
+    Trinity::UnitLastSearcher <RootUnitCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <RootUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <RootUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//Finds casting target (friend or enemy)
+Unit* bot_minion_ai::FindCastingTarget(float dist, bool isFriend, uint32 spellId) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    CastingUnitCheck check(me, dist, isFriend, spellId);
+    Trinity::UnitLastSearcher <CastingUnitCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <CastingUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <CastingUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+// Returns target for AOE spell (blizzard, hurricane etc.) based on attackers count
+// Cycles through BotParty, first checks player and, if checked, npcbots
+// If checked, can return friendly target as target for AOE spell
+Unit* bot_minion_ai::FindAOETarget(float dist, bool checkbots, bool targetfriend) const
+{
+    if (me->isMoving() || IsCasting()) return NULL;//prevent aoe casts while running away
+    Unit* unit = NULL;
+    Group* pGroup = master->GetGroup();
+    if (!pGroup)
+    {
+        AttackerSet m_attackers = master->getAttackers();
+        if (m_attackers.size() > 1)
+        {
+            uint32 mCount = 0;
+            for(AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+            {
+                if (!(*iter) || (*iter)->isDead()) continue;
+                if ((*iter)->isMoving()) continue;
+                if ((*iter)->HasBreakableByDamageCrowdControlAura())
+                    continue;
+                if (me->GetDistance(*iter) < dist)
+                    ++mCount;
+            }
+            if (mCount > 1)
+            {
+                Unit* u = master->GetVictim();
+                if (mCount > 3 && targetfriend == true)
+                    unit = master;
+                else if (u && FindSplashTarget(dist + 8, u))
+                    unit = u;
+            }//end if
+        }//end if
+        if (!checkbots)
+            return unit;
+        for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
+        {
+            Creature* bot = master->GetBotMap(i)->_Cre();
+            if (!bot || bot->isDead() || !bot->IsInWorld() || me->GetDistance(bot) > dist) continue;
+
+            AttackerSet b_attackers = bot->getAttackers();
+            if (b_attackers.size() > 1)
+            {
+                uint32 mCount = 0;
+                for(AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                {
+                    if (!(*iter) || (*iter)->isDead()) continue;
+                    if ((*iter)->isMoving()) continue;
+                    if ((*iter)->HasBreakableByDamageCrowdControlAura())
+                        continue;
+                    if (me->GetDistance(*iter) < dist)
+                        ++mCount;
+                }
+                if (mCount > 1)
+                {
+                    Unit* u = bot->GetVictim();
+                    if (mCount > 3 && targetfriend == true)
+                        unit = bot;
+                    else if (u && FindSplashTarget(dist + 8, u))
+                        unit = u;
+                }//end if
+            }//end if
+            if (unit) return unit;
+        }//end for
+        return unit;
+    }
+    bool Bots = false;
+    for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player* tPlayer = itr->GetSource();
+        if (!tPlayer) continue;
+        if (checkbots && tPlayer->HaveBot())
+            Bots = true;
+        if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+        if (tPlayer->isDead() || me->GetMap() != tPlayer->FindMap()) continue;
+        if (me->GetDistance(tPlayer) > 40) continue;
+
+        AttackerSet m_attackers = tPlayer->getAttackers();
+        if (m_attackers.size() > 1)
+        {
+            uint32 mCount = 0;
+            for (AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+            {
+                if (!(*iter) || (*iter)->isDead()) continue;
+                if ((*iter)->isMoving()) continue;
+                if (me->GetDistance(*iter) < dist)
+                    ++mCount;
+            }
+            if (mCount > 1)
+            {
+                Unit* u = tPlayer->GetVictim();
+                if (mCount > 3 && targetfriend == true)
+                    unit = tPlayer;
+                else if (u && FindSplashTarget(dist + 8, u))
+                    unit = u;
+            }//end if
+        }//end if
+        if (unit) return unit;
+    }//end for
+    if (!Bots) return NULL;
+    for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player* tPlayer = itr->GetSource();
+        if (tPlayer == NULL || !tPlayer->HaveBot()) continue;
+        if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+        if (me->GetMap() != tPlayer->FindMap()) continue;
+        for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+        {
+            Creature* bot = tPlayer->GetBotMap(i)->_Cre();
+            if (!bot || bot->isDead() || me->GetMap() != bot->FindMap()) continue;
+            if (!bot->IsInWorld()) continue;
+            if (me->GetDistance(bot) > 40) continue;
+
+            AttackerSet b_attackers = bot->getAttackers();
+            if (b_attackers.size() > 1)
+            {
+                uint32 mCount = 0;
+                for(AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                {
+                    if (!(*iter) || (*iter)->isDead()) continue;
+                    if ((*iter)->isMoving()) continue;
+                    if (me->GetDistance(*iter) < dist)
+                        ++mCount;
+                }
+                if (mCount > 1)
+                {
+                    Unit* u = bot->GetVictim();
+                    if (mCount > 3 && targetfriend == true)
+                        unit = bot;
+                    else if (u && FindSplashTarget(dist + 8, u))
+                        unit = u;
+                }//end if
+            }//end if
+        }//end for
+        if (unit) return unit;
+    }//end for
+    return unit;
+}
+// Finds secondary target for spells like Cleave, Swipe, Mind Sear etc.
+Unit* bot_minion_ai::FindSplashTarget(float dist, Unit* To) const
+{
+    if (!To)
+        To = me->GetVictim();
+    if (!To)
+        return NULL;
+
+    if (me->GetDistance(To) > dist)
+        return NULL;
+
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    SecondEnemyCheck check(me, dist, To, this);
+    Trinity::UnitLastSearcher <SecondEnemyCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <SecondEnemyCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <SecondEnemyCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+
+//////////
+//Internal
+//////////
+
+//Using rist-rank spell as source, returns spell of max rank allowed for given caster
+uint32 bot_ai::InitSpell(Unit* caster, uint32 spell)
+{
+    SpellInfo const* info = sSpellMgr->GetSpellInfo(spell);
+    if (!info)
+        return 0;//weird spell with no info, disable it
+
+    uint8 lvl = caster->getLevel();
+    if (lvl < info->BaseLevel)//only 1st rank spells check
+        return 0;//cannot use this spell
+
+    if (SpellInfo const* spInfo = info->GetNextRankSpell())
+    {
+        if (lvl < spInfo->BaseLevel)
+            return spell;//cannot use next rank, use this one
+        else
+            return InitSpell(caster, spInfo->Id);//can use next rank, forward check
+    }
+
+    return spell;//max rank, use this
+}
+//Health magement for minions
+//Including health calcs, set and regeneration
+void bot_minion_ai::_OnHealthUpdate(uint8 myclass, uint8 mylevel) const
+{
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "_OnHealthUpdate(): updating bot %s", me->GetName().c_str());
+    float pct = me->GetHealthPct();// needs for regeneration
+    uint32 m_basehp = classinfo.basehealth;
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "class base health: %u", m_basehp);
+    me->SetCreateHealth(m_basehp);
+    float stammod;
+    switch (myclass)
+    {
+        case CLASS_WARRIOR: case CLASS_DEATH_KNIGHT: case BEAR:
+            switch (master->getClass())
+            {
+                case CLASS_PRIEST: case CLASS_MAGE: case CLASS_WARLOCK:
+                    stammod = 16.f;
+                    break;
+                case CLASS_DRUID: case CLASS_SHAMAN: case CLASS_HUNTER: case CLASS_ROGUE:
+                    stammod = 13.f;
+                    break;
+                default: stammod = 9.8f; break;
+            }
+            break;
+        case CLASS_PALADIN:
+            switch (master->getClass())
+            {
+                case CLASS_PRIEST: case CLASS_MAGE: case CLASS_WARLOCK:
+                    stammod = 15.5f;
+                    break;
+                case CLASS_DRUID: case CLASS_SHAMAN: case CLASS_HUNTER: case CLASS_ROGUE:
+                    stammod = 12.5f;
+                    break;
+                case CLASS_PALADIN:
+                    stammod = 9.8f;
+                    break;
+                default: stammod = 9.f; break;
+            }
+            break;
+        case CLASS_PRIEST: case CLASS_MAGE: case CLASS_WARLOCK:
+            switch (master->getClass())
+            {
+                case CLASS_PRIEST: case CLASS_MAGE: case CLASS_WARLOCK:
+                    stammod = 9.8f;
+                    break;
+                case CLASS_DRUID: case CLASS_SHAMAN: case CLASS_HUNTER: case CLASS_ROGUE:
+                    stammod = 8.f;
+                    break;
+                default: stammod = 5.f; break;
+            }
+            break;
+        case CLASS_DRUID: case CAT: case CLASS_SHAMAN: case CLASS_HUNTER: case CLASS_ROGUE:
+            switch (master->getClass())
+            {
+                case CLASS_PRIEST: case CLASS_MAGE: case CLASS_WARLOCK:
+                    stammod = 12.f;
+                    break;
+                case CLASS_DRUID: case CLASS_SHAMAN: case CLASS_HUNTER: case CLASS_ROGUE:
+                    stammod = 9.8f;
+                    break;
+                default: stammod = 8.f; break;
+            }
+            break;
+        default: stammod = 10.f;
+            break;
+    }
+    stammod -= 0.3f;
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "stammod: %f", stammod);
+    
+    //manually pick up stamina from bot's buffs
+    float stamValue = me->GetTotalStatValue(STAT_STAMINA);
+    stamValue = std::max(stamValue - 18.f, 1.f); //remove base stamina (not calculated into health)
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "bot's stats to health add: Stamina (%f), value: %f", stamValue, stamValue * 10.f);
+    int32 hp_add = int32(stamValue * 10.f);
+    //pick up master's stamina from items
+    float total_pct = std::max((master->GetModifierValue(UNIT_MOD_STAT_STAMINA, TOTAL_PCT) - 0.1f), 1.f);
+    float base_stam = master->GetModifierValue(UNIT_MOD_STAT_STAMINA, BASE_VALUE);
+    base_stam = std::max(base_stam - 18.f, 0.f); //remove base stamina (not calculated into health)
+    stamValue = base_stam * master->GetModifierValue(UNIT_MOD_STAT_STAMINA, BASE_PCT) * total_pct;
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "stat to health add: Stamina (%f), value: %f", stamValue, stamValue*stammod);
+    hp_add += int32(stamValue*stammod);
+    //float stamstat = stat * 0.5f;
+    //if (stamValue > stamstat)
+    //{
+    //    //sLog->outBasic("selected stat to health add: Stamina (%f), value: %f", stamValue, stamValue*stammod);
+    //    hp_add += int32(stamValue * stammod);
+    //}
+    //else
+    //{
+    //    //sLog->outBasic("selected stat to health add: stamStat (%f), value: %f", stamstat, stamstat*stammod);
+    //    hp_add += int32(stamstat * stammod);
+    //}
+    //sLog->outBasic("health to add after master's stat mod: %i", hp_add);
+    int32 miscVal = me->getGender()*mylevel;
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "health to remove from gender mod: %i", -miscVal);
+    hp_add -= miscVal;//less hp for females lol
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "health to add after gender mod: %i", hp_add);
+    //miscVal = myrace*(mylevel/5);
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "health to add from race mod: %i", miscVal);
+    //hp_add += miscVal;//draenei tanks lol
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "health to add after race mod: %i", hp_add);
+    miscVal = master->GetNpcBotSlot(me->GetGUID()) * (mylevel/5);
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "health to remove from slot mod: %i", -miscVal);
+    hp_add -= miscVal;
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "health to add after slot mod: %i", hp_add);
+    uint32 m_totalhp = m_basehp + hp_add;//m_totalhp = uint32(float(m_basehp + hp_add) * stammod);
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "total base health: %u", m_totalhp);
+    if (master->GetBotTankGuid() == me->GetGUID())
+    {
+        m_totalhp = (m_totalhp * 135) / 100;//35% hp bonus for tanks
+        //sLog->outBasic("total base health (isTank): %u", m_totalhp);
+    }
+    me->SetModifierValue(UNIT_MOD_HEALTH, BASE_VALUE, float(m_totalhp));//replaces base hp at max lvl
+    me->UpdateMaxHealth();//will use our values we just set (update base health and buffs)
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "overall hp: %u", me->GetMaxHealth());
+    me->SetHealth(uint32(0.5f + float(me->GetMaxHealth()) * pct / 100.f));//restore pct
+    if (!me->IsInCombat())
+        me->SetHealth(me->GetHealth() + m_basehp / 100);//regenerate
+}
+//Mana management for minions
+//Including calcs and set
+void bot_minion_ai::_OnManaUpdate(uint8 myclass, uint8 mylevel, bool shapeshift)
+{
+    if (me->getPowerType() != POWER_MANA)
+        return;
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "_OnManaUpdate(): updating bot %s", me->GetName().c_str());
+    float pct = (float(me->GetPower(POWER_MANA)) * 100.f) / float(me->GetMaxPower(POWER_MANA));
+    float m_basemana = classinfo.basemana > 0 ? classinfo.basemana : me->GetCreateMana();
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "classinfo base mana = %f", m_basemana);
+    me->SetCreateMana(m_basemana);//set base mana, critical
+    float manamod = 15.f;//here we set mana multiplier from intellect as we gain mana from MASTER's stats mostly
+    switch (myclass)
+    {
+        case CLASS_PALADIN: case CLASS_HUNTER: manamod =  4.5f; break;
+        case CLASS_SHAMAN:                     manamod = 11.5f; break;
+        case CLASS_DRUID:                      manamod = 12.5f; break;
+        case CLASS_PRIEST:                     manamod = 16.5f; break;
+        case CLASS_MAGE: case CLASS_WARLOCK:   manamod = 10.5f; break;
+        default:                                                break;
+    }
+    //manamod += 1.f;//custom
+    //manamod *= 0.70f;//custom
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "Manamod: %f", manamod);
+    float intValue = me->GetTotalStatValue(STAT_INTELLECT);
+    intValue = std::max(intValue - 18.f, 1.f); //remove base int (not calculated into mana)
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "bot's stats to mana add: Int (%f), value: %f", intValue, intValue * manamod);
+    m_basemana += intValue * 15.f;
+    //pick up master's intellect from items if master has mana
+    if (master->getPowerType() == POWER_MANA)
+    {
+        float total_pct = std::max((master->GetModifierValue(UNIT_MOD_STAT_INTELLECT, TOTAL_PCT) - 0.1f), 1.f);
+        intValue = std::max(master->GetModifierValue(UNIT_MOD_STAT_INTELLECT, BASE_VALUE) - 18.f, 1.f); //remove base int (not calculated into mana)
+        intValue = intValue * master->GetModifierValue(UNIT_MOD_STAT_INTELLECT, BASE_PCT) * total_pct;
+    }
+    else// pick up maxstat
+        intValue = stat * 0.5f;
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "mana add from master's stat: %f", intValue * manamod);
+    m_basemana += intValue * manamod;
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "base mana + mana from master's intellect or stat: %f", m_basemana);
+    //intValue = me->GetTotalAuraModValue(UNIT_MOD_STAT_INTELLECT);
+    //sLog->outBasic("Intellect from buffs: %f", intValue);
+    //m_basemana += uint32(intValue) * manamod;
+    //sLog->outBasic("base mana + mana from intellect + mana from buffs: %u", m_basemana);
+    uint8 otherVal = me->getGender()*3*mylevel;
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "mana to add from gender mod: %u", otherVal);
+    m_basemana += float(otherVal);//more mana for females lol
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "base mana after gender mod: %f", m_basemana);
+    otherVal = master->GetNpcBotSlot(me->GetGUID()) * (mylevel/5);// only to make mana unique
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "mana to remove from slot mod: %i", -int8(otherVal));
+    m_basemana -= otherVal;
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "base mana after slot mod: %f", m_basemana);
+    float m_totalmana = m_basemana;
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "total mana to set: %f", m_totalmana);
+    me->SetModifierValue(UNIT_MOD_MANA, BASE_VALUE, m_totalmana);
+    me->UpdateMaxPower(POWER_MANA);
+    //TC_LOG_ERROR(LOG_FILTER_PLAYER, "Overall mana to set: %u", me->GetMaxPower(POWER_MANA));
+    if (tempMana)
+    {
+        me->SetPower(POWER_MANA, tempMana);
+        if (shapeshift == false)
+            tempMana = 0;
+    }
+    else
+        me->SetPower(POWER_MANA, uint32(0.5f + float(me->GetMaxPower(POWER_MANA)) * pct / 100.f));//restore pct
+    //No Regen
+}
+//Melee damage for minions (melee classes only)
+//Calculation is based on master's attack power if melee/hunter or spellpower 
+void bot_minion_ai::_OnMeleeDamageUpdate(uint8 myclass) const
+{
+    if (ap_mod == 0.f) return; //do not bother casters
+    //sLog->outBasic("_OnMeleeDamageUpdate: Updating bot %s", me->GetName().c_str());
+    float my_ap_mod = ap_mod;
+    float mod = master->getClass() == CLASS_HUNTER ? (master->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, BASE_PCT) + master->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, TOTAL_PCT))/2.f : 
+        (master->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, BASE_PCT) + master->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_PCT))/2.f;
+    mod = std::max(mod, 1.f); // x1 is Minimum
+    mod = std::min(mod, 2.5f); // x2.5 is Maximum
+    //sLog->outBasic("got base damage modifier: %f", mod);
+    mod -= (mod - 1.f)*0.33f;//reduce bonus by 33%
+    //sLog->outBasic("damage modifier truencated to %f, applying", mod);
+    me->SetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, BASE_PCT, mod);
+    me->SetModifierValue(UNIT_MOD_DAMAGE_OFFHAND, BASE_PCT, mod);
+    me->SetModifierValue(UNIT_MOD_DAMAGE_RANGED, BASE_PCT, mod);
+    me->SetCanDualWield(myclass == CLASS_ROGUE || myclass == CLASS_SHAMAN);
+    //Rogue has mainhand attack speed 1900, other dual-wielders - 2800 or 2600 or 2400
+    if (myclass == CLASS_ROGUE)
+        me->SetAttackTime(BASE_ATTACK, 1900);
+    if (me->CanDualWield())
+        me->SetAttackTime(OFF_ATTACK, myclass == CLASS_ROGUE ? 1400 : 1800);
+    //me->SetModifierValue(UNIT_MOD_DAMAGE_RANGED, BASE_PCT, mod);//NUY
+    mod = (mod - 1.f)*0.5f;
+    //sLog->outBasic("reduced damage modifier to gain bonus: %f", mod);
+    //sLog->outBasic("base ap modifier is %f", my_ap_mod);
+    my_ap_mod *= 0.5f;
+    //sLog->outBasic("ap modifier multiplied to %f", my_ap_mod);
+    my_ap_mod += my_ap_mod > 0.f ? mod : 0.f; //add reduced master's multiplier if can have damage
+    //sLog->outBasic("ap modifier + mod = %f", my_ap_mod);
+    me->SetModifierValue(UNIT_MOD_ATTACK_POWER, BASE_PCT, my_ap_mod);
+    me->SetModifierValue(UNIT_MOD_ATTACK_POWER_RANGED, BASE_PCT, my_ap_mod);
+
+    int32 sppower = 0;
+    for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
+    {
+        int32 power = master->SpellBaseDamageBonusDone(SpellSchoolMask(1 << i));
+        if (power > sppower)
+            sppower = power;
+    }
+    //sLog->outBasic("master's spellpower is %i, multiplying...", sppower);
+    sppower *= 1.5f;
+    //sLog->outBasic("got spellpower of %i", sppower);
+    //atpower = float(master->GetInt32Value(master->getClass() == CLASS_HUNTER ? UNIT_FIELD_RANGED_ATTACK_POWER : UNIT_FIELD_ATTACK_POWER));
+    float atpower = master->GetTotalAttackPowerValue(master->getClass() == CLASS_HUNTER ? RANGED_ATTACK : BASE_ATTACK);
+    //sLog->outBasic("master's base attack power is %f", atpower);
+    atpower = sppower > atpower ? sppower : atpower;//highest stat is used (either 1.5x spellpower or attack power)
+    //sLog->outBasic("chosen attack power stat value: %f", atpower);
+    //sLog->outBasic("expected attack power: %f", atpower*ap_mod);
+
+    me->SetModifierValue(UNIT_MOD_ATTACK_POWER, BASE_VALUE, atpower);
+    if (myclass == CLASS_HUNTER || myclass == CLASS_ROGUE)
+    {
+        me->SetModifierValue(UNIT_MOD_ATTACK_POWER_RANGED, BASE_VALUE, atpower);
+        me->UpdateAttackPowerAndDamage(true);
+    }
+    me->UpdateAttackPowerAndDamage();
+    //sLog->outBasic("listing stats: ");
+    //sLog->outBasic("attack power main hand: %f", me->GetTotalAttackPowerValue(BASE_ATTACK));
+    //sLog->outBasic("attack power off hand: %f", me->GetTotalAttackPowerValue(OFF_ATTACK));
+    //sLog->outBasic("attack power ranged: %f", me->GetTotalAttackPowerValue(RANGED_ATTACK));
+    //sLog->outBasic("damage multiplier main hand: %f", me->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, BASE_PCT) * me->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_PCT));
+    //sLog->outBasic("damage multiplier off hand: %f", me->GetModifierValue(UNIT_MOD_DAMAGE_OFFHAND, BASE_PCT) * me->GetModifierValue(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_PCT));
+    //sLog->outBasic("damage multiplier ranged: %f", me->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, BASE_PCT) * me->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, TOTAL_PCT));
+    //sLog->outBasic("Damage range main hand: min: %f, max: %f", me->GetFloatValue(UNIT_FIELD_MINDAMAGE), me->GetFloatValue(UNIT_FIELD_MAXDAMAGE));
+    //sLog->outBasic("Damage range off hand: min: %f, max: %f", me->GetFloatValue(UNIT_FIELD_MINOFFHANDDAMAGE), me->GetFloatValue(UNIT_FIELD_MAXOFFHANDDAMAGE));
+    //sLog->outBasic("Damage range ranged: min: %f, max: %f", me->GetFloatValue(UNIT_FIELD_MINRANGEDDAMAGE), me->GetFloatValue(UNIT_FIELD_MAXRANGEDDAMAGE));
+}
+//Health for pets
+//Same as for minions just simplified (modified to match real pets' values)
+void bot_pet_ai::_OnHealthUpdate(uint8 /*petType*/, uint8 mylevel) const
+{
+    float hp_mult = 10.f;
+    switch (GetPetType(me))
+    {
+        case PET_TYPE_VOIDWALKER:
+            hp_mult = 11.f;
+            break;
+        default:
+            break;
+    }
+    float pct = me->GetHealthPct();// needs for regeneration
+    //Use simple checks and calcs
+    //0.3 hp for bots (inaccurate but cheap)
+    uint32 m_basehp = me->GetCreateHealth()/2;
+    //pick up stamina from buffs
+    float stamValue = me->GetTotalStatValue(STAT_STAMINA);
+    stamValue = std::max(stamValue - 18.f, 1.f); //remove base stamina (not calculated into health)
+    uint32 hp_add = uint32(stamValue*hp_mult);
+    hp_add += (m_creatureOwner->GetMaxHealth() - m_creatureOwner->GetCreateHealth())*0.3f;
+    uint8 miscVal = GetPetType(me)*mylevel;
+    hp_add -= miscVal;
+    uint32 m_totalhp = m_basehp + hp_add;
+    if (master->GetBotTankGuid() == me->GetGUID())
+        m_totalhp = (m_totalhp*135) / 100;//35% hp bonus for tanks
+    me->SetModifierValue(UNIT_MOD_HEALTH, BASE_VALUE, float(m_totalhp));
+    me->UpdateMaxHealth();//will use values set (update base health and buffs)
+    me->SetHealth(uint32(0.5f + float(me->GetMaxHealth())*pct / 100.f));//restore pct
+    if (!me->IsInCombat())
+        me->SetHealth(me->GetHealth() + m_basehp / 100);//regenerate
+}
+//Mana for pets
+//Same as for minions just simplified (modified to match real pets' values)
+void bot_pet_ai::_OnManaUpdate(uint8 /*petType*/, uint8 mylevel, bool /*shapeshift*/)
+{
+    if (me->getPowerType() != POWER_MANA)
+        return;
+
+    float mana_mult = 15.f;
+    switch (GetPetType(me))
+    {
+        case PET_TYPE_VOIDWALKER:
+            mana_mult = 11.5f;
+            break;
+        default:
+            break;
+    }
+    float pct = (float(me->GetPower(POWER_MANA)) * 100.f) / float(me->GetMaxPower(POWER_MANA));
+    //Use simple checks and calcs
+    //0.3 mana for bots (inaccurate but cheap)
+    float m_basemana = float(me->GetCreateMana());
+    m_basemana += (std::max<float>(me->GetTotalStatValue(STAT_INTELLECT) - 18.f, 1.f))*mana_mult; //remove base stamina (not calculated into mana)
+    m_basemana += float(m_creatureOwner->GetMaxPower(POWER_MANA) - m_creatureOwner->GetCreateMana())*0.3f;
+    m_basemana -= float(GetPetType(me)*mylevel);
+    me->SetModifierValue(UNIT_MOD_MANA, BASE_VALUE, m_basemana);
+    me->UpdateMaxPower(POWER_MANA);
+    me->SetPower(POWER_MANA, uint32(0.5f + float(me->GetMaxPower(POWER_MANA))*pct / 100.f));//restore pct
+}
+//Sends all master's bots a message to not try to evade for a certain period of time
+void bot_ai::SendPartyEvadeAbort() const
+{
+    for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
+        if (Creature* bot = master->GetBotMap(i)->_Cre())
+            if (bot_minion_ai* ai = bot->GetBotMinionAI())
+                ai->SetEvadeTimer(50);
+}
+//Removes buggy bots' threat from party, so no 'stuck in combat' bugs form bot mod
+//optionally interrupts casted spell if target is dead for bot and it's pet
+void bot_minion_ai::_OnEvade()
+{
+    if (me->HasUnitState(UNIT_STATE_CASTING))
+        for (uint8 i = CURRENT_FIRST_NON_MELEE_SPELL; i != CURRENT_AUTOREPEAT_SPELL; ++i)
+            if (Spell* spell = me->GetCurrentSpell(CurrentSpellTypes(i)))
+                if (!spell->GetSpellInfo()->IsChanneled())
+                    if (Unit* u = spell->m_targets.GetUnitTarget())
+                        if (u->isDead() && !IsInBotParty(u))
+                            me->InterruptSpell(CurrentSpellTypes(i), false, false);
+
+    Creature* m_botsPet = me->GetBotsPet();
+    if (m_botsPet && m_botsPet->HasUnitState(UNIT_STATE_CASTING))
+        for (uint8 i = CURRENT_FIRST_NON_MELEE_SPELL; i != CURRENT_AUTOREPEAT_SPELL; ++i)
+            if (Spell* spell = m_botsPet->GetCurrentSpell(CurrentSpellTypes(i)))
+                if (!spell->GetSpellInfo()->IsChanneled())
+                    if (Unit* u = spell->m_targets.GetUnitTarget())
+                        if (u->isDead() && !IsInBotParty(u))
+                            m_botsPet->InterruptSpell(CurrentSpellTypes(i), false, false);
+
+    if (Rand() > 10) return;
+    if (!master->IsInCombat() && !me->IsInCombat() && (!m_botsPet || !m_botsPet->IsInCombat())) return;
+    if (CheckAttackTarget(GetBotClassForCreature(me)))
+        return;
+    //ChatHandler ch(master);
+    //ch.PSendSysMessage("_OnEvade() by bot %s", me->GetName().c_str());
+    if (master->IsInCombat())
+    {
+        HostileRefManager& mgr = master->getHostileRefManager();
+        if (!mgr.isEmpty())
+        {
+            std::set<Unit*> Set;
+            HostileReference* ref = mgr.getFirst();
+            while (ref)
+            {
+                if (ref->GetSource() && ref->GetSource()->GetOwner())
+                    Set.insert(ref->GetSource()->GetOwner());
+                ref = ref->next();
+            }
+            for (std::set<Unit*>::const_iterator i = Set.begin(); i != Set.end(); ++i)
+            {
+                Unit* unit = (*i);
+                if (/*unit->IsFriendlyTo(master)*/IsInBotParty(unit) || !unit->IsInCombat())
+                {
+                    //ch.PSendSysMessage("_OnEvade(): %s's hostile reference is removed from %s!", unit->GetName().c_str(), master->GetName().c_str());
+                    mgr.deleteReference(unit);
+                }
+            }
+        }
+    }
+    else
+    {
+        SendPartyEvadeAbort();
+        for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
+        {
+            Creature* cre = master->GetBotMap(i)->_Cre();
+            if (!cre) continue;
+            if (cre->IsInCombat())
+            {
+                cre->DeleteThreatList();
+                HostileRefManager& mgr = cre->getHostileRefManager();
+                if (!mgr.isEmpty())
+                {
+                    std::set<Unit*> Set;
+                    HostileReference* ref = mgr.getFirst();
+                    while (ref)
+                    {
+                        if (ref->GetSource() && ref->GetSource()->GetOwner())
+                            Set.insert(ref->GetSource()->GetOwner());
+                        ref = ref->next();
+                    }
+                    for (std::set<Unit*>::const_iterator i = Set.begin(); i != Set.end(); ++i)
+                    {
+                        Unit* unit = (*i);
+                        if (!unit->InSamePhase(me)) continue;
+                        if (/*unit->IsFriendlyTo(master)*/IsInBotParty(unit) || !unit->IsInCombat())
+                        {
+                            //ch.PSendSysMessage("_OnEvade(): %s's hostile reference is removed from %s!", unit->GetName().c_str(), cre->GetName().c_str());
+                            mgr.deleteReference(unit);
+                        }
+                    }
+                }
+                //if (mgr.isEmpty())// has empty threat list and no hostile refs - we have all rights to stop combat
+                //{
+                //    if (cre->IsInCombat())
+                //    {
+                //        //ch.PSendSysMessage("_OnEvade(): %s's HostileRef is empty! Combatstop!", cre->GetName().c_str());
+                //        cre->ClearInCombat();
+                //    }
+                //}
+            }
+
+            Creature* m_botsPet = cre->GetBotsPet();
+            if (!m_botsPet || !m_botsPet->IsInCombat()) continue;
+            m_botsPet->DeleteThreatList();
+            HostileRefManager& mgr = m_botsPet->getHostileRefManager();
+            if (!mgr.isEmpty())
+            {
+                std::set<Unit*> Set;
+                HostileReference* ref = mgr.getFirst();
+                while (ref)
+                {
+                    if (ref->GetSource() && ref->GetSource()->GetOwner())
+                        Set.insert(ref->GetSource()->GetOwner());
+                    ref = ref->next();
+                }
+                for (std::set<Unit*>::const_iterator i = Set.begin(); i != Set.end(); ++i)
+                {
+                    Unit* unit = (*i);
+                    if (!unit->InSamePhase(me)) continue;
+                    if (/*unit->IsFriendlyTo(master)*/IsInBotParty(unit) || !unit->IsInCombat())
+                    {
+                        //ch.PSendSysMessage("_OnEvade(): %s's hostile reference is removed from %s!", unit->GetName().c_str(), m_botsPet->GetName().c_str());
+                        mgr.deleteReference(unit);
+                    }
+                }
+            }
+            //if (mgr.isEmpty())// has empty threat list and no hostile refs - we have all rights to stop combat
+            //{
+            //    if (m_botsPet->IsInCombat())
+            //    {
+            //        //ch.PSendSysMessage("_OnEvade(): %s's HostileRef is empty! Combatstop!", pet->GetName().c_str());
+            //        m_botsPet->ClearInCombat();
+            //    }
+            //}
+        }
+    }
+}
+//SpellHit()... OnSpellHit()
+void bot_ai::OnSpellHit(Unit* /*caster*/, SpellInfo const* spell)
+{
+    for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+    {
+        uint32 auraname = spell->Effects[i].ApplyAuraName;
+        //remove pet on mount
+        if (auraname == SPELL_AURA_MOUNTED)
+            me->SetBotsPetDied();
+        //update stats
+        if (auraname == SPELL_AURA_MOD_STAT)
+        {
+            doHealth = true;
+            doMana = true;
+        }
+        else
+        {
+            if (auraname == SPELL_AURA_MOD_INCREASE_HEALTH || 
+                auraname == SPELL_AURA_MOD_INCREASE_HEALTH_2 || 
+                auraname == SPELL_AURA_MOD_MAX_HEALTH ||  // SPELL_AURA_MOD_INCREASE_HEALTH_2,SPELL_AURA_230
+                auraname == SPELL_AURA_MOD_INCREASE_HEALTH_PERCENT)
+                doHealth = true;
+            else if (auraname == SPELL_AURA_MOD_INCREASE_ENERGY || 
+                auraname == SPELL_AURA_MOD_INCREASE_ENERGY_PERCENT)
+                doMana = true;
+        }
+    }
+}
+//Messed up
+//Hp + Mana update
+//target update
+//returns fake wait time between overall AI updates (if it is even understandable)
+uint8 bot_ai::GetWait()
+{
+    if (doHealth)
+    {
+        doHealth = false;
+        _OnHealthUpdate(me->GetBotClass(), master->getLevel());
+    }
+    if (doMana)
+    {
+        doMana = false;
+        _OnManaUpdate(me->GetBotClass(), master->getLevel());
+    }
+    CheckAuras(true);
+    //0 to 2 plus 1 for every 3 bots except first one
+    return (1 + (master->GetNpcBotsCount() - 1)/3 + (irand(0,100) <= 50)*int8(RAND(-1,1)));
+}
+//Damage Mods
+//1) Apply class-specified damage/crit chance/crit damage bonuses
+//2) Apply bot damage multiplier
+//3) Remove Creature damage multiplier (make independent from original config)
+//Bug with config reload (creatures do not update their damage on reload) is not bot-related but still annoying
+void bot_ai::ApplyBotDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const
+{
+    ApplyClassDamageMultiplierMelee(damage, damageinfo);
+    damage = int32(float(damage)*dmgmult_melee/dmgmod_melee);
+}
+void bot_ai::ApplyBotDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const
+{
+    ApplyClassDamageMultiplierMelee(damage, damageinfo, spellInfo, attackType, crit);
+    damage = int32(float(damage)*dmgmult_melee/dmgmod_melee);
+}
+void bot_ai::ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const
+{
+    ApplyClassDamageMultiplierSpell(damage, damageinfo, spellInfo, attackType, crit);
+    damage = int32(float(damage)*dmgmult_spell/dmgmod_spell);
+}
+void bot_ai::ApplyBotDamageMultiplierEffect(SpellInfo const* spellInfo, uint8 effect_index, float &value) const
+{
+    //Only for damage effects which can scale (TC check)
+    bool canEffectScale = false;
+    switch (spellInfo->Effects[effect_index].Effect)
+    {
+        case SPELL_EFFECT_SCHOOL_DAMAGE:
+        //case SPELL_EFFECT_DUMMY:
+        //case SPELL_EFFECT_POWER_DRAIN:
+        //case SPELL_EFFECT_HEALTH_LEECH:
+        //case SPELL_EFFECT_HEAL:
+        case SPELL_EFFECT_WEAPON_DAMAGE:
+        //case SPELL_EFFECT_POWER_BURN:
+        //case SPELL_EFFECT_SCRIPT_EFFECT:
+        case SPELL_EFFECT_NORMALIZED_WEAPON_DMG:
+        //case SPELL_EFFECT_FORCE_CAST_WITH_VALUE:
+        //case SPELL_EFFECT_TRIGGER_SPELL_WITH_VALUE:
+        //case SPELL_EFFECT_TRIGGER_MISSILE_SPELL_WITH_VALUE:
+            canEffectScale = true;
+            break;
+        default:
+            break;
+    }
+    switch (spellInfo->Effects[effect_index].ApplyAuraName)
+    {
+        case SPELL_AURA_PERIODIC_DAMAGE:
+        //case SPELL_AURA_DUMMY:
+        //case SPELL_AURA_PERIODIC_HEAL:
+        //case SPELL_AURA_DAMAGE_SHIELD:
+        case SPELL_AURA_PROC_TRIGGER_DAMAGE:
+        //case SPELL_AURA_PERIODIC_LEECH:
+        //case SPELL_AURA_PERIODIC_MANA_LEECH:
+        //case SPELL_AURA_SCHOOL_ABSORB:
+        //case SPELL_AURA_PERIODIC_TRIGGER_SPELL_WITH_VALUE:
+            canEffectScale = true;
+            break;
+        default:
+            break;
+    }
+
+    if (!canEffectScale)
+        return;
+
+    ApplyClassDamageMultiplierEffect(spellInfo, value);
+
+    if (spellInfo->DmgClass == SPELL_DAMAGE_CLASS_MELEE || spellInfo->DmgClass == SPELL_DAMAGE_CLASS_RANGED)
+        value = value*dmgmult_melee/dmgmod_melee;
+    else if (spellInfo->DmgClass == SPELL_DAMAGE_CLASS_NONE || spellInfo->DmgClass == SPELL_DAMAGE_CLASS_MAGIC)
+        value = value*dmgmult_spell/dmgmod_spell;
+}
+//////////
+//GOSSIP//
+//////////
+//Implemented: Mage,.. and nothing more...
+bool bot_minion_ai::OnGossipHello(Player* player, Creature* creature)
+{
+    switch (creature->GetBotClass())
+    {
+        case CLASS_MAGE:
+            if (creature->IsInCombat())
+            {
+                player->CLOSE_GOSSIP_MENU();
+                break;
+            }
+            player->ADD_GOSSIP_ITEM(0, "I need food", 6001, GOSSIP_ACTION_INFO_DEF + 1);
+            player->ADD_GOSSIP_ITEM(0, "I need drink", 6001, GOSSIP_ACTION_INFO_DEF + 2);
+            player->PlayerTalkClass->SendGossipMenu(GOSSIP_SERVE_MASTER, creature->GetGUID());
+            break;
+        default:
+            player->CLOSE_GOSSIP_MENU();
+            break;
+    }
+    return true;
+}
+//GossipSelect
+//Mage: rations implemented
+bool bot_minion_ai::OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+{
+    if (!IsInBotParty(player))
+    {
+        player->CLOSE_GOSSIP_MENU();
+        creature->MonsterWhisper("Get away from me!", player->GetGUID());
+        return false;
+    }
+    switch (creature->GetBotClass())
+    {
+        case CLASS_MAGE:
+            switch (sender)
+            {
+                case 6001:// food/drink
+                {
+                    //Prevent high-leveled consumables for low-level characters
+                    Unit* checker;
+                    if (player->getLevel() < creature->getLevel())
+                        checker = player;
+                    else
+                        checker = creature;
+
+                    // Conjure Refreshment rank 1
+                    uint32 food = InitSpell(checker, 42955);
+                    bool iswater = (action == GOSSIP_ACTION_INFO_DEF + 2);
+                    if (!food)
+                    {
+                        if (!iswater)// Conjure Food rank 1
+                            food = InitSpell(checker, 587);
+                        else// Conjure Water rank 1
+                            food = InitSpell(checker, 5504);
+                    }
+                    if (!food)
+                    {
+                        std::string errorstr = "I can't conjure ";
+                        errorstr += iswater ? "water" : "food";
+                        errorstr += " yet";
+                        creature->MonsterWhisper(errorstr.c_str(), player->GetGUID());
+                        //player->PlayerTalkClass->ClearMenus();
+                        //return OnGossipHello(player, creature);
+                        player->CLOSE_GOSSIP_MENU();
+                        return false;
+                    }
+                    player->CLOSE_GOSSIP_MENU();
+                    SpellInfo const* Info = sSpellMgr->GetSpellInfo(food);
+                    Spell* foodspell = new Spell(creature, Info, TRIGGERED_NONE, player->GetGUID());
+                    SpellCastTargets targets;
+                    targets.SetUnitTarget(player);
+                    //TODO implement checkcast for bots
+                    SpellCastResult result = creature->IsMounted() || CCed(creature) ? SPELL_FAILED_CUSTOM_ERROR : foodspell->CheckPetCast(player);
+                    if (result != SPELL_CAST_OK)
+                    {
+                        foodspell->finish(false);
+                        delete foodspell;
+                        creature->MonsterWhisper("I can't do it right now", player->GetGUID());
+                        creature->SendPetCastFail(0, Info, result);
+                    }
+                    else
+                    {
+                        aftercastTargetGuid = player->GetGUID();
+                        foodspell->prepare(&targets);
+                        creature->MonsterWhisper("Here you go...", player->GetGUID());
+                    }
+                    break;
+                }
+            }
+            break;
+        default:
+            break;
+    }
+    return true;
+}
+//Summons pet for bot
+void bot_minion_ai::SummonBotsPet(uint32 entry)
+{
+    Creature* m_botsPet = me->GetBotsPet();
+    if (m_botsPet)
+        me->SetBotsPetDied();
+
+    uint8 mylevel = std::min<uint8>(master->getLevel(), 85);
+    uint32 originalentry = bot_pet_ai::GetPetOriginalEntry(entry);
+    if (!originalentry)
+    {
+        //annoy master
+        me->MonsterWhisper("Why am I trying to summon unknown pet!?", master->GetGUID());
+        return;
+    }
+    uint32 armor = 0;
+    float x(0),y(0),z(0);
+    me->GetClosePoint(x, y, z, me->GetObjectSize());
+    m_botsPet = me->SummonCreature(entry, x, y, z, 0, TEMPSUMMON_DEAD_DESPAWN);
+
+    if (!m_botsPet)
+    {
+        me->MonsterWhisper("Failed to summon pet!", master->GetGUID());
+        return;
+    }
+
+    //std::string name = sObjectMgr->GeneratePetName(originalentry);//voidwalker
+    //if (!name.empty())
+    //    m_botsPet->SetName(name);
+
+    PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_NPCBOT_PET_LEVELSTATS);
+    stmt->setUInt32(0, originalentry);
+    stmt->setUInt8(1, mylevel);
+    PreparedQueryResult result = WorldDatabase.Query(stmt);
+    //QueryResult result = WorldDatabase.PQuery("SELECT hp, mana, armor, str, agi, sta, inte, spi FROM `pet_levelstats` WHERE `creature_entry` = '%u' AND `level` = '%u'", originalentry, mylevel);
+
+    if (result)
+    {
+        Field* fields = result->Fetch();
+        uint32 hp = fields[0].GetUInt16();
+        uint32 mana = fields[1].GetUInt16();
+        armor = fields[2].GetUInt32();
+        uint32 str = fields[3].GetUInt16();
+        uint32 agi = fields[4].GetUInt16();
+        uint32 sta = fields[5].GetUInt16();
+        uint32 inte = fields[6].GetUInt16();
+        uint32 spi = fields[7].GetUInt16();
+
+        m_botsPet->SetCreateHealth(hp);
+        m_botsPet->SetMaxHealth(hp);
+        m_botsPet->SetCreateMana(mana);
+        m_botsPet->SetMaxPower(POWER_MANA, mana);
+
+        m_botsPet->SetCreateStat(STAT_STRENGTH, str);
+        m_botsPet->SetCreateStat(STAT_AGILITY, agi);
+        m_botsPet->SetCreateStat(STAT_STAMINA, sta);
+        m_botsPet->SetCreateStat(STAT_INTELLECT, inte);
+        m_botsPet->SetCreateStat(STAT_SPIRIT, spi);
+    }
+
+    m_botsPet->SetBotOwner(master);
+    m_botsPet->SetCreatureOwner(me);
+    m_botsPet->SetBotClass(bot_pet_ai::GetPetClass(m_botsPet));
+    master->SetMinion((Minion*)m_botsPet, true);
+    m_botsPet->SetUInt64Value(UNIT_FIELD_CREATEDBY, me->GetGUID());
+    m_botsPet->DeleteThreatList();
+    m_botsPet->AddUnitTypeMask(UNIT_MASK_MINION);
+    //m_botsPet->SetLevel(master->getLevel());
+    m_botsPet->AIM_Initialize();
+    m_botsPet->InitBotAI(true);
+    m_botsPet->setFaction(master->getFaction());
+    //bot_pet_ai* petai = m_botsPet->GetBotPetAI();
+    //petai->SetCreatureOwner(me);
+    //petai->SetBaseArmor(armor);
+    //petai->setStats(mylevel, bot_pet_ai::GetPetType(m_botsPet), true);
+    m_botsPet->SetBotCommandState(COMMAND_FOLLOW, true);
+
+    me->SetBotsPet(m_botsPet);
+
+    m_botsPet->SendUpdateToPlayer(master);
+}
+
+uint16 bot_ai::Rand() const
+{
+    return urand(0, 100 + (master->GetNpcBotsCount() - 1) * 10);
+}
+//Used for outside checks for druid
+uint8 bot_minion_ai::GetBotClassForCreature(Creature* bot)
+{
+    uint8 botClass = bot->GetBotClass();
+    switch (botClass)
+    {
+        case CAT: case BEAR:
+            return CLASS_DRUID;
+        default:
+            return botClass;
+    }
+}
+//Returns pet type (maybe unneeded)
+uint8 bot_pet_ai::GetPetType(Creature* pet)
+{
+    switch (pet->GetEntry())
+    {
+        case PET_VOIDWALKER:
+            return PET_TYPE_VOIDWALKER;
+    }
+    return PET_TYPE_NONE;
+}
+//Returns pet's class
+uint8 bot_pet_ai::GetPetClass(Creature* pet)
+{
+    switch (GetPetType(pet))
+    {
+        case PET_TYPE_IMP:
+            return CLASS_MAGE;
+        default:
+            return CLASS_PALADIN;
+    }
+}
+//Return entry used to summon real pets
+uint32 bot_pet_ai::GetPetOriginalEntry(uint32 entry)
+{
+    switch (entry)
+    {
+        case PET_VOIDWALKER:
+            return ORIGINAL_ENTRY_VOIDWALKER;
+        default:
+            return 0;
+    }
+}
+//PvP trinket for minions
+void bot_minion_ai::BreakCC(uint32 diff)
+{
+    if (pvpTrinket_cd <= diff && CCed(me, true) && (me->GetVictim() || !me->getAttackers().empty()))
+    {
+        temptimer = GC_Timer;
+        if (doCast(me, PVPTRINKET/*, true*/))
+        {
+            pvpTrinket_cd = PVPTRINKET_CD;
+            GC_Timer = temptimer;
+            return;
+        }
+    }
+}
+//Returns attack range based on given range
+//If mounted: 20%
+//If ranged: 125%
+//If master is dead: max range
+float bot_ai::InitAttackRange(float origRange, bool ranged) const
+{
+    if (me->IsMounted())
+        origRange *= 0.2f;
+    else
+    {
+        if (ranged)
+            origRange *= 1.25f;
+        if (master->isDead())
+            origRange += sWorld->GetMaxVisibleDistanceOnContinents();
+    }
+    return origRange;
+}
+//Force bots to start attack anyone who tries to DAMAGE me or master
+//This means that anyone who attacks party will be attacked by whole bot party (see GetTarget())
+void bot_minion_ai::OnOwnerDamagedBy(Unit* attacker)
+{
+    if (me->GetVictim())
+        return;
+    if (InDuel(attacker))
+        return;
+    bool byspell = false, ranged = false;
+    switch (GetBotClassForCreature(me))
+    {
+        case CLASS_DRUID:
+            byspell = me->GetShapeshiftForm() == FORM_NONE || 
+                me->GetShapeshiftForm() == FORM_TREE || 
+                me->GetShapeshiftForm() == FORM_MOONKIN;
+            ranged = byspell;
+            break;
+        case CLASS_PRIEST:
+        case CLASS_MAGE:
+        case CLASS_WARLOCK:
+        case CLASS_SHAMAN:
+            byspell = true;
+            ranged = true;
+            break;
+        case CLASS_HUNTER:
+            ranged = true;
+            break;
+        default:
+            break;
+    }
+    float maxdist = InitAttackRange(float(master->GetBotFollowDist()), ranged);//use increased range
+    if (!attacker->IsWithinDist(me, maxdist))
+        return;
+    if (!CanBotAttack(attacker, byspell))
+        return;
+
+    m_botCommandState = COMMAND_ABANDON;//reset AttackStart()
+    me->Attack(attacker, !ranged);
+}
diff --git a/src/server/game/AI/NpcBots/bot_ai.h b/src/server/game/AI/NpcBots/bot_ai.h
new file mode 100644
index 0000000..1900e8c
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_ai.h
@@ -0,0 +1,372 @@
+#ifndef _BOT_AI_H
+#define _BOT_AI_H
+
+#include "ScriptedCreature.h"
+
+struct PlayerClassLevelInfo
+{
+    PlayerClassLevelInfo() : basehealth(0), basemana(0) {}
+    uint32 basehealth;
+    uint32 basemana;
+};
+
+enum CommonValues
+{
+//COMMON SPELLS
+    MANAPOTION                          = 32453,//"???" forgot 0_o
+    HEALINGPOTION                       = 40535,//15504,//"Drinks Holy Elixir to heal the caster"
+    DRINK                               = 66041,//"Restores 4% mana per sec for 30 sec"
+    EAT                                 = 66478,//"Restores Health"
+    PVPTRINKET                          = 65547,//PvP Trinket
+//COMMON CDs
+    POTION_CD                           = 60000,//default 60sec potion cd
+    PVPTRINKET_CD                       = 120000,//default 2 min pvp trinket cd
+//COMMON PASSIVES
+  //1) "Increase(d) @whatever"
+    //SPELL_BONUS_10                      = 33021,//10spp
+    SPELL_BONUS_50                      = 45011,//50spp
+    SPELL_BONUS_150                     = 28141,//150spp
+    SPELL_BONUS_250                     = 69709,//250spp
+    FIREDAM_86                          = 33816,//86 fire spp
+    MANAREGEN45                         = 35867,//45 mp5
+    MANAREGEN100                        = 45216,//100 mp5
+  //2) Talents
+    HASTE /*Netherwind Presence - mage*/= 44403,//rank 3 3% spell haste
+    HASTE2   /*Serpent Swiftness - pet*/= 61683,//rank 2 10% haste
+    CRITS     /*Acuity - shaman*/       = 17487,//rank 3 3% crit
+    HOLYCRIT  /*Holy Spec (deprecated)*/= 15011,//rank 0 5% holy crit
+    DODGE   /*Bonus Dodge (deprecated)*/= 29045,//rank 0 5% dodge
+    PARRY    /*Deflection (deprecated)*/= 13854,//rank 0 6% parry
+    //PRECISION /*Precision - warrior*/   = 29592,//rank 3 3% melee hit
+    PRECISION /*Precision (passive)*/   = 19155,//rank 0 20% melee hit
+    PRECISION2/*Precision (deprecated)*/= 29440,//rank 0 3% spell hit -3% mana cost
+    DMG_TAKEN/*Deadened Nerves - rogue*/= 31383,//rank 3 (-10%)
+    HEAL_DONETAKEN/*Divinity - paladin*/= 63648,//rank 3 6% healing done 6% healing taken
+  //3) Pet/Special
+    //THREAT   /*Tank Class Passive*/     = 57339,//+43% threat
+    BOR      /*Blood of Rhino - pet*/   = 53482,//rank 2 +40% healing taken
+    //RCP      /*Rogue Class Passive*/    = 21184,//-27% threat caused
+    DEFENSIVE_STANCE_PASSIVE            = 7376, //+ 400% threat 10% damage reduction
+//COMMON GOSSIPS
+    GOSSIP_SERVE_MASTER                 = 2279  //"I live only to serve the master."
+};
+
+//TODO: slow fall / water walking for master
+//enum HoverSpells
+//{
+//    LEVITATE                            = 1706,
+//    SLOW_FALL                           = 130,
+//    //WATER_WALKING                       = 546,
+//};
+
+enum DruidStances//bot's temp set class
+{
+    BEAR        = 15,
+    CAT         = 25,
+    //TRAVEL      = 35,                   //NUY
+    //FLY         = 45,                   //NUY
+};
+
+enum BotPetTypes
+{
+    PET_TYPE_NONE,
+//Warlock
+    PET_TYPE_IMP,
+    PET_TYPE_VOIDWALKER,
+    PET_TYPE_SUCCUBUS,
+    PET_TYPE_FELHUNTER,
+    PET_TYPE_FELGUARD,
+//Mage
+    PET_TYPE_WATER_ELEMENTAL,
+//Shaman
+    //PET_TYPE_GHOSTLY_WOLF,
+    PET_TYPE_FIRE_ELEMENTAL,
+    PET_TYPE_EARTH_ELEMENTAL,
+//Hunter
+    PET_TYPE_VULTURE,
+
+    MAX_PET_TYPES
+};
+
+enum WarlockBotPets
+{
+    //PET_IMP                     = ,
+    PET_VOIDWALKER              = 70237,
+    //PET_SUCCUBUS                = 
+};
+
+enum HunterBotPets
+{
+    PET_VULTURE                 = 70238
+};
+
+enum BotPetsOriginalEntries
+{
+    ORIGINAL_ENTRY_VOIDWALKER   = 1860
+};
+
+class bot_ai : public ScriptedAI
+{
+    public:
+        virtual ~bot_ai();
+        bot_ai(Creature* creature);
+        //Player* GetMaster() const { return master; }
+        virtual bool IsMinionAI() const = 0;
+        virtual bool IsPetAI() const = 0;
+        virtual void SetBotCommandState(CommandStates /*st*/, bool /*force*/ = false, Position* /*newpos*/ = NULL) = 0;
+        virtual const bot_minion_ai* GetMinionAI() const { return NULL; }
+        virtual const bot_pet_ai* GetPetAI() const { return NULL; }
+        bool IsInBotParty(Unit* unit) const;
+        bool CanBotAttack(Unit* target, int8 byspell = 0) const;
+        bool InDuel(Unit* target) const;
+        void ApplyBotDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const;
+        void ApplyBotDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const;
+        void ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const;
+        void ApplyBotDamageMultiplierEffect(SpellInfo const* spellInfo, uint8 effect_index, float &value) const;
+        inline void SendPartyEvadeAbort() const;
+        inline void SetShouldUpdateStats() { shouldUpdateStats = true; }
+        inline void UpdateHealth() { doHealth = true; }
+        inline void UpdateMana() { doMana = true; }
+        inline void SetBotTank(Unit* newtank) { tank = newtank; m_TankGuid = newtank ? newtank->GetGUID() : 0; }
+        static Unit* GetBotGroupMainTank(Group* group) { return _GetBotGroupMainTank(group); }
+        inline float GetManaRegen() const { return regen_mp5; }
+        inline float GetHitRating() const { return hit; }
+        inline uint64 GetBotTankGuid() const { return m_TankGuid; }
+        inline int32 GetSpellPower() const { return m_spellpower; }
+        inline uint8 GetHaste() const { return haste; }
+
+        virtual void OnBotSummon(Creature* /*summon*/) {}
+        virtual void UnsummonAll() {}
+
+        void ReceiveEmote(Player* player, uint32 emote);
+        void ApplyPassives(uint8 botOrPetType) const;
+
+        static inline bool CCed(Unit* target, bool root = false)
+        {
+            return target ? target->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING | UNIT_STATE_DISTRACTED | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE) || (root && target->HasUnitState(UNIT_STATE_ROOT)) : true;
+        }
+    protected:
+        static uint32 InitSpell(Unit* caster, uint32 spell);
+
+        bool HasAuraName(Unit* unit, const std::string spell, uint64 casterGuid = 0, bool exclude = false) const;
+        bool HasAuraName(Unit* unit, uint32 spellId, uint64 casterGuid = 0, bool exclude = false) const;
+        bool RefreshAura(uint32 spell, int8 count = 1, Unit* target = NULL) const;
+        bool CheckAttackTarget(uint8 botOrPetType);
+        bool MoveBehind(Unit &target) const;
+        bool CheckImmunities(uint32 spell, Unit* target = NULL) const { return (spell && target && !target->ToCorpse() && target->IsHostileTo(me) ? !target->IsImmunedToDamage(sSpellMgr->GetSpellInfo(spell)) : true); }
+
+        //everything cast-related
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false, uint64 originalCaster = 0);
+        SpellCastResult checkBotCast(Unit* victim, uint32 spellId, uint8 botclass) const;
+        virtual void removeFeralForm(bool /*recast*/ = false) {}
+
+        inline bool Feasting() const { return (me->HasAura(EAT) || me->HasAura(DRINK)); }
+        static inline bool isMeleeClass(uint8 m_class) { return (m_class == CLASS_WARRIOR || m_class == CLASS_ROGUE || m_class == CLASS_PALADIN || m_class == CLASS_DEATH_KNIGHT || m_class == BEAR); }
+        static inline bool isTankingClass(uint8 m_class) { return (m_class == CLASS_WARRIOR || m_class == CLASS_PALADIN || m_class == CLASS_DEATH_KNIGHT || m_class == BEAR); }
+        inline bool IsChanneling(Unit* u = NULL) const { if (!u) u = me; return u->GetCurrentSpell(CURRENT_CHANNELED_SPELL); }
+        inline bool IsCasting(Unit* u = NULL) const { if (!u) u = me; return (u->HasUnitState(UNIT_STATE_CASTING) || IsChanneling(u) || u->IsNonMeleeSpellCasted(false)); }
+
+        void GetInPosition(bool force = false, bool ranged = true, Unit* newtarget = NULL, Position* pos = NULL);
+        void OnSpellHit(Unit* caster, SpellInfo const* spell);
+        void FindTank();
+        void listAuras(Player* player, Unit* unit) const;
+        void CalculateAttackPos(Unit* target, Position &pos) const;
+
+        virtual void ApplyClassDamageMultiplierMelee(uint32& /*damage*/, CalcDamageInfo& /*damageinfo*/) const {}
+        virtual void ApplyClassDamageMultiplierMelee(int32& /*damage*/, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* /*spellInfo*/, WeaponAttackType /*attackType*/, bool& /*crit*/) const {}
+        virtual void ApplyClassDamageMultiplierSpell(int32& /*damage*/, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* /*spellInfo*/, WeaponAttackType /*attackType*/, bool& /*crit*/) const {}
+        virtual void ApplyClassDamageMultiplierEffect(SpellInfo const* /*spellInfo*/, float& /*value*/) const {}
+        virtual void CureGroup(Player* /*pTarget*/, uint32 /*cureSpell*/, uint32 /*diff*/) {}
+        virtual void CheckAuras(bool /*force*/ = false) {}
+        virtual void BuffAndHealGroup(Player* /*gPlayer*/, uint32 /*diff*/) {}
+        virtual void RezGroup(uint32 /*REZZ*/, Player* /*gPlayer*/) {}
+        //virtual void DoNonCombatActions(uint32 /*diff*/) {}
+        //virtual void StartAttack(Unit* /*u*/, bool /*force*/ = false) {}
+        virtual void InitSpells() {}
+        virtual void ApplyClassPassives() {}
+        virtual void _OnHealthUpdate(uint8 /*myclass*/, uint8 /*mylevel*/) const = 0;
+        virtual void _OnManaUpdate(uint8 /*myclass*/, uint8 /*mylevel*/, bool = false) = 0;
+        //virtual void _OnMeleeDamageUpdate(uint8 /*myclass*/) const = 0;
+
+        //virtual void ReceiveEmote(Player* /*player*/, uint32 /*emote*/) {}
+        //virtual void CommonTimers(uint32 diff) = 0;
+
+        virtual bool HealTarget(Unit* /*target*/, uint8 /*pct*/, uint32 /*diff*/) { return false; }
+        virtual bool BuffTarget(Unit* /*target*/, uint32 /*diff*/) { return false; }
+        virtual bool CureTarget(Unit* /*target*/, uint32 /*cureSpell*/, uint32 /*diff*/) { return false; }
+
+        uint8 GetWait();
+        inline float InitAttackRange(float origRange, bool ranged) const;
+        uint16 Rand() const;
+        static inline uint32 GetLostHP(Unit* unit) { return unit->GetMaxHealth() - unit->GetHealth(); }
+        static inline uint8 GetHealthPCT(Unit* hTarget) { if (!hTarget || hTarget->isDead()) return 100; return (hTarget->GetHealth()*100/hTarget->GetMaxHealth()); }
+        static inline uint8 GetManaPCT(Unit* hTarget) { if (!hTarget || hTarget->isDead() || hTarget->getPowerType() != POWER_MANA) return 100; return (hTarget->GetPower(POWER_MANA)*100/(hTarget->GetMaxPower(POWER_MANA) + 1)); }
+
+        Unit* getTarget(bool byspell, bool ranged, bool &reset) const;
+
+        CommandStates GetBotCommandState() const { return m_botCommandState; }
+
+        typedef std::set<Unit*> AttackerSet;
+
+        Player* master;
+        Unit* opponent;
+        Unit* tank;
+        CommandStates m_botCommandState;
+        SpellInfo const* info;
+        Position pos, attackpos;
+        float stat, atpower, maxdist, regen_mp5, hit,
+            ap_mod, spp_mod, crit_mod;
+        uint64 aftercastTargetGuid;
+        int32 cost, value, sppower, m_spellpower;
+        uint32 GC_Timer, temptimer, checkAurasTimer, wait, currentSpell, tempMana;
+        uint8 clear_cd, haste, healTargetIconFlags;
+        bool doHealth, doMana, shouldUpdateStats;
+
+    private:
+        static Unit* _GetBotGroupMainTank(Group* group);
+        static inline float _getAttackDistance(float distance) { return distance > 0.f ? distance*0.72 : 0.f; }
+        Unit* extank;
+        float dmgmult_melee, dmgmult_spell;
+        float dmgmod_melee, dmgmod_spell;
+        uint64 m_TankGuid;
+};
+
+class bot_minion_ai : public bot_ai
+{
+    public:
+        virtual ~bot_minion_ai();
+        bot_minion_ai(Creature* creature);
+        const bot_minion_ai* GetMinionAI() const { return this; }
+        bool IsMinionAI() const { return true; }
+        bool IsPetAI() const { return false; }
+        void SummonBotsPet(uint32 entry);
+        inline bool IAmDead() const { return (!master || me->isDead()); }
+        void SetBotCommandState(CommandStates st, bool force = false, Position* newpos = NULL);
+        //virtual bool HealTarget(Unit* /*target*/, uint8 /*pct*/, uint32 const /*diff*/) { return false; }
+        //virtual bool BuffTarget(Unit* /*target*/, uint32 const /*diff*/) { return false; }
+        //virtual bool doCast(Unit*  /*victim*/, uint32 /*spellId*/, bool /*triggered*/ = false) { return false; }
+        void CureGroup(Player* pTarget, uint32 cureSpell, uint32 diff);
+        bool CureTarget(Unit* target, uint32 cureSpell, uint32 diff);
+        void CheckAuras(bool force = false);
+        //virtual void DoNonCombatActions(uint32 /*diff*/) {}
+        //virtual void StartAttack(Unit* /*u*/, bool /*force*/ = false) {}
+        void setStats(uint8 myclass, uint8 myrace, uint8 mylevel, bool force = false, bool shapeshift = false);
+
+        static bool OnGossipHello(Player* player, Creature* creature);
+        bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action);
+
+        void InitSpells() {}
+        void _OnHealthUpdate(uint8 myclass, uint8 mylevel) const;
+        void _OnManaUpdate(uint8 myclass, uint8 mylevel, bool shapeshift = false);
+        void _OnMeleeDamageUpdate(uint8 myclass) const;
+
+        void OnOwnerDamagedBy(Unit* attacker);
+
+        inline void SetEvadeTimer(uint8 time) { evade_cd = time; }
+
+        static inline uint8 GetBotClassForCreature(Creature* bot);
+
+    protected:
+        void BuffAndHealGroup(Player* gPlayer, uint32 diff);
+        void RezGroup(uint32 REZZ, Player* gPlayer);
+
+        void Follow(bool force = false, Position* newpos = NULL)
+        {
+            if (force || 
+                (me->IsAlive() && (!me->IsInCombat() || !opponent) && m_botCommandState != COMMAND_STAY))
+                SetBotCommandState(COMMAND_FOLLOW, force, newpos);
+        }
+
+        inline void Evade() { _OnEvade(); }
+
+        virtual void BreakCC(uint32 diff);
+
+        void CommonTimers(uint32 diff)
+        {
+            if (pvpTrinket_cd > diff)       pvpTrinket_cd -= diff;
+            if (Potion_cd > diff)           Potion_cd -= diff;
+            if (GC_Timer > diff)            GC_Timer -= diff;
+            if (temptimer > diff)           temptimer -= diff;
+            if (checkAurasTimer != 0)       --checkAurasTimer;
+            if (wait != 0)                  --wait;
+            if (evade_cd != 0)              --evade_cd;
+        }
+
+        Unit* FindHostileDispelTarget(float dist = 30, bool stealable = false) const;
+        Unit* FindAffectedTarget(uint32 spellId, uint64 caster = 0, float dist = DEFAULT_VISIBILITY_DISTANCE, uint8 hostile = 0) const;
+        Unit* FindPolyTarget(float dist = 30, Unit* currTarget = NULL) const;
+        Unit* FindFearTarget(float dist = 30) const;
+        Unit* FindRepentanceTarget(float dist = 20) const;
+        Unit* FindUndeadCCTarget(float dist = 30, uint32 spellId = 0) const;
+        Unit* FindRootTarget(float dist = 30, uint32 spellId = 0) const;
+        Unit* FindCastingTarget(float dist = 10, bool isFriend = false, uint32 spellId = 0) const;
+        Unit* FindAOETarget(float dist = 30, bool checkbots = false, bool targetfriend = true) const;
+        Unit* FindSplashTarget(float dist = 5, Unit* To = NULL) const;
+
+        uint32 Potion_cd, pvpTrinket_cd;
+
+    private:
+        bool CanCureTarget(Unit* target, uint32 cureSpell, uint32 diff) const;
+        void GetBotDispellableAuraList(Unit* target, Unit* caster, uint32 dispelMask, DispelChargesList& dispelList) const;
+        void CalculatePos(Position& pos);
+        void UpdateMountedState();
+        void UpdateStandState() const;
+        void UpdateRations() const;
+        void _OnEvade();
+        PlayerClassLevelInfo classinfo;
+        float myangle, armor_mod, haste_mod, dodge_mod, parry_mod;
+        uint8 rezz_cd, evade_cd;
+};
+
+class bot_pet_ai : public bot_ai
+{
+    public:
+        virtual ~bot_pet_ai();
+        bot_pet_ai(Creature* creature);
+        const bot_pet_ai* GetPetAI() const { return this; }
+        Creature* GetCreatureOwner() const { return m_creatureOwner; }
+        bool IsMinionAI() const { return false; }
+        bool IsPetAI() const { return true; }
+        inline bool IAmDead() const { return (!master || !m_creatureOwner || me->isDead()); }
+        //void SetCreatureOwner(Creature* newowner) { m_creatureOwner = newowner; }
+        void SetBotCommandState(CommandStates st, bool force = false, Position* newpos = NULL);
+        //virtual bool HealTarget(Unit* /*target*/, uint8 /*pct*/, uint32 const /*diff*/) { return false; }
+        //virtual bool BuffTarget(Unit* /*target*/, uint32 const /*diff*/) { return false; }
+        //void BuffAndHealGroup(Player* /*gPlayer*/, uint32 const /*diff*/) {}
+        //void RezGroup(uint32 /*REZZ*/, Player* /*gPlayer*/) {}
+        //virtual bool doCast(Unit*  /*victim*/, uint32 /*spellId*/, bool /*triggered*/ = false) { return false; }
+        //void CureGroup(Player* /*pTarget*/, uint32 /*cureSpell*/, uint32 const /*diff*/) {}
+        //bool CureTarget(Unit* /*target*/, uint32 /*cureSpell*/, uint32 const /*diff*/) { return false; }
+        void CheckAuras(bool force = false);
+        //virtual void DoNonCombatActions(uint32 /*diff*/) {}
+        //virtual void StartAttack(Unit* /*u*/, bool /*force*/ = false) {}
+        void setStats(uint8 mylevel, uint8 petType, bool force = false);
+
+        static uint8 GetPetType(Creature* pet);
+        static uint8 GetPetClass(Creature* pet);
+        static uint32 GetPetOriginalEntry(uint32 entry);
+
+        //debug
+        //virtual void ListSpells(ChatHandler* /*handler*/) const {}
+
+        void InitSpells() {}
+        void _OnHealthUpdate(uint8 petType, uint8 mylevel) const;
+        void _OnManaUpdate(uint8 petType, uint8 mylevel, bool shapeshift = false);
+        //void _OnMeleeDamageUpdate(uint8 /*myclass*/) const {}
+        void SetBaseArmor(uint32 armor) { basearmor = armor; }
+
+    protected:
+        void CommonTimers(uint32 diff)
+        {
+            if (GC_Timer > diff)            GC_Timer -= diff;
+            if (temptimer > diff)           temptimer -= diff;
+            if (checkAurasTimer != 0)       --checkAurasTimer;
+            if (wait != 0)                  --wait;
+        }
+
+        Creature* m_creatureOwner;
+    private:
+        uint32 basearmor;
+};
+
+#endif
diff --git a/src/server/game/AI/NpcBots/bot_druid_ai.cpp b/src/server/game/AI/NpcBots/bot_druid_ai.cpp
new file mode 100644
index 0000000..9df300e
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_druid_ai.cpp
@@ -0,0 +1,1145 @@
+#include "bot_ai.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+#include "WorldSession.h"
+/*
+Druid NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - Maybe 30%
+TODO: Feral Spells (from scratch), More Forms, Balance Spells + treants...
+*/
+class druid_bot : public CreatureScript
+{
+public:
+    druid_bot() : CreatureScript("druid_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new bot_druid_ai(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    struct bot_druid_ai : public bot_minion_ai
+    {
+        bot_druid_ai(Creature* creature) : bot_minion_ai(creature) { }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (checkBotCast(victim, spellId, CLASS_DRUID) != SPELL_CAST_OK)
+                return false;
+
+            info = sSpellMgr->GetSpellInfo(spellId);
+            if (me->GetShapeshiftForm() == FORM_NONE && swiftness && info->CalcCastTime() > 0)
+            {
+                DoCast(victim, spellId, true);
+                me->RemoveAurasDueToSpell(NATURES_SWIFTNESS, me->GetGUID(), 0, AURA_REMOVE_BY_EXPIRE);
+                me->RemoveAurasDueToSpell(CRIT_50, me->GetGUID(), 0, AURA_REMOVE_BY_EXPIRE);
+                swiftness = false;
+                return true;
+            }
+            if (spellId == BEAR_FORM || spellId == CAT_FORM)
+            {
+                if (tempMana)
+                {
+                    //remove form if any to make sure we have mana
+                    removeFeralForm(true);
+                }
+                else
+                {
+                    me->ModifyPower(POWER_MANA, -(info->CalcPowerCost(me, info->GetSchoolMask())));
+                    tempMana = me->GetPower(POWER_MANA);
+                }
+
+                if (Unit* u = me->GetVictim())
+                    GetInPosition(true, false, u);
+            }
+
+            bool result = bot_ai::doCast(victim, spellId, triggered);
+
+            if (result &&
+                //spellId != BEAR_FORM && spellId != CAT_FORM &&
+                spellId != MANAPOTION && spellId != WARSTOMP &&
+                me->HasAura(OMEN_OF_CLARITY_BUFF))
+            {
+                cost = info->CalcPowerCost(me, info->GetSchoolMask());
+                clearcast = true;
+                power = me->getPowerType();
+            }
+            return result;
+        }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit*) { removeFeralForm(false); master->SetNpcBotDied(me->GetGUID()); }
+
+        void warstomp(uint32 diff)
+        {
+            if (me->getRace() != RACE_TAUREN) return;
+            if (Warstomp_Timer > diff) return;
+
+            AttackerSet b_attackers = me->getAttackers();
+
+            if (b_attackers.empty())
+            {
+                Unit* u = me->SelectNearestTarget(6);
+                if (u && u->IsInCombat() && u->isTargetableForAttack())
+                {
+                    if (doCast(me, WARSTOMP))
+                    {
+                        Warstomp_Timer = 30000; //30sec
+                        return;
+                    }
+                }
+            }
+            for(AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+            {
+                if (!(*iter) || (*iter)->isDead()) continue;
+                if (!(*iter)->isTargetableForAttack()) continue;
+                if (me->GetDistance((*iter)) <= 6)
+                {
+                    if (doCast(me, WARSTOMP))
+                        Warstomp_Timer = 30000; //30sec
+                }
+            }
+        }
+
+        bool DamagePossible()
+        {
+            return true;
+            //return (GetManaPCT(me) < 30 || GetHealthPCT(master) < 50);
+            /*if (GetHealthPCT(master) < 75 || GetHealthPCT(me) < 75) return false;
+
+            if (Group* pGroup = master->GetGroup())
+            {
+                uint8 LHPcount = 0;
+                uint8 DIScount = 0;
+                for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* tPlayer = itr->GetSource();
+                    if (!tPlayer || tPlayer->isDead()) continue;
+                    if (me->GetExactDist(tPlayer) > 30) continue;
+                    if (tPlayer->GetHealth()*100 / tPlayer->GetMaxHealth() < 75)
+                        ++LHPcount;
+                    Unit::AuraApplicationMap const& auras = tPlayer->GetAppliedAuras();
+                    for (Unit::AuraApplicationMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+                        if (itr->second->GetBase()->GetSpellInfo()->Dispel == DISPEL_POISON)
+                            ++DIScount;
+                }
+                uint8 members = master->GetGroup()->GetMembersCount();
+
+                if (members > 10)
+                {
+                    if (LHPcount > 1 || DIScount > 2) return false;
+                }
+                if (members > 4)
+                {
+                    if (LHPcount > 0 || DIScount > 1) return false;
+                }
+                if (members < 5)
+                {
+                    if (LHPcount > 0 || DIScount > 0) return false;
+                }
+            }//endif unitlist
+
+            Unit* u = master->GetVictim();
+            if (master->getAttackers().size() > 4 || 
+              (!master->getAttackers().empty() && 
+                u != NULL && u->GetHealth() > me->GetMaxHealth()*17))
+                return false;
+
+            return true;*/
+        }
+
+        void removeFeralForm(bool recast)
+        {
+            ShapeshiftForm form = me->GetShapeshiftForm();
+            if (form != FORM_NONE)
+            {
+                switch (form)
+                {
+                case FORM_BEAR:
+                    me->RemoveAurasDueToSpell(BEAR_FORM);
+                    break;
+                case FORM_CAT:
+                    me->RemoveAurasDueToSpell(CAT_FORM);
+                    me->RemoveAurasDueToSpell(ENERGIZE);
+                    break;
+                default:
+                    break;
+                }
+                SetStats(CLASS_DRUID, recast);
+                //prevent using mana restore while jumping between forms (434)
+                Potion_cd = std::max<uint32>(Potion_cd, 1500);
+                Innervate_Timer = std::max<uint32>(Innervate_Timer, 1500);
+            }
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u); 
+            SetBotCommandState(COMMAND_ATTACK);
+            GetInPosition(force, me->GetShapeshiftForm() == FORM_NONE);
+        }
+
+        void doBearActions(uint32 diff)
+        {
+            if (me->getPowerType() != POWER_RAGE) return;
+
+            if (GetHealthPCT(me) < 75)
+                if (HealTarget(me, GetHealthPCT(me), diff))
+                    return;
+            opponent = me->GetVictim();
+            if (opponent)
+                StartAttack(opponent, true);
+            else
+                return;
+
+            //range check (melee) to prevent fake casts
+            if (me->GetDistance(opponent) > 5) return;
+
+            if (MANGLE_BEAR && MangleB_Timer <= diff && GC_Timer <= diff && rage >= 150 && Rand() < 35 &&
+                doCast(opponent, MANGLE_BEAR))
+            {
+                MangleB_Timer = 6000;
+                return;
+            }
+
+            if (SWIPE && GC_Timer <= diff && rage >= 150 && Rand() < 75 &&
+                doCast(opponent, SWIPE))
+                return;
+
+        }//end doBearActions
+
+        void doCatActions(uint32 diff)
+        {
+            if (me->getPowerType() != POWER_ENERGY) return;
+
+            if (GetHealthPCT(me) < 75)
+                if (HealTarget(me, GetHealthPCT(me), diff))
+                    return;
+            opponent = me->GetVictim();
+            if (opponent)
+                StartAttack(opponent, true);
+            else
+                return;
+            uint32 energy = me->GetPower(POWER_ENERGY);
+
+            if (MoveBehind(*opponent))
+                wait = 5;
+
+            //range check (melee) to prevent fake casts
+            if (me->GetDistance(opponent) > 5) return;
+
+            if (MANGLE_CAT && Mangle_Cat_Timer <= diff && GC_Timer <= diff && energy > 45 && Rand() < 35 &&
+                doCast(opponent, MANGLE_CAT))
+            {
+                Mangle_Cat_Timer = 6000;
+                return;
+            }
+            if (RAKE && Rake_Timer <= diff && GC_Timer <= diff && energy > 40 && Rand() < 30 &&
+                doCast(opponent, RAKE))
+            {
+                Rake_Timer = 10000;
+                return;
+            }
+            if (SHRED && Shred_Timer <= diff && GC_Timer <= diff && energy > 60 && !opponent->HasInArc(M_PI, me) && Rand() < 50 &&
+                doCast(opponent, SHRED))
+            {
+                Shred_Timer = 12000;
+                return;
+            }
+            if (RIP && Rip_Timer <= diff && GC_Timer <= diff && energy > 30 && Rand() < 30 &&
+                doCast(opponent, RIP))
+            {
+                Rip_Timer = 15000;
+                return;
+            }
+            if (CLAW && GC_Timer <= diff && energy > 45 && Rand() < 80 &&
+                doCast(opponent, CLAW))
+                return;
+        }//end doCatActions
+
+        void doBalanceActions(uint32 diff)
+        {
+            removeFeralForm(false);
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent);
+            }
+            else
+                return;
+            AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+
+            //range check to prevent fake casts
+            if (me->GetExactDist(opponent) > 30 || !DamagePossible()) return;
+
+            if (HURRICANE && Hurricane_Timer <= diff && GC_Timer <= diff && Rand() < 35)
+            {
+                Unit* target = FindAOETarget(30, true);
+                if (target && doCast(target, HURRICANE))
+                {
+                    Hurricane_Timer = 5000;
+                    return;
+                }
+                Hurricane_Timer = 2000; //fail
+            }
+            if (FAERIE_FIRE && GC_Timer <= diff &&
+                opponent->getAttackers().size() > 1 && //check if faerie fire is not useless 50/50
+                Rand() < 20)
+            {
+                Aura* ff = opponent->GetAura(FAERIE_FIRE/*, me->GetGUID()*/);
+                if (!ff || ff->GetStackAmount() < 3)
+                    if (doCast(opponent, FAERIE_FIRE))
+                        return;
+            }
+            if (MOONFIRE && Moonfire_Timer <= diff && GC_Timer <= diff && Rand() < 20 &&
+                !opponent->HasAura(MOONFIRE, me->GetGUID()))
+            {
+                if (doCast(opponent, MOONFIRE))
+                {
+                    Moonfire_Timer = 5000;
+                    return;
+                }
+            }
+            if (STARFIRE && Starfire_Timer <= diff && GC_Timer <= diff && Rand() < 50)
+            {
+                if (doCast(opponent, STARFIRE))
+                {
+                    Starfire_Timer = 11000;
+                    return;
+                }
+            }
+            if (WRATH && Wrath_Timer <= diff && GC_Timer <= diff && Rand() < 40)
+            {
+                if (doCast(opponent, WRATH))
+                {
+                    Wrath_Timer = uint32(sSpellMgr->GetSpellInfo(WRATH)->CalcCastTime()/100 * me->GetFloatValue(UNIT_MOD_CAST_SPEED) + 1);
+                    return;
+                }
+            }
+        }
+
+        bool MassGroupHeal(Player* gPlayer, uint32 diff)
+        {
+            if (!gPlayer || GC_Timer > diff) return false;
+            if (!TRANQUILITY && !WILD_GROWTH) return false;
+            if (Tranquility_Timer > diff && Wild_Growth_Timer > diff) return false;
+            if (Rand() > 30) return false;
+            if (IsCasting()) return false; // if I'm already casting
+            Group* pGroup = gPlayer->GetGroup();
+            if (!pGroup) return false;
+            uint8 LHPcount = 0;
+            uint8 pct = 100;
+            Unit* healTarget = NULL;
+            for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                Player* tPlayer = itr->GetSource();
+                if (!tPlayer || (tPlayer->isDead() && !tPlayer->HaveBot())) continue;
+                if (me->GetExactDist(tPlayer) > 39) continue;
+                if (GetHealthPCT(tPlayer) < 80)
+                {
+                    if (GetHealthPCT(tPlayer) < pct)
+                    {
+                        pct = GetHealthPCT(tPlayer);
+                        healTarget = tPlayer;
+                    }
+                    ++LHPcount;
+                    if (LHPcount > 2) break;
+                }
+                if (tPlayer->HaveBot())
+                {
+                    for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+                    {
+                        Creature* bot = tPlayer->GetBotMap(i)->_Cre();
+                        if (bot && bot->IsInWorld() && bot->GetExactDist(me) < 40 && GetHealthPCT(bot) < 80)
+                        {
+                            if (GetHealthPCT(bot) < pct)
+                            {
+                                pct = GetHealthPCT(bot);
+                                healTarget = bot;
+                            }
+                            ++LHPcount;
+                            if (LHPcount > 2) break;
+                        }
+                    }
+                }
+            }
+            if (LHPcount > 2 && TRANQUILITY && Tranquility_Timer <= diff &&
+                doCast(me, TRANQUILITY))
+                { Tranquility_Timer = 60000; return true; }
+            if (LHPcount > 0 && WILD_GROWTH && Wild_Growth_Timer <= diff &&
+                doCast(healTarget, WILD_GROWTH))
+                { Wild_Growth_Timer = 6000; return true; }
+            return false;
+        }//end MassGroupHeal
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (me->GetShapeshiftForm() == FORM_BEAR && me->getPowerType() != POWER_RAGE)
+                me->setPowerType(POWER_RAGE);
+            if (me->GetShapeshiftForm() == FORM_CAT && me->getPowerType() != POWER_ENERGY)
+                me->setPowerType(POWER_ENERGY);
+            if (me->GetShapeshiftForm() == FORM_NONE && me->getPowerType() != POWER_MANA)
+                me->setPowerType(POWER_MANA);
+            if (IAmDead()) return;
+            if (!me->GetVictim())
+                Evade();
+            else if (me->GetShapeshiftForm() == FORM_BEAR || me->GetShapeshiftForm() == FORM_CAT)
+                DoMeleeAttackIfReady();
+
+            if (me->GetShapeshiftForm() == FORM_BEAR)
+            {
+                rage = me->GetPower(POWER_RAGE);
+                if (ragetimer <= diff)
+                {
+                    if (!me->IsInCombat())
+                    {
+                        if (rage > 10.f*rageLossMult)
+                            me->SetPower(POWER_RAGE, rage - uint32(10.f*rageLossMult)); //-1 rage per 1.5 sec
+                        else
+                            me->SetPower(POWER_RAGE, 0);
+                    }
+                    ragetimer = 1500;
+                    if (rage > 1000) me->SetPower(POWER_RAGE, 1000);
+                    if (rage < 10) me->SetPower(POWER_RAGE, 0);
+                }
+            }
+            if (clearcast && me->HasAura(OMEN_OF_CLARITY_BUFF) && !me->IsNonMeleeSpellCasted(false))
+            {
+                me->ModifyPower(power, cost);
+                me->RemoveAurasDueToSpell(OMEN_OF_CLARITY_BUFF,me->GetGUID(),0,AURA_REMOVE_BY_EXPIRE);
+                clearcast = false;
+            }
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            CheckAuras();
+            BreakCC(diff);
+            if (CCed(me)) return;
+            warstomp(diff);
+
+            if (Potion_cd <= diff && me->getPowerType() == POWER_MANA && GetManaPCT(me) < 20)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, MANAPOTION))
+                    Potion_cd = POTION_CD;
+                GC_Timer = temptimer;
+            }
+
+            //Heal master
+            if (GetHealthPCT(master) < 85)
+                HealTarget(master, GetHealthPCT(master), diff);
+            //Innervate
+            doInnervate(diff);
+
+            MassGroupHeal(master, diff);
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+            else
+                CheckBattleRez(diff);
+            BuffAndHealGroup(master, diff);
+            CureTarget(master, REMOVE_CORRUPTION, diff);
+            CureGroup(master, REMOVE_CORRUPTION, diff);
+
+            if (!CheckAttackTarget(CLASS_DRUID))
+                return;
+
+            //debug
+            opponent = me->GetVictim();
+
+            if (GetHealthPCT(me) < 75)
+            {
+                HealTarget(me, GetHealthPCT(me), diff);
+                return;
+            }
+
+            if (IsCasting()) return; //Casting heal or something
+            CheckRoots(diff);
+
+            if (DamagePossible() && opponent != NULL)
+            {
+                Unit* u = opponent->GetVictim();
+                //if the target is attacking us, we want to go bear
+                if (BEAR_FORM && !CCed(opponent) &&
+                    (u == me || (tank == me && IsInBotParty(u))) ||
+                    (!me->getAttackers().empty() && (*me->getAttackers().begin()) == opponent && opponent->GetMaxHealth() > me->GetMaxHealth()*2))
+                {
+                    //if we don't have bear yet
+                    if (me->GetShapeshiftForm() != FORM_BEAR && formtimer <= diff &&
+                        doCast(me, BEAR_FORM))
+                    {
+                        SetStats(BEAR);
+                        formtimer = 1500;
+                    }
+                    if (me->GetShapeshiftForm() == FORM_BEAR)
+                        doBearActions(diff);
+                }
+                else
+                if (CAT_FORM && master->GetVictim() != opponent && tank && u == tank && u != me &&
+                    opponent->GetMaxHealth() < tank->GetMaxHealth()*3)
+                {
+                    //if we don't have cat yet
+                    if (me->GetShapeshiftForm() != FORM_CAT && formtimer <= diff)
+                    {
+                        if (doCast(me, CAT_FORM))
+                        {
+                            SetStats(CAT);
+                            formtimer = 1500;
+                        }
+                    }
+                    if (me->GetShapeshiftForm() == FORM_CAT)
+                        doCatActions(diff);
+                }
+                else if (tank != me)
+                    doBalanceActions(diff);
+            }
+            else if (tank != me)
+                doBalanceActions(diff);
+        }
+
+        bool HealTarget(Unit* target, uint8 hp, uint32 diff)
+        {
+            if (hp > 95) return false;
+            if (!target || target->isDead()) return false;
+            if (tank == me && hp > 35) return false;
+            if (hp > 50 && me->GetShapeshiftForm() != FORM_NONE) return false;//do not waste heal if in feral or so
+            if (Rand() > 50 + 20*target->IsInCombat() + 50*master->GetMap()->IsRaid() - 50*me->GetShapeshiftForm()) return false;
+            if (me->GetExactDist(target) > 40) return false;
+
+            //TODO: Narture swiftness 434
+            if ((hp < 15 || (hp < 35 && target->getAttackers().size() > 2)) &&
+                Nature_Swiftness_Timer <= diff && (target->IsInCombat() || !target->getAttackers().empty()))
+            {
+                if (me->IsNonMeleeSpellCasted(false))
+                    me->InterruptNonMeleeSpells(false);
+                if (NATURES_SWIFTNESS && doCast(me, NATURES_SWIFTNESS) && RefreshAura(CRIT_50, 2))
+                {
+                    swiftness = true;
+                    if (doCast(target, HEALING_TOUCH, true))
+                    {
+                        Nature_Swiftness_Timer = 120000; //2 min
+                        Heal_Timer = 3000;
+                        return true;
+                    }
+                }
+            }
+            if (SWIFTMEND && (hp < 25 || GetLostHP(target) > 5000) && Swiftmend_Timer <= 3000 &&
+                (HasAuraName(target, REGROWTH) || HasAuraName(target, REJUVENATION)))
+            {
+                if (doCast(target, SWIFTMEND))
+                {
+                    Swiftmend_Timer = 10000;
+                    if (GetHealthPCT(target) > 75)
+                        return true;
+                    else if (!target->getAttackers().empty())
+                    {
+                        if (doCast(target, REGROWTH))
+                        {
+                            GC_Timer = 300;
+                            return true;
+                        }
+                    }
+                }
+            }
+            if (hp > 35 && (hp < 75 || GetLostHP(target) > 3000) && Heal_Timer <= diff && NOURISH)
+            {
+                switch (urand(1,3))
+                {
+                    case 1:
+                    case 2:
+                        if (doCast(target, NOURISH))
+                        {
+                            Heal_Timer = 3000;
+                            return true;
+                        }
+                        break;
+                    case 3:
+                        if (doCast(target, HEALING_TOUCH))
+                        {
+                            Heal_Timer = 3000;
+                            return true;
+                        }
+                        break;
+                }
+            }
+            //maintain HoTs
+            Unit* u = target->GetVictim();
+            Creature* boss = u && u->ToCreature() && u->ToCreature()->isWorldBoss() ? u->ToCreature() : NULL;
+            bool tanking = tank == target && boss;
+            if (( (hp < 80 || GetLostHP(target) > 3500 || tanking) &&
+                Regrowth_Timer <= diff && GC_Timer <= diff && !target->HasAura(REGROWTH, me->GetGUID()) )
+                ||
+                (target->HasAura(REGROWTH, me->GetGUID()) && target->HasAura(REJUVENATION, me->GetGUID()) &&
+                (hp < 70 || GetLostHP(target) > 3000) && Regrowth_Timer <= diff && GC_Timer <= diff))
+            {
+                if (doCast(target, REGROWTH))
+                { Regrowth_Timer = 2000; return true; }
+            }
+            if (hp > 25 && (hp < 90 || GetLostHP(target) > 2000 || tanking) && GC_Timer <= diff &&
+                !HasAuraName(target, REJUVENATION, me->GetGUID()))
+            {
+                if (doCast(target, REJUVENATION))
+                {
+                    if (!target->getAttackers().empty() && (hp < 75 || GetLostHP(target) > 4000))
+                        if (SWIFTMEND && Swiftmend_Timer <= diff && doCast(target, SWIFTMEND))
+                            Swiftmend_Timer = 10000;
+                    GC_Timer = 500;
+                    return true;
+                }
+            }
+            if (LIFEBLOOM != 0 && GC_Timer <= diff &&
+                ((hp < 85 && hp > 40) || (hp > 70 && tanking) ||
+                (hp < 70 && hp > 25 && HasAuraName(target, REGROWTH) && HasAuraName(target, REJUVENATION)) ||
+                (GetLostHP(target) > 1500 && hp > 35)))
+            {
+                Aura* bloom = target->GetAura(LIFEBLOOM, me->GetGUID());
+                if ((!bloom || bloom->GetStackAmount() < 3) && doCast(target, LIFEBLOOM))
+                    return true;
+            }
+            if (hp > 30 && (hp < 70 || GetLostHP(target) > 3000) && Heal_Timer <= diff &&
+                doCast(target, HEALING_TOUCH))
+            {
+                Heal_Timer = 3000;
+                return true;
+            }
+            return false;
+        }
+
+        bool BuffTarget(Unit* target, uint32 diff)
+        {
+            if (GC_Timer > diff || Rand() > 30) return false;
+
+            if (target && target->IsAlive() && me->GetExactDist(target) < 30)
+            {
+                if (Thorns_Timer <= diff && me->GetShapeshiftForm() == FORM_NONE &&
+                    !target->getAttackers().empty() && !HasAuraName(target, THORNS))
+                {
+                    if (doCast(target, THORNS))
+                    {
+                        Thorns_Timer = target->ToCreature() ? 10000 : 45000;
+                        return true;
+                    }
+                    //fail
+                    Thorns_Timer = 2500;
+                }
+                if (!me->IsInCombat() || master->GetMap()->IsRaid())
+                    if (!HasAuraName(target, MARK_OF_THE_WILD))
+                        if (doCast(target, MARK_OF_THE_WILD))
+                            return true;
+            }
+            return false;
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || me->IsMounted()) return;
+
+            RezGroup(REVIVE, master);
+
+            //if eating or drinking don't do anything but rez
+            if (Feasting()) return;
+
+            if (BuffTarget(master, diff))
+            {
+                /*GC_Timer = 800;*/
+                return;
+            }
+            if (BuffTarget(me, diff))
+            {
+                /*GC_Timer = 800;*/
+                return;
+            }
+        }
+
+        void doInnervate(uint32 diff, uint8 minmanaval = 50)
+        {
+            if (!INNERVATE || Innervate_Timer > diff || GC_Timer > diff || Rand() > 15) return;
+            if (me->GetShapeshiftForm() != FORM_NONE && (tank == me || me->getAttackers().size() > 3)) return;
+
+            Unit* iTarget = NULL;
+
+            if (master->IsInCombat() && master->getPowerType() == POWER_MANA &&
+                GetManaPCT(master) < 20 && !master->HasAura(INNERVATE))
+                iTarget = master;
+            else if (me->IsInCombat() && me->getPowerType() == POWER_MANA &&
+                GetManaPCT(me) < 20 && !me->HasAura(INNERVATE))
+                iTarget = me;
+
+            Group* group = master->GetGroup();
+            if (!iTarget && !group) //first check master's bots
+            {
+                for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
+                {
+                    Creature* bot = master->GetBotMap(i)->_Cre();
+                    if (!bot || !bot->IsInCombat() || bot->isDead()) continue;
+                    if (me->GetExactDist(bot) > 30) continue;
+                    if (bot->getPowerType() != POWER_MANA) continue;
+                    if (GetManaPCT(bot) < minmanaval && !bot->HasAura(INNERVATE))
+                    {
+                        iTarget = bot;
+                        break;
+                    }
+                }
+            }
+            if (!iTarget && group) //cycle through player members...
+            {
+                for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* tPlayer = itr->GetSource();
+                    if (tPlayer == NULL || !tPlayer->IsInWorld() || !tPlayer->IsInCombat() || tPlayer->isDead()) continue;
+                    if (me->GetExactDist(tPlayer) > 30) continue;
+                    if (tPlayer->getPowerType() != POWER_MANA) continue;
+                    if (GetManaPCT(tPlayer) < minmanaval && !tPlayer->HasAura(INNERVATE))
+                    {
+                        iTarget = tPlayer;
+                        break;
+                    }
+                    if (iTarget)
+                        break;
+                }
+            }
+            if (!iTarget && group) //... and their bots.
+            {
+                for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* tPlayer = itr->GetSource();
+                    if (tPlayer == NULL || !tPlayer->HaveBot()) continue;
+                    for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+                    {
+                        Creature* bot = tPlayer->GetBotMap(i)->_Cre();
+                        if (!bot || bot->isDead()) continue;
+                        if (me->GetExactDist(bot) > 30) continue;
+                        if (bot->getPowerType() != POWER_MANA) continue;
+                        if (GetManaPCT(bot) < minmanaval && !bot->HasAura(INNERVATE))
+                        {
+                            iTarget = bot;
+                            break;
+                        }
+                    }
+                    if (iTarget)
+                        break;
+                }
+            }
+
+            //fail
+            if (!iTarget)
+            {
+                Innervate_Timer = 3000;
+                return;
+            }
+
+            if (doCast(iTarget, INNERVATE))
+            {
+                if (iTarget->GetTypeId() == TYPEID_PLAYER)
+                    me->MonsterWhisper("Innervate on You!", iTarget->GetGUID());
+                else
+                {
+                    std::ostringstream msg;
+                    msg << "Innervate on " << (iTarget == me ? "myself" : iTarget->GetName()) << '!';
+                    me->MonsterWhisper(msg.str().c_str(), master->GetGUID());
+                }
+
+                Innervate_Timer = iTarget->GetTypeId() == TYPEID_PLAYER ? 60000 : 20000; //1 min if player and 20 sec if bot
+            }
+        }
+
+        void CheckRoots(uint32 diff)
+        {
+            if (!ENTANGLING_ROOTS || GC_Timer > diff || Rand() > 35) return;
+            if (me->GetShapeshiftForm() != FORM_NONE) return;
+            if (FindAffectedTarget(ENTANGLING_ROOTS, me->GetGUID(), 60)) return;
+            if (Unit* target = FindRootTarget(33, ENTANGLING_ROOTS))
+                if (doCast(target, ENTANGLING_ROOTS))
+                    return;
+        }
+
+        void CheckBattleRez(uint32 diff)
+        {
+            if (!REBIRTH || Rebirth_Timer > diff || Rand() > 10 || IsCasting() || me->IsMounted()) return;
+            Group* gr = master->GetGroup();
+            if (!gr)
+            {
+                Unit* target = master;
+                if (master->IsAlive()) return;
+                if (master->IsRessurectRequested()) return; //ressurected
+                if (master->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+                    target = (Unit*)master->GetCorpse();
+                if (!target || !target->IsInWorld())
+                    return;
+                if (me->GetExactDist(target) > 40)
+                {
+                    me->GetMotionMaster()->MovePoint(master->GetMapId(), *target);
+                    Rebirth_Timer = 1500;
+                    return;
+                }
+                else if (!target->IsWithinLOSInMap(me))
+                    me->Relocate(*target);
+
+                if (doCast(target, REBIRTH)) //rezzing
+                {
+                    me->MonsterWhisper("Rezzing You", master->GetGUID());
+                    Rebirth_Timer = me->getLevel() >= 60 ? 300000 : 600000; //5-10 min (improved possible)
+                }
+                return;
+            }
+            for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                Player* tPlayer = itr->GetSource();
+                Unit* target = tPlayer;
+                if (!tPlayer || tPlayer->IsAlive()) continue;
+                if (tPlayer->IsRessurectRequested()) continue; //ressurected
+                if (tPlayer->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+                    target = (Unit*)tPlayer->GetCorpse();
+                if (!target || !target->IsInWorld()) continue;
+                if (master->GetMap() != target->FindMap()) continue;
+                if (me->GetExactDist(target) > 30)
+                {
+                    me->GetMotionMaster()->MovePoint(target->GetMapId(), *target);
+                    Rebirth_Timer = 1500;
+                    return;
+                }
+                else if (!target->IsWithinLOSInMap(me))
+                    me->Relocate(*target);
+
+                if (doCast(target, REBIRTH)) //rezzing
+                {
+                    me->MonsterWhisper("Rezzing You", tPlayer->GetGUID());
+                    Rebirth_Timer = me->getLevel() >= 60 ? 300000 : 600000; //5-10 min (improved possible)
+                    return;
+                }
+            }
+        }
+
+        void SetStats(uint8 form, bool reshapeshift = false)
+        {
+            switch (form)
+            {
+                case BEAR:
+                    me->SetBotClass(BEAR);
+                    me->setPowerType(POWER_RAGE);
+                    me->SetMaxPower(POWER_RAGE, 1000);
+                    //me->SetPower(POWER_RAGE, me->getLevel() >= 11 ? 200 : 0);
+                    if (me->getLevel() >= 40 && !me->HasAura(LEADER_OF_THE_PACK_BUFF))
+                        RefreshAura(LEADER_OF_THE_PACK_BUFF);
+                    setStats(BEAR, me->getRace(), master->getLevel());
+                    break;
+                case CAT:
+                    me->SetBotClass(CAT);
+                    me->setPowerType(POWER_ENERGY);
+                    me->SetMaxPower(POWER_ENERGY, 100);
+                    //me->SetPower(POWER_ENERGY, me->getLevel() >= 11 ? 100 : 0);
+                    if (me->getLevel() >= 40 && !me->HasAura(LEADER_OF_THE_PACK_BUFF))
+                        RefreshAura(LEADER_OF_THE_PACK_BUFF);
+                    RefreshAura(ENERGIZE, me->getLevel()/41 + 1);
+                    setStats(CAT, me->getRace(), master->getLevel());
+                    break;
+                case CLASS_DRUID:
+                    me->SetBotClass(CLASS_DRUID);
+                    me->setPowerType(POWER_MANA);
+                    setStats(CLASS_DRUID, me->getRace(), master->getLevel(), false, reshapeshift);
+                    //me->SetPower(POWER_MANA, init ? mana : 0);
+                    //tempMana = 0;
+                    break;
+            }
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            Heal_Timer = 0;
+            Regrowth_Timer = 0;
+            Swiftmend_Timer = 0;
+            Wild_Growth_Timer = 0;
+            Tranquility_Timer = 10000;
+            Nature_Swiftness_Timer = 15000;
+            Rebirth_Timer = 10000;
+            Warstomp_Timer = 0;
+            MangleB_Timer = 0;
+            Claw_Timer = 0;
+            Rake_Timer = 0;
+            Shred_Timer = 0;
+            Rip_Timer = 0;
+            Mangle_Cat_Timer = 0;
+            Moonfire_Timer = 0;
+            Starfire_Timer = 0;
+            Wrath_Timer = 0;
+            Hurricane_Timer = 0;
+            Innervate_Timer = 0;
+            Thorns_Timer = 0;
+            formtimer = 0;
+            clearcast = false;
+            swiftness = false;
+            power = POWER_MANA;
+            //mana = 0;
+            rage = 0;
+            rageIncomeMult = sWorld->getRate(RATE_POWER_RAGE_INCOME);
+            rageLossMult = sWorld->getRate(RATE_POWER_RAGE_LOSS);
+            ragetimer = 0;
+
+            if (master)
+            {
+                setStats(CLASS_DRUID, me->getRace(), master->getLevel(), true);
+                ApplyClassPassives();
+                ApplyPassives(CLASS_DRUID);
+            }
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            CommonTimers(diff);
+            if (MangleB_Timer > diff)               MangleB_Timer -= diff;
+            if (Claw_Timer > diff)                  Claw_Timer -= diff;
+            if (Rake_Timer > diff)                  Rake_Timer -= diff;
+            if (Shred_Timer > diff)                 Shred_Timer -= diff;
+            if (Mangle_Cat_Timer > diff)            Mangle_Cat_Timer -= diff;
+            if (Moonfire_Timer > diff)              Moonfire_Timer -= diff;
+            if (Starfire_Timer > diff)              Starfire_Timer -= diff;
+            if (Wrath_Timer > diff)                 Wrath_Timer -= diff;
+            if (Hurricane_Timer > diff)             Hurricane_Timer -= diff;
+            if (Innervate_Timer > diff)             Innervate_Timer -= diff;
+            if (Rip_Timer > diff)                   Rip_Timer -= diff;
+            if (Regrowth_Timer > diff)              Regrowth_Timer -= diff;
+            if (Heal_Timer > diff)                  Heal_Timer -= diff;
+            if (Swiftmend_Timer > diff)             Swiftmend_Timer -= diff;
+            if (Wild_Growth_Timer > diff)           Wild_Growth_Timer -= diff;
+            if (Nature_Swiftness_Timer > diff)      Nature_Swiftness_Timer -= diff;
+            if (Tranquility_Timer > diff)           Tranquility_Timer -= diff;
+            if (Rebirth_Timer > diff)               Rebirth_Timer -= diff;
+            if (Thorns_Timer > diff)                Thorns_Timer -= diff;
+            if (Warstomp_Timer > diff)              Warstomp_Timer -= diff;
+            if (formtimer > diff)                   formtimer -= diff;
+            if (ragetimer > diff)                   ragetimer -= diff;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            MARK_OF_THE_WILD                        = InitSpell(me, MARK_OF_THE_WILD_1);
+            THORNS                                  = InitSpell(me, THORNS_1);
+            HEALING_TOUCH                           = InitSpell(me, HEALING_TOUCH_1);
+            REGROWTH                                = InitSpell(me, REGROWTH_1);
+            REJUVENATION                            = InitSpell(me, REJUVENATION_1);
+            LIFEBLOOM                               = InitSpell(me, LIFEBLOOM_1);
+            NOURISH                                 = InitSpell(me, NOURISH_1);
+     /*tal*/WILD_GROWTH                 = lvl >= 49 ? InitSpell(me, WILD_GROWTH_1) : 0;
+            SWIFTMEND                   = lvl >= 11 ? InitSpell(me, SWIFTMEND_1) : 0;
+            TRANQUILITY                             = InitSpell(me, TRANQUILITY_1);
+            REVIVE                                  = InitSpell(me, REVIVE_1);
+            REBIRTH                                 = InitSpell(me, REBIRTH_1);
+            BEAR_FORM                               = InitSpell(me, BEAR_FORM_1);
+            SWIPE                                   = InitSpell(me, SWIPE_1);
+            MANGLE_BEAR                 = lvl >= 10 ? InitSpell(me, MANGLE_BEAR_1) : 0;
+            //BASH                                    = InitSpell(me, BASH_1);
+            CAT_FORM                                = InitSpell(me, CAT_FORM_1);
+            CLAW                                    = InitSpell(me, CLAW_1);
+            RAKE                                    = InitSpell(me, RAKE_1);
+            SHRED                                   = InitSpell(me, SHRED_1);
+            RIP                                     = InitSpell(me, RIP_1);
+            MANGLE_CAT                  = lvl >= 10 ? InitSpell(me, MANGLE_CAT_1) : 0;
+            MOONFIRE                                = InitSpell(me, MOONFIRE_1);
+            STARFIRE                                = InitSpell(me, STARFIRE_1);
+            WRATH                                   = InitSpell(me, WRATH_1);
+            HURRICANE                               = InitSpell(me, HURRICANE_1);
+            FAERIE_FIRE                             = InitSpell(me, FAERIE_FIRE_1);
+            REMOVE_CORRUPTION                       = InitSpell(me, REMOVE_CORRUPTION_1);
+            INNERVATE                               = InitSpell(me, INNERVATE_1);
+            ENTANGLING_ROOTS                        = InitSpell(me, ENTANGLING_ROOTS_1);
+     /*tal*/NATURES_SWIFTNESS           = lvl >= 29 ? InitSpell(me, NATURES_SWIFTNESS_1) : 0;
+            WARSTOMP                                = WARSTOMP_1;
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+            if (level >= 82)
+                RefreshAura(SPELLDMG2, 5); //+10%
+            else if (level >= 75)
+                RefreshAura(SPELLDMG2, 4); //+8%
+            else if (level >= 67)
+                RefreshAura(SPELLDMG2, 3); //+6%
+            else if (level >= 58)
+                RefreshAura(SPELLDMG2, 2); //+4%
+            else if (level >= 49)
+                RefreshAura(SPELLDMG2); //+2%
+            if (level >= 82)
+                RefreshAura(SPELLDMG, 5); //+15%
+            else if (level >= 75)
+                RefreshAura(SPELLDMG, 4); //+12%
+            else if (level >= 67)
+                RefreshAura(SPELLDMG, 3); //+9%
+            else if (level >= 58)
+                RefreshAura(SPELLDMG, 2); //+6%
+            else if (level >= 49)
+                RefreshAura(SPELLDMG); //+3%
+            if (level >= 45)
+                RefreshAura(NATURE_WARD2); //50%
+            else if (level >= 43)
+                RefreshAura(NATURE_WARD1); //100%
+            if (level >= 50)
+                RefreshAura(LIVING_SEED3); //100%
+            else if (level >= 48)
+                RefreshAura(LIVING_SEED2); //66%
+            else if (level >= 46)
+                RefreshAura(LIVING_SEED1); //33%
+            if (level >= 53)
+                RefreshAura(REVITALIZE2, 2/*3*/); //20% (2%)x3
+            else if (level >= 51)
+                RefreshAura(REVITALIZE1, 2/*3*/); //20%  (1%)x3
+            if (level >= 70)
+                RefreshAura(OMEN_OF_CLARITY, 3); //x3
+            else if (level >= 40)
+                RefreshAura(OMEN_OF_CLARITY, 2); //x2
+            else if (level >= 20)
+                RefreshAura(OMEN_OF_CLARITY); //x1
+            if (level >= 45)
+                RefreshAura(GLYPH_SWIFTMEND); //no comsumption
+            if (level >= 40)
+                RefreshAura(GLYPH_INNERVATE); //no comsumption
+            if (level >= 20)
+                RefreshAura(NATURESGRACE);
+            if (level >= 12)
+                RefreshAura(FUROR);
+            if (level >= 78)
+            {
+                RefreshAura(T9_RESTO_P4_BONUS);
+                RefreshAura(T8_RESTO_P4_BONUS);
+                RefreshAura(T9_BALANCE_P2_BONUS);
+                RefreshAura(T10_BALANCE_P2_BONUS);
+                RefreshAura(T10_BALANCE_P4_BONUS);
+            }
+        }
+
+    private:
+        uint32
+   /*Buffs*/MARK_OF_THE_WILD, THORNS, 
+/*Heal/Rez*/HEALING_TOUCH, REGROWTH, REJUVENATION, LIFEBLOOM, NOURISH, WILD_GROWTH, SWIFTMEND, TRANQUILITY, REVIVE, REBIRTH, 
+    /*Bear*/BEAR_FORM, SWIPE, MANGLE_BEAR,// BASH, 
+     /*Cat*/CAT_FORM, CLAW, RAKE, SHRED, RIP, MANGLE_CAT, 
+ /*Balance*/MOONFIRE, STARFIRE, WRATH, HURRICANE, FAERIE_FIRE, 
+    /*Misc*/REMOVE_CORRUPTION, INNERVATE, ENTANGLING_ROOTS, NATURES_SWIFTNESS, WARSTOMP;
+        //Timers/other
+/*Heal*/uint32 Heal_Timer, Regrowth_Timer, Swiftmend_Timer, Wild_Growth_Timer,
+/*Heal*/    Tranquility_Timer, Nature_Swiftness_Timer, Rebirth_Timer, Thorns_Timer;
+/*Bear*/uint32 MangleB_Timer;
+/*Cat*/ uint32 Claw_Timer, Rake_Timer, Shred_Timer, Rip_Timer, Mangle_Cat_Timer;
+/*Bal*/ uint32 Moonfire_Timer, Starfire_Timer, Wrath_Timer, Hurricane_Timer, Innervate_Timer;
+/*Misc*/uint32 formtimer, ragetimer, Warstomp_Timer;
+/*Chck*/bool clearcast, swiftness;
+/*Misc*/Powers power;
+/*Misc*/uint32 /*mana, */rage;
+/*Misc*/float rageIncomeMult, rageLossMult;
+
+        enum DruidBaseSpells
+        {
+            MARK_OF_THE_WILD_1                  = 1126,
+            THORNS_1                            = 467,
+            HEALING_TOUCH_1                     = 5185,
+            REGROWTH_1                          = 8936,
+            REJUVENATION_1                      = 774,
+            LIFEBLOOM_1                         = 33763,
+            NOURISH_1                           = 50464,
+     /*tal*/WILD_GROWTH_1                       = 48438,
+            SWIFTMEND_1                         = 18562,
+            TRANQUILITY_1                       = 740,
+            REVIVE_1                            = 50769,
+            REBIRTH_1                           = 20484,
+            BEAR_FORM_1                         = 5487,
+            SWIPE_1                             = 779,
+            MANGLE_BEAR_1                       = 33878,
+            //BASH_1                              = 5211,
+            CAT_FORM_1                          = 768,
+            CLAW_1                              = 1082,
+            RAKE_1                              = 1822,
+            SHRED_1                             = 5221,
+            RIP_1                               = 1079,
+            MANGLE_CAT_1                        = 33876,
+            MOONFIRE_1                          = 8921,
+            STARFIRE_1                          = 2912,
+            WRATH_1                             = 5176,
+            HURRICANE_1                         = 16914,
+            FAERIE_FIRE_1                       = 770,
+            REMOVE_CORRUPTION_1                 = 2782,
+            INNERVATE_1                         = 29166,
+            ENTANGLING_ROOTS_1                  = 339,
+     /*tal*/NATURES_SWIFTNESS_1                 = 17116,
+            WARSTOMP_1                          = 20549
+        };
+        enum DruidPassives
+        {
+        //Talents
+            OMEN_OF_CLARITY                     = 16864,//clearcast
+            NATURESGRACE                        = 61346,//haste 20% for 3 sec
+            NATURE_WARD1                        = 33881,
+            NATURE_WARD2                        = 33882,
+            LIVING_SEED1                        = 48496,//rank 1
+            LIVING_SEED2                        = 48499,//rank 2
+            LIVING_SEED3                        = 48500,//rank 3
+            REVITALIZE1                         = 48539,//rank 1
+            REVITALIZE2                         = 48544,//rank 2
+            FUROR                               = 17059,//rank 3
+        //Glyphs
+            GLYPH_SWIFTMEND                     = 54824,//no consumption
+            GLYPH_INNERVATE                     = 54832,//self regen
+        //other
+            T9_RESTO_P4_BONUS                   = 67128,//rejuve crits
+            T8_RESTO_P4_BONUS                   = 64760,//rejuve init heal 
+            T9_BALANCE_P2_BONUS                 = 67125,//moonfire crits
+            T10_BALANCE_P2_BONUS                = 70718,//omen of doom (15%)
+            T10_BALANCE_P4_BONUS                = 70723,//Languish(DOT)
+            SPELLDMG/*Piercing Ice - mage*/     = 15060,//3% crit
+            SPELLDMG2/*Earth and Moon - druid*/ = 48511,//2% dam
+            ENERGIZE                            = 27787,//Rogue Armor Energize (chance: +35 energy on hit)
+            CRIT_50                             = 23434 //50% spell crit
+        };
+        enum DruidSpecial
+        {
+  /*Talent*/LEADER_OF_THE_PACK_BUFF             = 24932,
+            //NATURESGRACEBUFF                    = 16886,
+            OMEN_OF_CLARITY_BUFF                = 16870 //434 deprecated
+        };
+    };
+};
+
+void AddSC_druid_bot()
+{
+    new druid_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_hunter_ai.cpp b/src/server/game/AI/NpcBots/bot_hunter_ai.cpp
new file mode 100644
index 0000000..435df78
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_hunter_ai.cpp
@@ -0,0 +1,340 @@
+#include "bot_ai.h"
+//#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+//#include "SpellAuras.h"
+/*
+Hunter NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - 1%
+TODO:
+*/
+class hunter_bot : public CreatureScript
+{
+public:
+    hunter_bot() : CreatureScript("hunter_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new hunter_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    struct hunter_botAI : public bot_minion_ai
+    {
+        hunter_botAI(Creature* creature) : bot_minion_ai(creature)
+        {
+            Reset();
+        }
+
+        //void CreatePet()
+        //{
+
+        //    pet = me->GetBotsPet(60238);
+
+        //    if (pet == NULL)
+        //        return;
+
+        //    pet->UpdateCharmAI();
+        //    pet->setFaction(me->getFaction());
+        //    pet->SetReactState(REACT_DEFENSIVE);
+        //    pet->GetMotionMaster()->MoveFollow(me, PET_FOLLOW_DIST*urand(1, 2),PET_FOLLOW_ANGLE);
+        //    CharmInfo* charmInfonewbot = pet->InitCharmInfo();
+        //    pet->GetCharmInfo()->SetCommandState(COMMAND_FOLLOW);
+        //    pet->UpdateStats(STAT_STRENGTH);
+        //    pet->UpdateStats(STAT_AGILITY);
+        //    pet->SetLevel(master->getLevel());
+
+        //    /*float val2 = master->getLevel()*4.f + pet->GetStat(STAT_STRENGTH)*5.f;
+
+        //    val2=100.0;
+        //    uint32 attPowerMultiplier=1;
+        //    pet->SetModifierValue(UNIT_MOD_ATTACK_POWER, BASE_VALUE, uint32(val2));
+        //    pet->UpdateAttackPowerAndDamage();
+        //    pet->SetBaseWeaponDamage(BASE_ATTACK, MINDAMAGE, uint32(val2 * attPowerMultiplier));
+        //    pet->SetBaseWeaponDamage(BASE_ATTACK, MAXDAMAGE, uint32(val2 * attPowerMultiplier)*3+master->getLevel());
+        //    pet->UpdateDamagePhysical(BASE_ATTACK);*/
+
+        //}
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (checkBotCast(victim, spellId, CLASS_HUNTER) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit*) { master->SetNpcBotDied(me->GetGUID()); }
+        void DoNonCombatActions(uint32 const /*diff*/)
+        {}
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+
+            if (IAmDead()) return;
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            //if (pet && pet != NULL && pet->isDead())
+            //{
+            //    me->SetBotsPetDied();
+            //    pet = NULL;
+            //}
+
+            //if we think we have a pet, but master doesn't, it means we teleported
+            //if (pet && !me->getBotsPet())
+            //{
+            //    me->SetBotsPetDied();
+            //    pet = NULL;
+            //}
+
+            DoNormalAttack(diff);
+            ScriptedAI::UpdateAI(diff);
+
+            //if low on health, drink a potion
+            if (GetHealthPCT(me) < 65)
+            {
+                if (doCast(me, HEALINGPOTION))
+                    Potion_cd = POTION_CD;
+            }
+
+            //if low on mana, drink a potion
+            if (GetManaPCT(me) < 65 && Potion_cd <= diff)
+            {
+                if (doCast(me, MANAPOTION))
+                    Potion_cd = POTION_CD;
+            }
+
+            opponent = SelectTarget(SELECT_TARGET_TOPAGGRO, 0);
+            if (!opponent && !me->GetVictim())
+            {
+                me->CombatStop();
+                //ResetOrGetNextTarget();
+
+                //to reduce the number of crashes, remove pet whenever we are not in combat
+                //if (pet != NULL && pet->IsAlive())
+                //{
+                //    me->SetBotsPetDied();
+                //    pet = NULL;
+                //}
+                return;
+            }
+
+            //if (pet == NULL)
+            //    CreatePet();
+
+            //if (pet && pet->IsAlive() &&
+            //    !pet->IsInCombat() &&
+            //    me->GetVictim())
+            //{
+            //    pet->Attack (me->GetVictim(), true);
+            //    pet->GetMotionMaster()->MoveChase(me->GetVictim(), 1, 0);
+            //}
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            AttackerSet m_attackers = master->getAttackers();
+            if (!opponent || opponent->isDead()) return;
+
+            // try to get rid of enrage effect
+            if (TRANQ_SHOT && (HasAuraName(opponent, "Enrage") || (HasAuraName(opponent, "Frenzy")))) 
+            {
+                me->InterruptNonMeleeSpells(true, AUTO_SHOT);
+                me->MonsterSay("Tranquil shot!", LANG_UNIVERSAL, opponent->GetGUID());
+                doCast(opponent, TRANQ_SHOT, true);
+              //  doCast(opponent, AUTO_SHOT);
+              //  return;
+            }
+
+            // silence it
+            if (SILENCING_SHOT && opponent->HasUnitState(UNIT_STATE_CASTING) && SilencingShot_Timer <= diff)
+            {
+                doCast(opponent, SILENCING_SHOT);
+                SilencingShot_Timer = 25000;
+              //  doCast(opponent, AUTO_SHOT);
+              //  return;
+            }
+
+            // mark it
+            if (!HasAuraName(opponent, "Hunter's Mark"))
+            {
+                doCast(opponent, HUNTERS_MARK);
+              //  doCast(opponent, AUTO_SHOT);
+              //  return;
+            }
+
+            // sting it
+            if (SCORPID_STING && !opponent->HasAura(SCORPID_STING, me->GetGUID())) 
+            {
+                me->InterruptNonMeleeSpells(true, AUTO_SHOT);
+                doCast(opponent, SCORPID_STING);
+               // me->MonsterSay("Scorpid Sting!", LANG_UNIVERSAL, NULL);
+               // doCast(opponent, AUTO_SHOT);
+               // return;
+            }
+
+             if (CHIMERA_SHOT && ChimeraShot_Timer <= diff && GC_Timer <= diff)
+             {
+                me->InterruptNonMeleeSpells(true, AUTO_SHOT);
+                doCast(opponent, CHIMERA_SHOT);
+                ChimeraShot_Timer = 10000;
+               // me->MonsterSay("Chimera Sting!", LANG_UNIVERSAL, NULL);
+              //  doCast(opponent, AUTO_SHOT);
+              //  return;
+            }
+
+            if (ARCANE_SHOT && ArcaneShot_cd <= diff && GC_Timer <= diff)
+            {
+                me->InterruptNonMeleeSpells(true, AUTO_SHOT);
+                doCast(opponent, ARCANE_SHOT);
+               // me->MonsterSay("Arcane shot!", LANG_UNIVERSAL, NULL);
+                ArcaneShot_cd = 60;
+              //  doCast(opponent, AUTO_SHOT);
+              //  return;
+            }
+
+            if (AIMED_SHOT && AimedShot_Timer <= diff && GC_Timer <= diff)
+            {
+                me->InterruptNonMeleeSpells( true, AUTO_SHOT );
+                doCast(opponent, AIMED_SHOT);
+               // me->MonsterSay("Aimed shot!", LANG_UNIVERSAL, NULL);
+                AimedShot_Timer = 120;
+              //  doCast(opponent, AUTO_SHOT);
+              //  return;
+            }
+            //Temp Feign death For Debug
+            AttackerSet b_attackers = me->getAttackers();
+            if (!b_attackers.empty())
+            {
+            for(AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                if (*iter && (*iter)->GetVictim()->GetGUID() == me->GetGUID() && 
+                    me->GetDistance(*iter) < 10 && 
+                    Feign_Death_Timer <= diff && GC_Timer <= diff)
+                {
+                    doCast(me, FEIGN_DEATH, true);
+                    opponent->AddThreat(me, -100000);
+                    me->CombatStop();
+                    Feign_Death_Timer = 25000;
+                    me->CombatStart(opponent);
+                }
+            }
+
+            doCast(opponent, AUTO_SHOT);
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            ArcaneShot_cd = 0;
+            ChimeraShot_Timer = 0;
+            SilencingShot_Timer = 0;
+            AimedShot_Timer = 0;
+            Feign_Death_Timer = 0;
+
+            if (master)
+            {
+                setStats(CLASS_HUNTER, me->getRace(), master->getLevel(), true);
+                ApplyClassPassives();
+                ApplyPassives(CLASS_HUNTER);
+             }
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            CommonTimers(diff);
+            if (ArcaneShot_cd > diff)               ArcaneShot_cd -= diff;
+            if (ChimeraShot_Timer > diff)           ChimeraShot_Timer -= diff;
+            if (SilencingShot_Timer > diff)         SilencingShot_Timer -= diff;
+            if (AimedShot_Timer > diff)             AimedShot_Timer -= diff;
+            if (Feign_Death_Timer > diff)           Feign_Death_Timer -= diff;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            AUTO_SHOT                               = AUTO_SHOT_1;
+            TRANQ_SHOT                              = InitSpell(me, TRANQ_SHOT_1);
+            SCORPID_STING                           = InitSpell(me, SCORPID_STING_1);
+            HUNTERS_MARK                            = InitSpell(me, HUNTERS_MARK_1);
+            ARCANE_SHOT                             = InitSpell(me, ARCANE_SHOT_1);
+            CHIMERA_SHOT                = lvl >= 60 ? CHIMERA_SHOT_1 : 0;
+            AIMED_SHOT                  = lvl >= 20 ? InitSpell(me, AIMED_SHOT_1) : 0;
+            SILENCING_SHOT              = lvl >= 50 ? SILENCING_SHOT_1 : 0;
+            ASPECT_OF_THE_DRAGONHAWK                = InitSpell(me, ASPECT_OF_THE_DRAGONHAWK_1);
+            FEIGN_DEATH                             = InitSpell(me, FEIGN_DEATH_1);
+        }
+
+        void ApplyClassPassives()
+        { }
+
+    private:
+        uint32
+        AUTO_SHOT, TRANQ_SHOT, SCORPID_STING, HUNTERS_MARK, ARCANE_SHOT, CHIMERA_SHOT, AIMED_SHOT, 
+        SILENCING_SHOT, ASPECT_OF_THE_DRAGONHAWK, FEIGN_DEATH;
+        //Timers
+        uint32 ArcaneShot_cd, ChimeraShot_Timer, SilencingShot_Timer, AimedShot_Timer, Feign_Death_Timer;
+
+        enum HunterBaseSpells
+        {
+            AUTO_SHOT_1                         = 75,
+            TRANQ_SHOT_1                        = 19801,
+            SCORPID_STING_1                     = 3043,
+            HUNTERS_MARK_1                      = 14325,
+            ARCANE_SHOT_1                       = 3044,
+            CHIMERA_SHOT_1                      = 53209,
+            AIMED_SHOT_1                        = 19434,
+            SILENCING_SHOT_1                    = 34490,
+            ASPECT_OF_THE_DRAGONHAWK_1          = 61846,
+            FEIGN_DEATH_1                       = 5384,
+        };
+
+        enum HunterPassives
+        {
+        };
+
+        enum HunterSpecial
+        {
+        };
+    };
+};
+
+void AddSC_hunter_bot()
+{
+    new hunter_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_mage_ai.cpp b/src/server/game/AI/NpcBots/bot_mage_ai.cpp
new file mode 100644
index 0000000..325f7ec
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_mage_ai.cpp
@@ -0,0 +1,935 @@
+#include "bot_ai.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+#include "WorldSession.h"
+/*
+Mage NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - Around 45%
+TODO: Ice Lance, Deep Freeze, Mana Gems, Pet etc...
+*/
+class mage_bot : public CreatureScript
+{
+public:
+    mage_bot() : CreatureScript("mage_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new mage_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    struct mage_botAI : public bot_minion_ai
+    {
+        mage_botAI(Creature* creature) : bot_minion_ai(creature) { }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (checkBotCast(victim, spellId, CLASS_MAGE) != SPELL_CAST_OK)
+                return false;
+            bool result = bot_ai::doCast(victim, spellId, triggered);
+
+            if (result && spellId != MANAPOTION && me->HasAura(CLEARCASTBUFF))
+            {
+                cost = info->CalcPowerCost(me, info->GetSchoolMask());
+                clearcast = true;
+            }
+
+            return result;
+        }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit*) { master->SetNpcBotDied(me->GetGUID()); }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            GetInPosition(force, true);
+        }
+
+        void Counter()
+        {
+            Unit* u = me->GetVictim();
+            bool cSpell = CounterSpell_cd <= 5000;
+            bool blast = FireBlast_cd <= 3000 && !(u && u->ToCreature() && (u->ToCreature()->isWorldBoss() || u->ToCreature()->IsDungeonBoss())) && me->HasAura(IMPACT_BUFF);
+            if (!cSpell && !blast) return;
+            if (u && u->IsNonMeleeSpellCasted(false))
+            {
+                temptimer = GC_Timer;
+                if (me->IsNonMeleeSpellCasted(false))
+                    me->InterruptNonMeleeSpells(false);
+                if (cSpell && doCast(u, COUNTERSPELL))
+                    CounterSpell_cd = 15000;
+                else if (blast && doCast(u, FIREBLAST))
+                    FireBlast_cd = 6000;
+                GC_Timer = temptimer;
+            }
+            else if (cSpell)
+            {
+                if (Unit* target = FindCastingTarget(30))
+                {
+                    temptimer = GC_Timer;
+                    if (me->IsNonMeleeSpellCasted(false))
+                        me->InterruptNonMeleeSpells(false);
+                    if (doCast(target, COUNTERSPELL))
+                    {
+                        CounterSpell_cd = 15000;
+                        GC_Timer = temptimer;
+                    }
+                }
+            }
+        }
+
+        void CheckSpellSteal(uint32 diff)
+        {
+            if (!SPELLSTEAL || Rand() > 25 || GC_Timer > diff || IsCasting()) return;
+            Unit* target = FindHostileDispelTarget(30, true);
+            if (target && doCast(target, SPELLSTEAL))
+                GC_Timer = 800;
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || me->IsMounted()) return;
+            if (Feasting()) return;
+
+            if (!HasAuraName(me, DAMPENMAGIC) && 
+                doCast(me, DAMPENMAGIC))
+            { /*GC_Timer = 800;*/ return; }
+
+            if (!HasAuraName(me, ICEARMOR) && 
+                doCast(me, ICEARMOR))
+            { /*GC_Timer = 800;*/ return; }
+        }
+
+        bool BuffTarget(Unit* target, uint32 diff)
+        {
+            if (GC_Timer > diff || !target || target->isDead() || Rand() > 50) return false;
+            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
+            if (me->GetExactDist(target) > 30) return false;
+            if (target->getPowerType() == POWER_MANA && 
+                !HasAuraName(target, ARCANEINTELLECT) && 
+                doCast(target, ARCANEINTELLECT))
+            {
+                /*GC_Timer = 800;*/
+                return true;
+            }
+            return false;
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (IAmDead()) return;
+            if (!me->GetVictim())
+                Evade();
+            if (clearcast && me->HasAura(CLEARCASTBUFF) && !me->IsNonMeleeSpellCasted(false))
+            {
+                me->ModifyPower(POWER_MANA, cost);
+                me->RemoveAurasDueToSpell(CLEARCASTBUFF,me->GetGUID(),0,AURA_REMOVE_BY_EXPIRE);
+                if (me->HasAura(ARCANE_POTENCY_BUFF1))
+                    me->RemoveAurasDueToSpell(ARCANE_POTENCY_BUFF1,me->GetGUID(),0,AURA_REMOVE_BY_EXPIRE);
+                if (me->HasAura(ARCANE_POTENCY_BUFF2))
+                    me->RemoveAurasDueToSpell(ARCANE_POTENCY_BUFF2,me->GetGUID(),0,AURA_REMOVE_BY_EXPIRE);
+                clearcast = false;
+            }
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            CheckAuras();
+            BreakCC(diff);
+            if (CCed(me) && (!ICEBLOCK || !me->HasAura(ICEBLOCK))) return;//TODO
+
+            CheckBlink(diff);
+            CheckPoly(diff);
+            CheckPots(diff);
+            CureTarget(master, REMOVE_CURSE, diff);
+            CureTarget(me, REMOVE_CURSE, diff);
+            CureGroup(master, REMOVE_CURSE, diff);
+
+            FocusMagic(diff);
+            BuffAndHealGroup(master, diff);
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+            
+            if (!CheckAttackTarget(CLASS_MAGE))
+                return;
+
+            CheckPoly2();//this should go AFTER getting opponent
+
+            Counter();
+            CheckSpellSteal(diff);
+            DoNormalAttack(diff);
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent);
+            }
+            else
+                return;
+            AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+
+            Unit* u = me->SelectNearestTarget(20);
+            //ICE_BARRIER
+            if (ICE_BARRIER && Ice_Barrier_cd <= diff && u && u->GetVictim() == me && 
+                u->GetDistance(me) < 8 && !me->HasAura(ICE_BARRIER))
+            {
+                if (me->IsNonMeleeSpellCasted(true))
+                    me->InterruptNonMeleeSpells(true);
+                if (doCast(me, ICE_BARRIER))
+                {
+                    Ice_Barrier_cd = 41000 - me->getLevel()*200;//down to 25 sec on 80
+                    GC_Timer = 800;
+                    return;
+                }
+            }
+            if ((!ICE_BARRIER || Ice_Barrier_cd > diff) && 
+                BLINK && Blink_cd < 3000 && u && u->GetVictim() == me && 
+                !me->HasAura(ICE_BARRIER) && u->GetDistance(me) < 6)
+            {
+                if (me->IsNonMeleeSpellCasted(true))
+                    me->InterruptNonMeleeSpells(true);
+                if (doCast(me, BLINK))
+                {
+                    Blink_cd = 15000 - me->getLevel()/4 * 100;
+                    GC_Timer = 800;
+                    return;
+                }
+            }
+
+            if (me->HasAura(ICEBLOCK))
+                if (((GetManaPCT(me) > 45 && GetHealthPCT(me) > 80) || b_attackers.empty()) && Iceblock_cd <= 57000 && tank)
+                    me->RemoveAurasDueToSpell(ICEBLOCK);
+            //ICEBLOCK
+            if (ICEBLOCK && Rand() < 50 && !b_attackers.empty() && tank && Iceblock_cd <= diff && 
+                (GetManaPCT(me) < 15 || GetHealthPCT(me) < 45 || b_attackers.size() > 4) && 
+                !me->HasAura(ICEBLOCK))
+            {
+                if (me->IsNonMeleeSpellCasted(true))
+                    me->InterruptNonMeleeSpells(true);
+                if (doCast(me, ICEBLOCK))
+                {
+                    Iceblock_cd = 60000;
+                    return;
+                }
+            }
+
+            if (IsCasting()) return;
+
+            BOLT = (CCed(opponent, true) || (opponent->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISARMED) && me->HasAura(COMBUSTION))) ? FIREBALL : FROSTBOLT;
+            NOVA = BOLT == FIREBALL && BLASTWAVE ? BLASTWAVE : FROSTNOVA ? FROSTNOVA : 0;
+
+            float dist = me->GetExactDist(opponent);
+            if (dist > 30)
+                return;
+
+            if (COMBUSTION && Rand() < 15 && 
+                (opponent->GetMaxHealth() > master->GetMaxHealth()*10 || 
+                m_attackers.size() > 1 || b_attackers.size() > 2))
+            {
+                if (!HasAuraName(me, "Combustion") && Combustion_cd <= diff)
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(me, COMBUSTION))
+                    {
+                        Combustion_cd = 60000;
+                        //Reset timers for fun
+                        Nova_cd = 0; FireBlast_cd = 0; DragonBreath_cd = 0;
+                    }
+                    GC_Timer = temptimer;
+                }
+            }
+            //DAMAGE
+            //PYROBLAST
+            if (PYROBLAST && Rand() < 75 && Pyroblast_cd <= diff && GC_Timer <= diff && 
+                b_attackers.size() < 2 && dist < 30 && opponent->IsPolymorphed() && 
+                doCast(opponent, PYROBLAST))
+                Pyroblast_cd = 50;
+            //nova //TODO: SEPARATE
+            u = me->SelectNearestTarget(7);
+            if (u && NOVA && Nova_cd <= diff && !CCed(u, true) && IsInBotParty(u->GetVictim()))
+            {
+                Unit* tar = u->GetVictim();
+                if (tar && IsInBotParty(tar) && doCast(me, NOVA))
+                {
+                    Nova_cd = 15000;
+                    return;
+                }
+            }
+            //living bomb
+            if (LIVINGBOMB && Rand() < 25 && Living_Bomb_cd <= diff && GC_Timer <= diff && 
+                dist < 30 && opponent->GetHealth() > me->GetHealth()/2 && 
+                !opponent->HasAura(LIVINGBOMB, me->GetGUID()) && 
+                doCast(opponent, LIVINGBOMB))
+            {
+                Living_Bomb_cd = 6000;
+                GC_Timer = 500;
+                return;
+            }
+            //cone of cold
+            if (CONEOFCOLD && ConeofCold_cd <= diff && GC_Timer <= diff && dist < 7 && 
+                me->HasInArc(M_PI, opponent) && 
+                doCast(opponent, CONEOFCOLD))
+            {
+                ConeofCold_cd = 14000;
+                GC_Timer = 500;
+                return;
+            }
+            //dragon's breath
+            u = me->SelectNearestTarget(7);
+            if (DRAGONBREATH && u && DragonBreath_cd <= diff && GC_Timer <= diff && 
+                me->HasInArc(M_PI, opponent) && !HasAuraName(u, FROSTNOVA) && 
+                doCast(opponent, DRAGONBREATH))
+            {
+                DragonBreath_cd = 25000;
+                GC_Timer = 800;
+                return;
+            }
+            /*//blast wave //TODO Separate again
+            u = me->SelectNearestTarget(8);
+            if (BLASTWAVE != 0 && u && isTimerReady(BlastWave_cd) && 
+                !HasAuraName(u, FROSTNOVA) && !HasAuraName(u, DRAGONBREATH) && 
+                doCast(me, BLASTWAVE))
+            {
+                BlastWave_cd = BLASTWAVE_CD;
+                GC_Timer = 800;
+            }*/
+            //fire blast
+            if (FireBlast_cd <= diff && GC_Timer <= diff && dist < 20 && 
+                Rand() < 20 + 80*(!opponent->HasAuraType(SPELL_AURA_MOD_STUN) && me->HasAura(IMPACT_BUFF)) && 
+                doCast(opponent, FIREBLAST))
+            {
+                FireBlast_cd = 6000;
+                GC_Timer = 500;
+                return;
+            }
+            //flamestrike
+            if (GC_Timer <= diff && Rand() < 60 && me->HasAura(FIRESTARTERBUFF))
+            {
+                Unit* FStarget = FindAOETarget(30, true, false);
+                if (FStarget && doCast(FStarget, FLAMESTRIKE, true))
+                {
+                    me->RemoveAurasDueToSpell(FIRESTARTERBUFF);
+                    GC_Timer = 0;
+                    return;
+                }
+            }
+            //blizzard
+            if (BLIZZARD && Rand() < 80 && Blizzard_cd <= diff)
+            {
+                Unit* blizztarget = FindAOETarget(30, true);
+                if (blizztarget && doCast(blizztarget, BLIZZARD))
+                {
+                    Blizzard_cd = 5000;
+                    return;
+                }
+                Blizzard_cd = 2000;//fail
+            }
+            //Frost of Fire Bolt
+            if (Rand() < 75 && Bolt_cd <= diff && dist < 30 && 
+                doCast(opponent, BOLT))
+            {
+                Bolt_cd = uint32(float(sSpellMgr->GetSpellInfo(BOLT)->CalcCastTime()/100) * me->GetFloatValue(UNIT_MOD_CAST_SPEED) + 200);
+                return;
+            }
+            //Arcane Missiles
+            if (Rand() < 10 && GC_Timer <= diff && !me->isMoving() && dist < 20 && 
+                doCast(opponent, ARCANEMISSILES))
+                return;
+        }
+
+        void CheckPoly(uint32 diff)
+        {
+            if (polyCheckTimer <= diff)
+            {
+                Polymorph = FindAffectedTarget(POLYMORPH, me->GetGUID());
+                polyCheckTimer = 2000;
+            }
+        }
+
+        void CheckPoly2()
+        {
+            if (Polymorph == false && GC_Timer < 500)
+            {
+                if (Unit* target = FindPolyTarget(30, me->GetVictim()))
+                {
+                    if (doCast(target, POLYMORPH))
+                    {
+                        Polymorph = true;
+                        polyCheckTimer = 2000;
+                    }
+                }
+            }
+        }
+
+        void CheckPots(uint32 diff)
+        {
+            if (GetHealthPCT(me) < 70 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, HEALINGPOTION))
+                    Potion_cd = POTION_CD;
+                GC_Timer = temptimer;
+            }
+            if (GetManaPCT(me) < 35)
+            {
+                if (Evocation_cd <= diff && !me->isMoving() && me->getAttackers().empty() && doCast(me, EVOCATION))
+                    Evocation_cd = 60000;
+                else if (Potion_cd <= diff)
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(me, MANAPOTION))
+                        Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+        }
+
+        void CheckBlink(uint32 diff)
+        {
+            if (GetBotCommandState() == COMMAND_STAY || me->IsMounted()) return;
+            if (Blink_cd > diff || me->getLevel() < 20 || IsCasting()) return;
+            if (me->GetExactDist(master) > std::max(float(master->GetBotFollowDist()), 25.f)/* && me->IsWithinLOSInMap(master)*/)
+            {
+                me->SetFacingTo(me->GetAngle(master));
+                if (doCast(me, BLINK))
+                {
+                    Blink_cd = 15000 - me->getLevel()/4 * 100; //13 sec with improved
+                    GC_Timer = 500;
+                }
+                return;
+            }
+            if (!me->getAttackers().empty() && me->GetExactDist(master) > 15)
+            {
+                if (Unit* op = me->SelectNearestTarget(10))
+                {
+                    if (op->GetVictim() == me)
+                    {
+                        me->SetFacingTo(me->GetAngle(master));
+                        if (doCast(me, BLINK))
+                        {
+                            Blink_cd = 15000 - me->getLevel()/4 * 100; //13 sec with improved
+                            GC_Timer = 500;
+                        }
+                    }
+                }
+            }
+        }
+
+        void FocusMagic(uint32 diff)
+        {
+            if (!FOCUSMAGIC || me->getLevel() < 20 || fmCheckTimer > diff || GC_Timer > diff || Rand() < 50 || IsCasting())
+                return;
+            if (Unit* target = FindAffectedTarget(FOCUSMAGIC, me->GetGUID(), 70, 2))
+            {
+                fmCheckTimer = 30000;
+                return;
+            }
+            else
+            {
+                Group* pGroup = master->GetGroup();
+                if (!pGroup)
+                {
+                    if (master->getPowerType() == POWER_MANA && !master->HasAura(FOCUSMAGIC) && me->GetExactDist(master) < 30)
+                    target = master;
+                }
+                else
+                {
+                    for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        Player* pPlayer = itr->GetSource();
+                        if (!pPlayer || pPlayer->isDead()) continue;
+                        if (me->GetMapId() != pPlayer->GetMapId()) continue;
+                        if ((pPlayer->getClass() == CLASS_MAGE || 
+                            pPlayer->getClass() == CLASS_PRIEST || 
+                            pPlayer->getClass() == CLASS_SHAMAN || 
+                            pPlayer->getClass() == CLASS_DRUID || 
+                            pPlayer->getClass() == CLASS_PALADIN || 
+                            pPlayer->getClass() == CLASS_WARLOCK) && 
+                            !pPlayer->HasAura(FOCUSMAGIC) && me->GetExactDist(pPlayer) < 30)
+                        {
+                            target = pPlayer;
+                            break;
+                        }
+                    }
+                    if (!target)
+                    {
+                        for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                        {
+                            Player* pPlayer = itr->GetSource();
+                            if (!pPlayer || !pPlayer->HaveBot()) continue;
+                            if (me->GetMapId() != pPlayer->GetMapId()) continue;
+                            for (uint8 i = 0; i != pPlayer->GetMaxNpcBots(); ++i)
+                            {
+                                Creature* cre = pPlayer->GetBotMap(i)->_Cre();
+                                if (!cre || cre == me || cre->isDead() || cre->getPowerType() != POWER_MANA) continue;
+                                if ((cre->GetBotClass() == CLASS_MAGE || 
+                                    cre->GetBotClass() == CLASS_PRIEST || 
+                                    cre->GetBotClass() == CLASS_SHAMAN || 
+                                    cre->GetBotClass() == CLASS_DRUID || 
+                                    cre->GetBotClass() == CLASS_WARLOCK) && 
+                                    !cre->HasAura(FOCUSMAGIC) && me->GetExactDist(cre) < 30)
+                                {
+                                    target = cre;
+                                    break;
+                                }
+                            }
+                        }
+                    }
+                }
+                if (target && doCast(target, FOCUSMAGIC))
+                {
+                    GC_Timer = 500;
+                    fmCheckTimer = 30000;
+                    return;
+                }
+            }
+            fmCheckTimer = 5000;
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //Combustion: 10% per stack
+                if (SPELL_SCHOOL_MASK_FIRE & spellInfo->GetSchoolMask())
+                    if (Aura* combustion = me->GetAura(COMBUSTION_BUFF))
+                        aftercrit += float(combustion->GetStackAmount()*10);
+                //Incineration: 6% additional critical chance for Fire Blast, Scorch, Arcane Blast and Cone of Cold
+                if (lvl >= 10 &&
+                    (spellId == FIREBLAST ||
+                    spellId == CONEOFCOLD/* ||
+                    spellId == ARCANEBLAST ||
+                    spellId == SCORCH*/))
+                    aftercrit += 6.f;
+                //World In Flames: 6% additional critical chance for
+                //Flamestrike, Pyroblast, Blast Wave, Dragon's Breath, Living Bomb, Blizzard and Arcane Explosion
+                if (lvl >= 15 &&
+                    (spellId == FLAMESTRIKE ||
+                    spellId == PYROBLAST ||
+                    spellId == BLASTWAVE ||
+                    spellId == DRAGONBREATH/* ||
+                    spellId == ARCANEXPLOSION ||
+                    spellId == LIVINGBOMB ||    //cannot be handled here
+                    spellId == BLIZZARD*/))    //cannot be handled here
+                    aftercrit += 6.f;
+
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!spell damage is not yet critical and will be multiplied by 1.5
+                //so we should put here bonus damage mult /1.5
+                //Spell Power: 50% additional crit damage bonus for All spells
+                if (lvl >= 55)
+                    pctbonus += 0.333f;
+                //Ice Shards: 50% additional crit damage bonus for Frost spells
+                else if (lvl >= 15 && (SPELL_SCHOOL_MASK_FROST & spellInfo->GetSchoolMask()))
+                    pctbonus += 0.333f;
+            }
+            //Improved Cone of Cold: 35% bonus damage for Cone of Cold
+            if (lvl >= 30 && spellId == CONEOFCOLD)
+                pctbonus += 0.35f;
+            //Fire Power: 10% bonus damage for Fire spells
+            if (lvl >= 35 && (SPELL_SCHOOL_MASK_FIRE & spellInfo->GetSchoolMask()))
+                pctbonus += 0.1f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(Unit* /*target*/, SpellInfo const* spell)
+        {
+            if (aftercastTargetGuid != 0)
+            {
+                //only players for now
+                if (!IS_PLAYER_GUID(aftercastTargetGuid))
+                {
+                    aftercastTargetGuid = 0;
+                    return;
+                }
+                Player* pTarget = sObjectAccessor->FindPlayer(aftercastTargetGuid);
+                aftercastTargetGuid = 0;
+                if (!pTarget/* || me->GetDistance(pTarget) > 15*/)
+                    return;
+
+                //handle effects
+                for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+                {
+                    switch (spell->Effects[i].Effect)
+                    {
+                        case SPELL_EFFECT_CREATE_ITEM:
+                        case SPELL_EFFECT_CREATE_ITEM_2:
+                        {
+                            uint32 newitemid = spell->Effects[i].ItemType;
+                            if (newitemid)
+                            {
+                                ItemPosCountVec dest;
+                                ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(newitemid);
+                                if (!pProto)
+                                    return;
+                                uint32 count = pProto->GetMaxStackSize();
+                                uint32 no_space = 0;
+                                InventoryResult msg = pTarget->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, newitemid, count, &no_space);
+                                if (msg != EQUIP_ERR_OK)
+                                {
+                                    if (msg == EQUIP_ERR_INV_FULL || msg == EQUIP_ERR_ITEM_MAX_COUNT)
+                                        count -= no_space;
+                                    else
+                                    {
+                                        // if not created by another reason from full inventory or unique items amount limitation
+                                        pTarget->SendEquipError(msg, NULL, NULL, newitemid);
+                                        continue;
+                                    }
+                                }
+                                if (count)
+                                {
+                                    Item* pItem = pTarget->StoreNewItem(dest, newitemid, true, Item::GenerateItemRandomPropertyId(newitemid));
+                                    if (!pItem)
+                                    {
+                                        pTarget->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL);
+                                        continue;
+                                    }
+                                    //unsafe possible
+                                    pItem->SetUInt32Value(ITEM_FIELD_CREATOR, me->GetGUIDLow());
+
+                                    pTarget->SendNewItem(pItem, count, true, false, true);
+                                }
+                            }
+                            break;
+                        }
+                        default:
+                            break;
+                    }
+                }
+            }
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            Pyroblast_cd = 0;
+            FireBlast_cd = 0;
+            DragonBreath_cd = 0;
+            Combustion_cd = 30000;//30 sec for reset
+            Ice_Barrier_cd = 0;
+            Iceblock_cd = 0;
+            ConeofCold_cd = 0;
+            Blizzard_cd = 10000;
+            CounterSpell_cd = 0;
+            Evocation_cd = 0;
+            Blink_cd = 0;
+            Bolt_cd = 0;
+            Nova_cd = 0;
+            polyCheckTimer = 0;
+            fmCheckTimer = 0;
+            Polymorph = false;
+            clearcast = false;
+            BOLT = FROSTBOLT;//default frost
+            NOVA = BLASTWAVE != 0 ? BLASTWAVE : FROSTNOVA;
+
+            if (master)
+            {
+                setStats(CLASS_MAGE, me->getRace(), master->getLevel(), true);
+                ApplyClassPassives();
+                ApplyPassives(CLASS_MAGE);
+           }
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            CommonTimers(diff);
+            if (Pyroblast_cd > diff)            Pyroblast_cd -= diff;
+            if (Ice_Barrier_cd > diff)          Ice_Barrier_cd -= diff;
+            if (Iceblock_cd > diff)             Iceblock_cd -= diff;
+            if (ConeofCold_cd > diff)           ConeofCold_cd -= diff;
+            if (Living_Bomb_cd > diff)          Living_Bomb_cd -= diff;
+            if (FireBlast_cd > diff)            FireBlast_cd -= diff;
+            if (Bolt_cd > diff)                 Bolt_cd -= diff;
+            if (Blizzard_cd > diff)             Blizzard_cd -= diff;
+            if (CounterSpell_cd > diff)         CounterSpell_cd -= diff;
+            if (Nova_cd > diff)                 Nova_cd -= diff;
+            if (DragonBreath_cd > diff)         DragonBreath_cd -= diff;
+            if (Blink_cd > diff)                Blink_cd -= diff;
+            if (Combustion_cd > diff)           Combustion_cd -= diff;
+            if (Evocation_cd > diff)            Evocation_cd -= diff;
+            if (polyCheckTimer > diff)          polyCheckTimer -= diff;
+            if (fmCheckTimer > diff)            fmCheckTimer -= diff;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            DAMPENMAGIC                             = InitSpell(me, DAMPENMAGIC_1);
+            ARCANEINTELLECT                         = InitSpell(me, ARCANEINTELLECT_1);
+            ARCANEMISSILES                          = InitSpell(me, ARCANEMISSILES_1); 
+            POLYMORPH                               = InitSpell(me, POLYMORPH_1);
+            COUNTERSPELL                            = InitSpell(me, COUNTERSPELL_1);
+            SPELLSTEAL                              = InitSpell(me, SPELLSTEAL_1);
+            EVOCATION                               = InitSpell(me, EVOCATION_1);
+            BLINK                                   = InitSpell(me, BLINK_1);
+            REMOVE_CURSE                            = InitSpell(me, REMOVE_CURSE_1);
+            //INVISIBILITY                            = InitSpell(me, INVISIBILITY_1);
+            FIREBALL                                = InitSpell(me, FIREBALL_1);
+            BLASTWAVE                   = lvl >= 30 ? InitSpell(me, BLASTWAVE_1) : 0;
+            DRAGONBREATH                = lvl >= 40 ? InitSpell(me, DRAGONBREATH_1) : 0;
+            FIREBLAST                               = InitSpell(me, FIREBLAST_1);
+            PYROBLAST                   = lvl >= 20 ? InitSpell(me, PYROBLAST_1) : 0;
+            LIVINGBOMB                  = lvl >= 60 ? InitSpell(me, LIVINGBOMB_1) : 0;
+            FLAMESTRIKE                             = InitSpell(me, DAMPENMAGIC_1);
+            COMBUSTION                  = lvl >= 50 ? COMBUSTION_1 : 0;
+            FROSTBOLT                               = InitSpell(me, FROSTBOLT_1);
+            FROSTNOVA                               = InitSpell(me, FROSTNOVA_1);
+            CONEOFCOLD                              = InitSpell(me, CONEOFCOLD_1);
+            BLIZZARD                                = InitSpell(me, BLIZZARD_1);
+            ICEARMOR                    = lvl >= 20 ? InitSpell(me, ICEARMOR_1) : InitSpell(me, FROSTARMOR_1);
+            ICE_BARRIER                 = lvl >= 40 ? InitSpell(me, ICE_BARRIER_1) : 0;
+            ICEBLOCK                                = InitSpell(me, ICEBLOCK_1);
+            FOCUSMAGIC                  = lvl >= 20 ? FOCUSMAGIC_1 : 0;
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+            //Dam+(-Hit)
+            if (level >= 50)
+                RefreshAura(ARCTIC_WINDS,3); //+15%/-15%
+            else if (level >= 25)
+                RefreshAura(ARCTIC_WINDS,2); //+10%/-10%
+            else if (level >= 10)
+                RefreshAura(ARCTIC_WINDS); //+5%/-5%
+            //CHILL
+            if (level >= 30)
+                RefreshAura(WINTERS_CHILL3); //100%
+            else if (level >= 25)
+                RefreshAura(WINTERS_CHILL2); //66%
+            else if (level >= 20)
+                RefreshAura(WINTERS_CHILL1); //33%
+            //Imp Blizzard
+            if (level >= 20)
+                RefreshAura(IMPROVED_BLIZZARD); //50% slow
+            //Frostbite
+            if (level >= 80)
+                FROSTBITE = FROSTBITE3;
+            else if (level >= 50)
+                FROSTBITE = FROSTBITE2;
+            else if (level >= 10)
+                FROSTBITE = FROSTBITE1;
+            if (level >= 60)
+                RefreshAura(FROSTBITE,3);//3x
+            else if (level >= 30)
+                RefreshAura(FROSTBITE,2);//2x
+            else if (level >= 10)
+                RefreshAura(FROSTBITE);//1x
+            //Shattered Barrier
+            if (level >= 45)
+                RefreshAura(SHATTERED_BARRIER);
+            //Bonus
+            if (level >= 65)
+                RefreshAura(ARCANE_INSTABILITY,4); //+12%dmg crit
+            else if (level >= 55)
+                RefreshAura(ARCANE_INSTABILITY,3); //+9%dmg crit
+            else if (level >= 45)
+                RefreshAura(ARCANE_INSTABILITY,2); //+6%dmg crit
+            else if (level >= 35)
+                RefreshAura(ARCANE_INSTABILITY); //+3%dmg crit
+            //Absorb
+            if (level >= 50)
+                RefreshAura(INCANTERS_ABSORPTION3);
+            else if (level >= 45)
+                RefreshAura(INCANTERS_ABSORPTION2);
+            else if (level >= 40)
+                RefreshAura(INCANTERS_ABSORPTION1);
+            //Shatter
+            if (level >= 35)
+                RefreshAura(SHATTER3);
+            else if (level >= 30)
+                RefreshAura(SHATTER2);
+            else if (level >= 25)
+                RefreshAura(SHATTER1);
+            //ClearCasting
+            if (level >= 75)
+                RefreshAura(CLEARCAST,3);//30%
+            else if (level >= 40)
+                RefreshAura(CLEARCAST,2);//20%
+            else if (level >= 15)
+                RefreshAura(CLEARCAST);//10%
+            //Fingers
+            if (level >= 45)
+                RefreshAura(FINGERS_OF_FROST);//15%
+            //Potency
+            if (level >= 40)
+                RefreshAura(ARCANE_POTENCY2);//30% bonus
+            else if (level >= 35)
+                RefreshAura(ARCANE_POTENCY1);//15% bonus
+            //Ignite
+            if (level >= 15)
+                RefreshAura(IGNITE);
+            //Impact
+            if (level >= 60)
+                RefreshAura(IMPACT,2);
+            else if (level >= 20)
+                RefreshAura(IMPACT);
+            //Imp. Counterspell
+            if (level >= 35)
+                RefreshAura(IMPROVED_COUNTERSPELL2);//4 sec
+            else if (level >= 25)
+                RefreshAura(IMPROVED_COUNTERSPELL1);//2 sec
+            //Firestarter
+            if (level >= 55)
+                RefreshAura(FIRESTARTER2);//100% chance
+            else if (level >= 45)
+                RefreshAura(FIRESTARTER1);//50% chance
+            //Spells
+            if (LIVINGBOMB != 0)
+                RefreshAura(GLYPH_LIVING_BOMB);
+            if (POLYMORPH != 0)
+                RefreshAura(GLYPH_POLYMORPH);
+        }
+
+    private:
+        uint32
+  /*Arcane*/DAMPENMAGIC, ARCANEINTELLECT, ARCANEMISSILES, POLYMORPH, COUNTERSPELL, FOCUSMAGIC,
+  /*Arcane*/SPELLSTEAL, EVOCATION, BLINK, REMOVE_CURSE, /*INVISIBILITY,*/
+    /*Fire*/FIREBALL, FIREBLAST, FLAMESTRIKE, PYROBLAST, COMBUSTION, BLASTWAVE, DRAGONBREATH, LIVINGBOMB,
+   /*Frost*/FROSTBOLT, FROSTNOVA, CONEOFCOLD, BLIZZARD, ICEARMOR, ICEBLOCK, ICE_BARRIER, FROSTBITE;
+        //Timers
+/*fire*/uint32 Pyroblast_cd, FireBlast_cd, DragonBreath_cd, Living_Bomb_cd, Combustion_cd;
+/*frst*/uint32 Ice_Barrier_cd, ConeofCold_cd, Blizzard_cd, Iceblock_cd;
+/*arcn*/uint32 CounterSpell_cd, Blink_cd, Evocation_cd;
+/*exc.*/uint32 Bolt_cd, Nova_cd;
+/*exc.*/uint32 BOLT, NOVA;
+/*exc.*/uint32 polyCheckTimer, fmCheckTimer;
+        //Check
+/*exc.*/bool Polymorph, clearcast;
+
+        enum MageBaseSpells// all orignals
+        {
+            DAMPENMAGIC_1                       = 604, 
+            ARCANEINTELLECT_1                   = 1459, 
+            ARCANEMISSILES_1                    = 5143, 
+            POLYMORPH_1                         = 118,
+            COUNTERSPELL_1                      = 2139,
+            SPELLSTEAL_1                        = 30449,
+            EVOCATION_1                         = 12051,
+            BLINK_1                             = 1953,
+            REMOVE_CURSE_1                      = 475,
+            //INVISIBILITY_1                      = 0,
+            FIREBALL_1                          = 133,
+            BLASTWAVE_1                         = 11113,
+            DRAGONBREATH_1                      = 31661,
+            FIREBLAST_1                         = 2136,
+            PYROBLAST_1                         = 11366,
+            LIVINGBOMB_1                        = 44457,
+            FLAMESTRIKE_1                       = 2120,
+            COMBUSTION_1                        = 11129,
+            FROSTBOLT_1                         = 116,
+            FROSTNOVA_1                         = 122,
+            CONEOFCOLD_1                        = 120,
+            BLIZZARD_1                          = 10,
+            FROSTARMOR_1                        = 168,
+            ICEARMOR_1                          = 7302,
+            ICE_BARRIER_1                       = 11426,
+            ICEBLOCK_1                          = 45438,
+            FOCUSMAGIC_1                        = 54646,
+        };
+
+        enum MagePassives
+        {
+            SHATTERED_BARRIER                   = 54787,//rank 2
+            ARCTIC_WINDS                        = 31678,//rank 5
+            WINTERS_CHILL1                      = 11180,
+            WINTERS_CHILL2                      = 28592,
+            WINTERS_CHILL3                      = 28593,
+            FROSTBITE1                          = 11071,
+            FROSTBITE2                          = 12496,
+            FROSTBITE3                          = 12497,
+            IMPROVED_BLIZZARD                   = 12488,//rank 3
+            CLEARCAST /*Arcane Concentration*/  = 12577,//rank 5
+            ARCANE_POTENCY1                     = 31571,
+            ARCANE_POTENCY2                     = 31572,
+            SHATTER1                            = 11170,
+            SHATTER2                            = 12982,
+            SHATTER3                            = 12983,
+            INCANTERS_ABSORPTION1               = 44394,
+            INCANTERS_ABSORPTION2               = 44395,
+            INCANTERS_ABSORPTION3               = 44396,
+            FINGERS_OF_FROST                    = 44545,//rank 2
+            ARCANE_INSTABILITY                  = 15060,//rank 3
+            IMPROVED_COUNTERSPELL1              = 11255,
+            IMPROVED_COUNTERSPELL2              = 12598,
+            IGNITE                              = 12848,
+            FIRESTARTER1                        = 44442,
+            FIRESTARTER2                        = 44443,
+            IMPACT                              = 12358,
+            GLYPH_LIVING_BOMB                   = 63091,
+            GLYPH_POLYMORPH                     = 56375,
+        };
+        enum MageSpecial
+        {
+            CLEARCASTBUFF                       = 12536,
+            IMPACT_BUFF                         = 64343,
+            FIRESTARTERBUFF                     = 54741,
+            ARCANE_POTENCY_BUFF1                = 57529,
+            ARCANE_POTENCY_BUFF2                = 57531,
+            COMBUSTION_BUFF                     = 28682
+        };
+    };
+};
+
+void AddSC_mage_bot()
+{
+    new mage_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_paladin_ai.cpp b/src/server/game/AI/NpcBots/bot_paladin_ai.cpp
new file mode 100644
index 0000000..ab364c6
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_paladin_ai.cpp
@@ -0,0 +1,1049 @@
+#include "bot_ai.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuraEffects.h"
+#include "WorldSession.h"
+/*
+Paladin NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - Around 45-50%
+TODO: Tanking, Shield Abilities, Auras
+*/
+class paladin_bot : public CreatureScript
+{
+public:
+    paladin_bot() : CreatureScript("paladin_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new paladin_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    struct paladin_botAI : public bot_minion_ai
+    {
+        paladin_botAI(Creature* creature) : bot_minion_ai(creature) { }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (checkBotCast(victim, spellId, CLASS_PALADIN) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        void HOFGroup(Player* pTarget, uint32 diff)
+        {
+            if (!HOF || HOF_Timer > diff || GC_Timer > diff || Rand() > 60) return;
+            if (IsCasting()) return; //I'm busy
+
+            if (Group* pGroup = pTarget->GetGroup())
+            {
+                for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* tPlayer = itr->GetSource();
+                    if (!tPlayer) continue;
+                    if (HOFTarget(tPlayer, diff))
+                        return;
+                }
+                for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* tPlayer = itr->GetSource();
+                    if (!tPlayer || !tPlayer->HaveBot()) continue;
+                    for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+                    {
+                        Creature* cre = tPlayer->GetBotMap(i)->_Cre();
+                        if (!cre || !cre->IsInWorld()) continue;
+                        if (HOFTarget(cre, diff))
+                            return;
+                    }
+                }
+            }
+        }
+
+        bool HOFTarget(Unit* target, uint32 diff)
+        {
+            if (!HOF || HOF_Timer > diff || GC_Timer > diff) return false;
+            if (!target || target->isDead()) return false;
+            if (target->ToCreature() && Rand() > 25) return false;
+            if (me->GetExactDist(target) > 30) return false;//too far away
+            if (HasAuraName(target, HOF)) return false;     //Alredy has HOF
+
+            Unit::AuraMap const &auras = target->GetOwnedAuras();
+            for (Unit::AuraMap::const_iterator i = auras.begin(); i != auras.end(); ++i)
+            {
+                Aura* aura = i->second;
+                if (aura->IsPassive()) continue;//most
+                if (aura->GetDuration() < 2000) continue;
+                if (AuraApplication* app = aura->GetApplicationOfTarget(target->GetGUID()))
+                    if (app->IsPositive()) continue;
+                SpellInfo const* spellInfo = aura->GetSpellInfo();
+                if (spellInfo->AttributesEx & SPELL_ATTR0_HIDDEN_CLIENTSIDE) continue;
+                if (me->getLevel() >= 40 && (spellInfo->GetAllEffectsMechanicMask() & (1<<MECHANIC_STUN)))
+                {
+                    if (doCast(target, HOF))
+                    {
+                        if (target->ToCreature())
+                            HOF_Timer = 10000; //10 sec for selfcast after stun
+                        else
+                            HOF_Timer = 15000; //improved
+                        HOFGuid = target->GetGUID();
+                        return true;
+                    }
+                }
+       /*else */if (spellInfo->GetAllEffectsMechanicMask() & (1<<MECHANIC_SNARE) || 
+                    spellInfo->GetAllEffectsMechanicMask() & (1<<MECHANIC_ROOT))
+                {
+                    uint32 spell = (spellInfo->Dispel == DISPEL_MAGIC ||
+                        spellInfo->Dispel == DISPEL_DISEASE ||
+                        spellInfo->Dispel == DISPEL_POISON) &&
+                        CLEANSE ? CLEANSE : HOF;
+                    if (doCast(target, spell))
+                    {
+                        if (spell == HOF)
+                        {
+                            if (target->ToCreature())
+                                HOF_Timer = 5000;//5 sec for bots
+                            else
+                                HOF_Timer = 15000;//improved
+                            if (me->getLevel() >= 40)
+                                HOFGuid = target->GetGUID();
+                        }
+                        return true;
+                    }
+                }
+            }
+            return false;
+        }
+
+        void HOSGroup(Player* hTarget, uint32 diff)
+        {
+            if (!HOS || HOS_Timer > diff || GC_Timer > diff || Rand() > 30) return;
+            if (IsCasting()) return;
+            if (Group* pGroup = hTarget->GetGroup())
+            {
+                bool bots = false;
+                float threat;
+                for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* HOSPlayer = itr->GetSource();
+                    if (!HOSPlayer) continue;
+                    if (HOSPlayer->HaveBot())
+                        bots = true;
+                    if (HOSPlayer->isDead()) continue;
+                    if (tank && HOSPlayer == tank) continue;//tanks do not need it
+                    if (!HOSPlayer->IsInWorld() || master->GetMap() != HOSPlayer->FindMap() || me->GetExactDist(HOSPlayer) > 30) continue;
+                    if (HasAuraName(HOSPlayer, HOS)) continue;
+                    AttackerSet h_attackers = HOSPlayer->getAttackers();
+                    if (h_attackers.empty()) continue;
+                    for (AttackerSet::iterator iter = h_attackers.begin(); iter != h_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->isDead()) continue;
+                        if (!(*iter)->CanHaveThreatList()) continue;
+                        threat = (*iter)->getThreatManager().getThreat(HOSPlayer);
+                        if (threat < 25.f) continue;//too small threat
+                        if ((*iter)->getThreatManager().getThreat(tank) < threat * 0.33f) continue;//would be useless
+                        if (HOSPlayer->GetDistance((*iter)) > 10) continue;
+                        if (HOSTarget(HOSPlayer, diff))
+                            return;
+                    }//end for
+                }//end for
+                if (!bots) return;
+                for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* pl = itr->GetSource();
+                    if (!pl) continue;
+                    if (!pl->HaveBot()) continue;
+                    if (master->GetMap() != pl->FindMap()) continue;
+                    if (!pl->IsInWorld() || pl->IsBeingTeleported()) continue;
+                    for (uint8 i = 0; i != pl->GetMaxNpcBots(); ++i)
+                    {
+                        Creature* cre = pl->GetBotMap(i)->_Cre();
+                        if (!cre || cre->isDead()) continue;
+                        if (tank && cre == tank) continue;
+                        if (me->GetExactDist(cre) > 30) continue;
+                        if (HasAuraName(cre, HOS)) continue;     //Alredy has HOS
+                        AttackerSet h_attackers = cre->getAttackers();
+                        if (h_attackers.empty()) continue;
+                        for (AttackerSet::iterator iter = h_attackers.begin(); iter != h_attackers.end(); ++iter)
+                        {
+                            if (!(*iter)) continue;
+                            if ((*iter)->isDead()) continue;
+                            if (!(*iter)->CanHaveThreatList()) continue;
+                            threat = (*iter)->getThreatManager().getThreat(cre);
+                            if (threat < 25.f) continue;//too small threat
+                            if ((*iter)->getThreatManager().getThreat(tank) < threat * 0.33f) continue;//would be useless
+                            if (cre->GetDistance((*iter)) > 10) continue;
+                            if (HOSTarget(cre, diff))
+                                return;
+                        }//end for
+                    }//end for
+                }//end for
+            }//end if
+        }
+
+        bool HOSTarget(Unit* target, uint32 diff)
+        {
+            if (!target || target->isDead()) return false;
+            if (!HOS || HOS_Timer > diff || GC_Timer > diff || Rand() > 50) return false;
+            if (tank && target == tank) return false;       //tanks do not need it
+            if (IsCasting()) return false;          //I'm busy casting
+            if (me->GetExactDist(target) > 30) return false; //too far away
+            if (HasAuraName(target, HOS)) return false;     //Alredy has HOS
+
+            AttackerSet h_attackers = target->getAttackers();
+            if (h_attackers.empty()) return false; //no aggro
+            float threat;
+            uint8 Tattackers = 0;
+            for (AttackerSet::iterator iter = h_attackers.begin(); iter != h_attackers.end(); ++iter)
+            {
+                if (!(*iter)) continue;
+                if ((*iter)->isDead()) continue;
+                if (!(*iter)->CanHaveThreatList()) continue;
+                threat = (*iter)->getThreatManager().getThreat(target);
+                if (threat < 25.f) continue; //too small threat
+                if ((*iter)->getThreatManager().getThreat(tank) < threat * 0.33f) continue;//would be useless
+                if (target->GetDistance((*iter)) <= 10)
+                    Tattackers++;
+            }
+            if (Tattackers > 0 && doCast(target, HOS))
+            {
+                for (AttackerSet::iterator iter = h_attackers.begin(); iter != h_attackers.end(); ++iter)
+                    if ((*iter)->getThreatManager().getThreat(target) > 0.f)
+                        (*iter)->getThreatManager().modifyThreatPercent(target, -(30 + 50*(target->HasAura(586)))); //Fade
+                HOS_Timer = 25000 - 20000*IS_CREATURE_GUID(target->GetGUID());
+                return true;
+            }
+            return false;
+        }
+        //Holy_Shock setup (Modify HERE)
+        bool HS(Unit* target, uint32 diff)
+        {
+            if (!target || target->isDead()) return false;
+            if (!HOLY_SHOCK || HS_Timer > diff || GC_Timer > diff) return false;
+            if (IsCasting()) return false;
+            if (target->GetTypeId() == TYPEID_PLAYER && (target->IsCharmed() || target->isPossessed()))
+                return false; //do not damage friends under control
+            if (me->GetExactDist(target) > 40) return false;
+
+            if (doCast(target, HOLY_SHOCK))
+            {
+                if (urand(1,100) > 20) //Daybreak: 20% to not trigger HS CD, only GCD
+                    HS_Timer = target->ToCreature() ? 3500 : 5000;
+                return true;
+            }
+            return false;
+        }
+
+        bool HealTarget(Unit* target, uint8 hp, uint32 diff)
+        {
+            if (!target || target->isDead()) return false;
+            if (hp > 97) return false;
+            //sLog->outBasic("HealTarget() by %s on %s", me->GetName().c_str(), target->GetName().c_str());
+            if (Rand() > 40 + 20*target->IsInCombat() + 50*master->GetMap()->IsRaid()) return false;
+            if (me->GetExactDist(target) > 35) return false;
+            if (IsCasting()) return false;
+            if (HAND_OF_PROTECTION && BOP_Timer <= diff && IS_PLAYER_GUID(target->GetGUID()) && 
+                (master->GetGroup() && master->GetGroup()->IsMember(target->GetGUID()) || target == master) && 
+                ((hp < 30 && !target->getAttackers().empty()) || (hp < 50 && target->getAttackers().size() > 3)) && 
+                me->GetExactDist(target) < 30 && 
+                !HasAuraName(target, HAND_OF_PROTECTION) && 
+                !HasAuraName(target, "Forbearance"))
+            {
+                if (doCast(target, HAND_OF_PROTECTION))
+                {
+                    if (target->GetTypeId() == TYPEID_PLAYER)
+                        me->MonsterWhisper("BOP on you!", target->GetGUID());
+                    BOP_Timer = 60000; //1 min
+                    if (!HasAuraName(target, "Forbearance"))
+                        me->AddAura(25771, target); //Forbearance
+                    if (HasAuraName(target, "Forbearance") && !target->HasAura(HAND_OF_PROTECTION))
+                        me->AddAura(HAND_OF_PROTECTION, target);
+                }
+                return true;
+            }
+            else if (hp < 20 && !HasAuraName(target, HAND_OF_PROTECTION))
+            {
+                // 20% to cast loh, else just do a Shock
+                switch (rand()%3)
+                {
+                    case 1:
+                        if (LAY_ON_HANDS && LOH_Timer <= diff && hp < 20 && 
+                            target->GetTypeId() == TYPEID_PLAYER && 
+                            (target->IsInCombat() || !target->getAttackers().empty()) && 
+                            !HasAuraName(target, "Forbearance"))
+                        {
+                            if (doCast(target, LAY_ON_HANDS))
+                            {
+                                me->MonsterWhisper("Lay of Hands on you!", target->GetGUID());
+                                LOH_Timer = 150000; //2.5 min
+                                return true;
+                            }
+                        }
+                    case 2:
+                        if (GC_Timer > diff) return false;
+                        if (FLASH_OF_LIGHT && doCast(target, FLASH_OF_LIGHT))
+                            return true;
+                    case 3:
+                        if (GC_Timer > diff) return false;
+                        if (HOLY_SHOCK && HS_Timer <= diff && HS(target, diff))
+                            return true;
+                }
+            }
+            if (GC_Timer > diff) return false;
+            if (HOLY_SHOCK && (hp < 85 || GetLostHP(target) > 6000) && HS_Timer <= diff)
+                if (HS(target, diff))
+                    return true;
+            if ((hp > 35 && (hp < 75 || GetLostHP(target) > 8000)) || (!FLASH_OF_LIGHT && hp < 85))
+                if (doCast(target, HOLY_LIGHT))
+                    return true;
+            if (FLASH_OF_LIGHT && (hp < 90 || GetLostHP(target) > 1500))
+                if (doCast(target, FLASH_OF_LIGHT))
+                    return true;
+            return false;
+        }//end HealTarget
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            GetInPosition(force, false);
+        }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit*) { master->SetNpcBotDied(me->GetGUID()); }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (HOFGuid != 0)
+            {
+                if (Unit* ally = sObjectAccessor->FindUnit(HOFGuid))
+                    if (Aura* hof = ally->GetAura(HOF, me->GetGUID()))
+                        hof->SetDuration(hof->GetDuration() + 4000); //Guardian's Favor part 2 (handled separately)
+                HOFGuid = 0;
+            }
+            if (IAmDead()) return;
+            if (me->GetVictim())
+                DoMeleeAttackIfReady();
+            else
+                Evade();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            CheckAuras();
+            BreakCC(diff);
+            //HOFTarget(me, diff);//self stun cure goes FIRST
+            if (CCed(me)) return;
+
+            if (GetManaPCT(me) < 30 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, MANAPOTION))
+                    Potion_cd = POTION_CD;
+                GC_Timer = temptimer;
+            }
+            if (GetManaPCT(me) < 40 && DIVINE_PLEA && Divine_Plea_Timer <= diff)
+                if (doCast(me, DIVINE_PLEA))
+                    Divine_Plea_Timer = 45000;
+
+            CureTarget(me, CLEANSE, diff); //maybe unnecessary but this goes FIRST
+            HOFTarget(master, diff); //maybe unnecessary
+            CureTarget(master, CLEANSE, diff); //maybe unnecessary
+            BuffAndHealGroup(master, diff);
+            HOSTarget(master, diff);
+            CureGroup(master, CLEANSE, diff);
+            HOFGroup(master, diff);
+            HOSGroup(master, diff);
+
+            if (GetHealthPCT(me) < 50 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, HEALINGPOTION))
+                    Potion_cd = POTION_CD;
+                GC_Timer = temptimer;
+            }
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+            //buff
+            if (SEAL_OF_TRUTH && Rand() < 20 && GC_Timer <= diff && !me->HasAura(SEAL_OF_TRUTH) && 
+                doCast(me, SEAL_OF_TRUTH))
+                GC_Timer = 500;
+
+            // Heal myself
+            if (GetHealthPCT(me) < 80)
+                HealTarget(me, GetHealthPCT(me), diff);
+
+            if (!CheckAttackTarget(CLASS_PALADIN))
+                return;
+
+            Repentance(diff);
+            //Counter(diff);
+            DoNormalAttack(diff);
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || me->IsMounted()) return;
+
+            RezGroup(REDEMPTION, master);
+
+            if (Feasting()) return;
+
+            //aura
+            if (master->IsAlive() && me->GetExactDist(master) < 20)
+            {
+                uint8 myAura;
+                if (me->HasAura(DEVOTION_AURA, me->GetGUID()))
+                    myAura = DEVOTIONAURA;
+                else if (me->HasAura(CONCENTRATION_AURA, me->GetGUID()))
+                    myAura = CONCENTRATIONAURA;
+                else myAura = NOAURA;
+
+                if (myAura != NOAURA)
+                    return; //do not bother
+
+                Aura* concAura = master->GetAura(CONCENTRATION_AURA);
+                Aura* devAura = master->GetAura(DEVOTION_AURA);
+                if (devAura && concAura) return;
+                if (devAura && devAura->GetCasterGUID() == me->GetGUID()) return;
+                if (concAura && concAura->GetCasterGUID() == me->GetGUID()) return;
+
+                if ((master->getClass() == CLASS_MAGE || 
+                    master->getClass() == CLASS_PRIEST || 
+                    master->getClass() == CLASS_WARLOCK || 
+                    master->getClass() == CLASS_DRUID || devAura) && 
+                    !concAura && 
+                    doCast(me, CONCENTRATION_AURA))
+                {
+                    /*GC_Timer = 800;*/
+                    return;
+                }
+                if (!devAura && doCast(me, DEVOTION_AURA))
+                {
+                    /*GC_Timer = 800;*/
+                    return;
+                }
+            }
+        }
+
+        bool BuffTarget(Unit* target, uint32 diff)
+        {
+            if (!target || target->isDead() || GC_Timer > diff || Rand() > 30) return false;
+            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
+            if (me->GetExactDist(target) > 30) return false;
+
+            bool kings = !BLESSING_OF_KINGS || HasAuraName(target, BLESSING_OF_KINGS);
+            bool might = !BLESSING_OF_MIGHT || HasAuraName(target, BLESSING_OF_MIGHT);
+            if (kings && might)
+                return false;
+
+            if (!kings && doCast(target, BLESSING_OF_KINGS))
+                return true;
+
+            if (!might && doCast(target, BLESSING_OF_MIGHT))
+                return true;
+
+            return false;
+        }
+
+        void Repentance(uint32 diff, Unit* target = NULL)
+        {
+            if (target && Repentance_Timer < 25000 && doCast(target, REPENTANCE))
+            {
+                temptimer = GC_Timer;
+                Repentance_Timer = 45000;
+                GC_Timer = temptimer;
+                return;
+            }
+            if (REPENTANCE && Repentance_Timer <= diff)
+            {
+                Unit* u = FindRepentanceTarget(30);
+                if (u && u->GetVictim() != me && doCast(u, REPENTANCE))
+                    Repentance_Timer = 45000;
+            }
+        }
+
+        void Counter(uint32 diff)
+        {
+            if (IsCasting())
+                return;
+
+            if (REBUKE && Rand() < 90 && Rebuke_Timer <= diff && me->GetDistance(opponent) < 5 &&
+                opponent->IsNonMeleeSpellCasted(false))
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, REBUKE))
+                {
+                    Rebuke_Timer = 8000;
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            if (Rand() > 60)
+                return;
+
+            Unit* target = Repentance_Timer < 25000 ? FindCastingTarget(30, false, REPENTANCE) : NULL;
+            if (target)
+                Repentance(diff, target); //first check repentance
+            else if (TURN_EVIL && Turn_Evil_Timer < 1500)
+            {
+                target = FindCastingTarget(20, false, TURN_EVIL);
+                temptimer = GC_Timer;
+                if (target && doCast(target, TURN_EVIL, true))
+                    Turn_Evil_Timer = 3000;
+                GC_Timer = temptimer;
+            }
+            else if (HOLY_WRATH && Holy_Wrath_Timer < 8000)
+            {
+                target = FindCastingTarget(8, false, TURN_EVIL); //here we check target as with turn evil cuz of same requirements
+                temptimer = GC_Timer;
+                if (target && doCast(me, HOLY_WRATH))
+                    Holy_Wrath_Timer = 23500 - me->getLevel() * 100; //23.5 - 0...8.5 sec (15 sec on 85)
+                GC_Timer = temptimer;
+            }
+            else if (HAMMER_OF_JUSTICE && HOJ_Timer <= 7000/* && GC_Timer <= diff*/)
+            {
+                target = FindCastingTarget(10);
+                if (target && doCast(opponent, HAMMER_OF_JUSTICE))
+                    HOJ_Timer = 69000 - master->getLevel()*500; //25 sec on 85
+            }
+        }
+
+        void TurnEvil(uint32 diff)
+        {
+            if (!TURN_EVIL || Turn_Evil_Timer > diff || GC_Timer > diff || Rand() > 50 || 
+                FindAffectedTarget(TURN_EVIL, me->GetGUID(), 50))
+                return;
+            Unit* target = FindUndeadCCTarget(20, TURN_EVIL);
+            if (target && 
+                (target != me->GetVictim() || GetHealthPCT(me) < 70 || target->GetVictim() == master) && 
+                doCast(target, TURN_EVIL, true))
+            {
+                Turn_Evil_Timer = 3000;
+                return;
+            }
+            else
+            if ((opponent->GetCreatureType() == CREATURE_TYPE_UNDEAD || opponent->GetCreatureType() == CREATURE_TYPE_DEMON) && 
+                !CCed(opponent) && 
+                opponent->GetVictim() && tank && opponent->GetVictim() != tank && opponent->GetVictim() != me && 
+                GetHealthPCT(me) < 90 && 
+                doCast(opponent, TURN_EVIL, true))
+                Turn_Evil_Timer = 3000;
+        }
+
+        void Wrath(uint32 diff)
+        {
+            if (!HOLY_WRATH || Holy_Wrath_Timer > diff || GC_Timer > diff || Rand() > 50)
+                return;
+            if ((opponent->GetCreatureType() == CREATURE_TYPE_UNDEAD || opponent->GetCreatureType() == CREATURE_TYPE_DEMON) && 
+                me->GetExactDist(opponent) <= 8 && doCast(me, HOLY_WRATH))
+                Holy_Wrath_Timer = 23500 - me->getLevel() * 100; //23.5 - 0...8.5 sec (15 sec on 85)
+            else 
+            {
+                Unit* target = FindUndeadCCTarget(8, HOLY_WRATH);
+                if (target && doCast(me, HOLY_WRATH))
+                    Holy_Wrath_Timer = 23500 - me->getLevel() * 100; //23.5 - 0...8.5 sec (15 sec on 85)
+            }
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent, true);
+            }
+            else
+                return;
+
+            Counter(diff);
+            TurnEvil(diff);
+
+            if (MoveBehind(*opponent))
+                wait = 5;
+
+            if (HOW && HOW_Timer <= diff && Rand() < 30 && GetHealthPCT(opponent) < 19 && GC_Timer <= 300 &&// custom GCD check
+                me->GetExactDist(opponent) < 30)
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, HOW))
+                {
+                    HOW_Timer = 6000; //6 sec
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            Unit* u = opponent->GetVictim();
+            if (Rand() < 50 && HANDOFRECKONING && Hand_Of_Reckoning_Timer <= diff && me->GetExactDist(opponent) < 30 &&
+                u && u != me && u != tank && (IsInBotParty(u) || tank == me)) //No GCD
+            {
+                Creature* cre = opponent->ToCreature();
+                temptimer = GC_Timer;
+                if (((cre && cre->isWorldBoss() && !isMeleeClass(u->getClass())) || 
+                    GetHealthPCT(u) < GetHealthPCT(me) - 5 || tank == me) && 
+                    doCast(opponent, HANDOFRECKONING))
+                {
+                    Hand_Of_Reckoning_Timer = (me == tank) ? 4000 : 8000;
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            if (Rand() < 20 && HAMMER_OF_JUSTICE && HOJ_Timer <= diff && GC_Timer <= diff && 
+                !CCed(opponent) && me->GetExactDist(opponent) < 10)
+            {
+                if (doCast(opponent, HAMMER_OF_JUSTICE))
+                {
+                    HOJ_Timer = 69000 - master->getLevel()*500; //25 sec on 85
+                    return;
+                }
+            }
+
+            if (JUDGEMENT && Judge_Timer <= diff && GC_Timer <= diff && Rand() < 50 && 
+                me->GetExactDist(opponent) < 10 && me->HasAura(SEAL_OF_TRUTH))
+                if (doCast(opponent, JUDGEMENT))
+                    Judge_Timer = 7000;
+
+            if (Rand() < 50 && CONSECRATION && Consecration_cd <= diff && GC_Timer <= diff && 
+                me->GetDistance(opponent) < 7 && !opponent->isMoving())
+            {
+                if (doCast(me, CONSECRATION))
+                {
+                    Consecration_cd = 20000;
+                    return;
+                }
+            }
+
+            if (Rand() < 25 && AVENGING_WRATH && AW_Timer <= diff && 
+                (opponent->GetHealth() > master->GetMaxHealth()*2/3))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, AVENGING_WRATH))
+                {
+                    AW_Timer = 60000; //1 min
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            if (CRUSADER_STRIKE && Crusader_cd <= diff && GC_Timer <= diff && me->GetDistance(opponent) < 5)
+            {
+                if (doCast(opponent, CRUSADER_STRIKE))
+                {
+                    Crusader_cd = 4530 - me->getLevel() * 18; //3 sec on 85
+                    return;
+                }
+            }
+
+            if (EXORCISM && Exorcism_Timer <= diff && GC_Timer <= diff && me->GetExactDist(opponent) < 30 &&
+                (tank != me || opponent->GetVictim() == me || opponent->IsVehicle() || opponent->ToPlayer()))
+            {
+                if (doCast(opponent, EXORCISM, me->HasAura(THE_ART_OF_WAR_BUFF)))
+                {
+                    Exorcism_Timer = 7000;
+                    return;
+                }
+            }
+
+            Wrath(diff);
+
+            if (DIVINE_STORM && DS_Timer <= diff && GC_Timer <= diff && me->GetExactDist(opponent) < 7)
+            {
+                if (doCast(opponent, DIVINE_STORM))
+                {
+                    DS_Timer = 10000 - me->getLevel()/4 * 100; //10 - 2 sec
+                    return;
+                }
+            }
+        }
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //Rule of Law: 15% additional crit chance for Crusader Strike etc.
+                if (lvl >= 30 && spellId == CRUSADER_STRIKE)
+                    aftercrit += 0.15f;
+                //Arbiter of the Light: 12% additional crit chance for Judgements etc.
+                if (lvl >= 10 && (spellInfo->Category == SPELLCATEGORY_JUDGEMENT || spellInfo->GetSpellSpecific() == SPELL_SPECIFIC_JUDGEMENT))
+                    aftercrit += 0.12f;
+
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            //if (crit)
+            //{
+            //}
+            //Wrath of the Lightbringer (part 1): 100% bonus damage for Crusader Strike and Judgements
+            if (lvl >= 30 &&
+                (spellId == CRUSADER_STRIKE ||
+                spellInfo->Category == SPELLCATEGORY_JUDGEMENT ||
+                spellInfo->GetSpellSpecific() == SPELL_SPECIFIC_JUDGEMENT))
+                pctbonus += 1.f;
+            //Hallowed Ground: 40% bonus damage for Consecration
+            if (lvl >= 30 && spellId == CONSECRATION)
+                pctbonus += 0.4f;
+            //Crusade (part 1): 30% bonus damage for Crusader Strike etc.
+            if (lvl >= 10 && spellId == CRUSADER_STRIKE)
+                pctbonus += 0.3f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //Wrath of the Lightbringer (part 2): 30% additional crit chance for Holy Wrath and Hammer of Wrath
+                if (lvl >= 30 && (spellId == HOLY_WRATH || spellId == HOW))
+                    aftercrit += 0.3f;
+                //Sanctified Wrath: 6% additional critical chance for Hammer of Wrath
+                if (lvl >= 40 && spellId == HOW)
+                    aftercrit += 0.06f;
+
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            //if (crit)
+            //{
+            //}
+
+            //Blazing Light: 20% bonus damage for Exorcism and Holy Shock
+            if (lvl >= 20 && (spellId == EXORCISM || spellId == HOLY_SHOCK))
+                pctbonus += 0.2f;
+
+            //SPECIAL
+            //The Art of War (buff): 100% bonus damage for Exorcism
+            if (lvl >= 33 && spellId == EXORCISM && me->HasAura(THE_ART_OF_WAR_BUFF))
+            {
+                me->RemoveAura(THE_ART_OF_WAR_BUFF);
+                pctbonus += 1.f;
+            }
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void DamageDealt(Unit* /*victim*/, uint32& /*damage*/, DamageEffectType damageType)
+        {
+            //Custom OnHit() handlers
+
+            if (damageType == DIRECT_DAMAGE)
+            {
+                //The Art of War: 20% on autoattack
+                if (me->getLevel() >= 33)
+                    if (urand(1,100) <= 20)
+                        me->CastSpell(me, THE_ART_OF_WAR_BUFF, true);
+            }
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            Crusader_cd = 0;
+            Consecration_cd = 0;
+            LOH_Timer = 0;
+            HOJ_Timer = 0;
+            HOF_Timer = 0;
+            Judge_Timer = 0;
+            HS_Timer = 0;
+            BOP_Timer = 0;
+            HOW_Timer = 0;
+            DS_Timer = 0;
+            AW_Timer = 10000;
+            HOS_Timer = 0;
+            Hand_Of_Reckoning_Timer = 0;
+            Divine_Plea_Timer = 0;
+            Repentance_Timer = 0;
+            Exorcism_Timer = 0;
+            Holy_Wrath_Timer = 0;
+            Turn_Evil_Timer = 0;
+            Rebuke_Timer = 0;
+
+            HOFGuid = 0;
+
+            if (master)
+            {
+                setStats(CLASS_PALADIN, me->getRace(), master->getLevel(), true);
+                ApplyClassPassives();
+                ApplyPassives(CLASS_PALADIN);
+            }
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            CommonTimers(diff);
+            if (HOW_Timer > diff)                   HOW_Timer -= diff;
+            if (DS_Timer > diff)                    DS_Timer -= diff;
+            if (AW_Timer > diff)                    AW_Timer -= diff;
+            if (HOS_Timer > diff)                   HOS_Timer -= diff;
+            if (HS_Timer > diff)                    HS_Timer -= diff;
+            if (BOP_Timer > diff)                   BOP_Timer -= diff;
+            if (Consecration_cd > diff)             Consecration_cd -= diff;
+            if (Crusader_cd > diff)                 Crusader_cd -= diff;
+            if (LOH_Timer > diff)                   LOH_Timer -= diff;
+            if (HOJ_Timer > diff)                   HOJ_Timer -= diff;
+            if (HOF_Timer > diff)                   HOF_Timer -= diff;
+            if (Judge_Timer > diff)                 Judge_Timer -= diff;
+            if (Hand_Of_Reckoning_Timer > diff)     Hand_Of_Reckoning_Timer -= diff;
+            if (Divine_Plea_Timer > diff)           Divine_Plea_Timer -= diff;
+            if (Repentance_Timer > diff)            Repentance_Timer -= diff;
+            if (Exorcism_Timer > diff)              Exorcism_Timer -= diff;
+            if (Holy_Wrath_Timer > diff)            Holy_Wrath_Timer -= diff;
+            if (Turn_Evil_Timer > diff)             Turn_Evil_Timer -= diff;
+            if (Rebuke_Timer > diff)                Rebuke_Timer -= diff;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            FLASH_OF_LIGHT                          = InitSpell(me, FLASH_OF_LIGHT_1);
+            HOLY_LIGHT                  = lvl <= 61 ? InitSpell(me, HOLY_LIGHT_1) : InitSpell(me, DIVINE_LIGHT_1); //exception
+            LAY_ON_HANDS                            = InitSpell(me, LAY_ON_HANDS_1);
+            HOLY_SHOCK                  = lvl >= 10 ? HOLY_SHOCK_1 : 0;
+            CLEANSE                     = lvl >= 34 ? CLEANSE_1 : 0;
+            REDEMPTION                              = InitSpell(me, REDEMPTION_1);
+            HAMMER_OF_JUSTICE                       = InitSpell(me, HAMMER_OF_JUSTICE_1);
+            REPENTANCE                  = lvl >= 47 ? REPENTANCE_1 : 0;
+            TURN_EVIL                               = InitSpell(me, TURN_EVIL_1);
+            HOLY_WRATH                              = InitSpell(me, HOLY_WRATH_1);
+            EXORCISM                                = InitSpell(me, EXORCISM_1);
+            SEAL_OF_TRUTH               = lvl >= 10 ? SEAL_OF_TRUTH_1 : 0;
+            CRUSADER_STRIKE                         = CRUSADER_STRIKE_1; //exception
+            JUDGEMENT                               = InitSpell(me, JUDGEMENT_1);
+            CONSECRATION                            = InitSpell(me, CONSECRATION_1);
+            DIVINE_STORM                = lvl >= 29 ? DIVINE_STORM_1 : 0;
+            HOW /*Hammer of Wrath*/                 = InitSpell(me, HOW_1);
+            AVENGING_WRATH                          = InitSpell(me, AVENGING_WRATH_1);
+            BLESSING_OF_MIGHT                       = InitSpell(me, BLESSING_OF_MIGHT_1);
+            BLESSING_OF_KINGS                       = InitSpell(me, BLESSING_OF_KINGS_1);
+            DEVOTION_AURA                           = InitSpell(me, DEVOTION_AURA_1);
+            CONCENTRATION_AURA                      = InitSpell(me, CONCENTRATION_AURA_1);
+            DIVINE_PLEA                             = InitSpell(me, DIVINE_PLEA_1);
+            HAND_OF_PROTECTION                      = InitSpell(me, HAND_OF_PROTECTION_1);
+            HOF  /* Hand of Freedom */              = InitSpell(me, HOF_1);
+            HOS /*Hand of salvation*/               = InitSpell(me, HOS_1);
+            HANDOFRECKONING                         = InitSpell(me, HANDOFRECKONING_1);
+            REBUKE                                  = InitSpell(me, REBUKE_1);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+            //1 - crit 3%
+            if (level >= 78)
+                RefreshAura(SPELLDMG,5); //+15%
+            else if (level >= 75)
+                RefreshAura(SPELLDMG,4); //+12%
+            else if (level >= 55)
+                RefreshAura(SPELLDMG,3); //+9%
+            else if (level >= 35)
+                RefreshAura(SPELLDMG,2); //+6%
+            else if (level >= 15)
+                RefreshAura(SPELLDMG); //+3%
+            //2 - SPD 2%
+            if (level >= 55)
+                RefreshAura(SPELLDMG2,5); //+10%
+            else if (level >= 45)
+                RefreshAura(SPELLDMG2,4); //+8%
+            else if (level >= 35)
+                RefreshAura(SPELLDMG2,3); //+6%
+            else if (level >= 25)
+                RefreshAura(SPELLDMG2,2); //+4%
+            else if (level >= 15)
+                RefreshAura(SPELLDMG2); //+2%
+            //Talents
+            if (level >= 10)
+                RefreshAura(PURE);
+            if (level >= 11)
+                RefreshAura(WISE);
+            if (level >= 43)
+                RefreshAura(CONVICTION3);
+            else if (level >= 41)
+                RefreshAura(CONVICTION2);
+            else if (level >= 39)
+                RefreshAura(CONVICTION1);
+            if (level >= 45)
+                RefreshAura(SHEATH_OF_LIGHT);
+            if (level >= 37)
+                RefreshAura(DIVINE_PURPOSE);
+            if (level >= 35)
+                RefreshAura(VINDICATION);
+            //434 new
+            if (level >= 51)
+                RefreshAura(HEAL_DONETAKEN,5); //+30%
+            else if (level >= 41)
+                RefreshAura(HEAL_DONETAKEN,4); //+24%
+            else if (level >= 31)
+                RefreshAura(HEAL_DONETAKEN,3); //+18%
+            else if (level >= 21)
+                RefreshAura(HEAL_DONETAKEN,2); //+12%
+            else if (level >= 11)
+                RefreshAura(HEAL_DONETAKEN); //+6%
+
+            if (level >= 13)
+                RefreshAura(POTI3);
+            else if (level >= 11)
+                RefreshAura(POTI2);
+            else if (level >= 10)
+                RefreshAura(POTI1);
+
+            if (level >= 31)
+                RefreshAura(DENOUNCE);
+
+            if (level >= 43)
+                RefreshAura(SPEED_OF_LIGHT);
+
+            if (level >= 21)
+                RefreshAura(JUST);
+
+            if (level >= 29)
+                RefreshAura(COMMUNION);
+
+            if (level >= 39)
+                RefreshAura(SACRED_SHIELD);
+        }
+
+    private:
+        uint32
+   /*Heals*/FLASH_OF_LIGHT, HOLY_LIGHT, HOLY_SHOCK, LAY_ON_HANDS,
+      /*CC*/HAMMER_OF_JUSTICE, REPENTANCE, TURN_EVIL, REBUKE,
+  /*Damage*/SEAL_OF_TRUTH, HOLY_WRATH, EXORCISM, CRUSADER_STRIKE, JUDGEMENT,
+  /*Damage*/CONSECRATION, DIVINE_STORM, AVENGING_WRATH, HOW, //hammer of wrath
+/*Blessing*/BLESSING_OF_MIGHT, BLESSING_OF_KINGS,
+   /*Auras*/DEVOTION_AURA, CONCENTRATION_AURA,
+   /*Hands*/HAND_OF_PROTECTION, HOF, HOS, HANDOFRECKONING,
+    /*Misc*/CLEANSE, REDEMPTION, DIVINE_PLEA;
+        //Timers
+        uint32 Crusader_cd, Consecration_cd, Exorcism_Timer, Holy_Wrath_Timer, Judge_Timer, HOF_Timer,
+            HS_Timer, HOW_Timer, DS_Timer, HOS_Timer, Hand_Of_Reckoning_Timer, Turn_Evil_Timer,
+            LOH_Timer, HOJ_Timer, BOP_Timer, AW_Timer, Divine_Plea_Timer, Repentance_Timer,
+            Rebuke_Timer;
+        uint64 HOFGuid;
+
+        enum PaladinBaseSpells// all orignals
+        {
+            REBUKE_1                            = 96231,
+            DIVINE_LIGHT_1                      = 82326,
+            FLASH_OF_LIGHT_1                    = 19750,
+            HOLY_LIGHT_1                        = 635,
+            LAY_ON_HANDS_1                      = 633,
+            REDEMPTION_1                        = 7328,
+            HOF_1  /*Hand of Freedom*/          = 1044,
+            HOLY_SHOCK_1                        = 20473,
+            CLEANSE_1                           = 66116,//4987 original spell
+            HAND_OF_PROTECTION_1                = 1022,
+            HOS_1 /*Hand of salvation*/         = 1038,
+            SEAL_OF_TRUTH_1                     = 31801,
+            HANDOFRECKONING_1                   = 62124,
+            DIVINE_PLEA_1                       = 54428,
+            REPENTANCE_1                        = 20066,
+            TURN_EVIL_1                         = 10326,
+            CRUSADER_STRIKE_1                   = 35395,
+            JUDGEMENT_1                         = 20271,
+            CONSECRATION_1                      = 26573,
+            HAMMER_OF_JUSTICE_1                 = 853,
+            DIVINE_STORM_1                      = 53385,
+            HOW_1   /*Hammer of Wrath*/         = 24275,
+            EXORCISM_1                          = 879,
+            HOLY_WRATH_1                        = 2812,
+            AVENGING_WRATH_1                    = 31884,
+            BLESSING_OF_MIGHT_1                 = 19740,
+            BLESSING_OF_KINGS_1                 = 20217,
+            DEVOTION_AURA_1                     = 465,
+            CONCENTRATION_AURA_1                = 19746
+        };
+        enum PaladinPassives
+        {
+        //Talents
+            DIVINE_PURPOSE                      = 86172,
+            PURE/*Judgements of the Pure*/      = 54151,
+            JUST/*Judgements of the Just*/      = 53696,//rank 2
+            VINDICATION                         = 26016,
+            CONVICTION1                         = 20049,
+            CONVICTION2                         = 20056,
+            CONVICTION3                         = 20057,
+            POTI1 /*Protector of the Innocent*/ = 20138,
+            POTI2                               = 20139,
+            POTI3                               = 20140,
+            DENOUNCE                            = 85510,//rank 2
+            SPEED_OF_LIGHT                      = 85499,//rank 3
+            COMMUNION                           = 31876,
+            SACRED_SHIELD                       = 85285,
+        //Special
+            SHEATH_OF_LIGHT                     = 53503,//not a talent
+            WISE/*Judgements of the Wise*/      = 31878,//not a talent
+        //other
+            SPELLDMG/*Piercing Ice - mage*/     = 15060,//3% crit
+            SPELLDMG2/*Earth and Moon - druid*/ = 48511 //2% dam
+        };
+
+        enum PaladinSpecial
+        {
+            NOAURA,
+            DEVOTIONAURA,
+            CONCENTRATIONAURA,
+
+            THE_ART_OF_WAR_BUFF                 = 59578
+        };
+    };
+};
+
+void AddSC_paladin_bot()
+{
+    new paladin_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_priest_ai.cpp b/src/server/game/AI/NpcBots/bot_priest_ai.cpp
new file mode 100644
index 0000000..9c7aa1b
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_priest_ai.cpp
@@ -0,0 +1,859 @@
+#include "bot_ai.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+//#include "SpellAuras.h"
+#include "WorldSession.h"
+/*
+Priest NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - Around 50%
+TODO: maybe remove Divine Spirit or so, too much buffs
+*/
+class priest_bot : public CreatureScript
+{
+public:
+    priest_bot() : CreatureScript("priest_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new priest_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    struct priest_botAI : public bot_minion_ai
+    {
+        priest_botAI(Creature* creature) : bot_minion_ai(creature) { }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (checkBotCast(victim, spellId, CLASS_PRIEST) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        bool MassGroupHeal(Player* player, uint32 diff)
+        {
+            if (!PRAYER_OF_HEALING && !DIVINE_HYMN) return false;
+            if (!player->GetGroup()) return false;
+            if (Rand() > 30) return false;
+            if (IsCasting()) return false;
+
+            if (DIVINE_HYMN && Divine_Hymn_Timer <= diff)
+            {
+                Group* gr = player->GetGroup();
+                uint8 LHPcount = 0;
+                for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* tPlayer = itr->GetSource();
+                    if (!tPlayer || me->GetMap() != tPlayer->FindMap() || 
+                        !tPlayer->IsInWorld() || tPlayer->IsBeingTeleported() || 
+                        tPlayer->isPossessed() || tPlayer->IsCharmed()) continue;
+                    if (tPlayer->IsAlive())
+                    {
+                        if (me->GetExactDist(tPlayer) > 35) continue;
+                        uint8 pct = 50 + tPlayer->getAttackers().size()*10;
+                        pct = pct < 80 ? pct : 80;
+                        if (GetHealthPCT(tPlayer) < pct && GetLostHP(tPlayer) > 4000)
+                            ++LHPcount;
+                    }
+                    if (LHPcount > 1)
+                        break;
+                    if (!tPlayer->HaveBot()) continue;
+                    for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+                    {
+                        Creature* bot = tPlayer->GetBotMap(i)->_Cre();
+                        if (bot && GetHealthPCT(bot) < 40 && me->GetExactDist(bot) < 30)
+                            ++LHPcount;
+                        if (LHPcount > 1)
+                            break;
+                    }
+                }
+                if (LHPcount > 1 && doCast(me, DIVINE_HYMN))
+                {
+                    Divine_Hymn_Timer = 180000; //3 min
+                    return true;
+                }
+            }
+            if (PRAYER_OF_HEALING)
+            {
+                Group* gr = player->GetGroup();
+                Unit* castTarget = NULL;
+                uint8 LHPcount = 0;
+                for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    uint8 lowestPCT = 100;
+                    Player* tPlayer = itr->GetSource();
+                    if (!tPlayer || me->GetMap() != tPlayer->GetMap() || 
+                        !tPlayer->IsInWorld() || tPlayer->IsBeingTeleported() || 
+                        tPlayer->isPossessed() || tPlayer->IsCharmed()) continue;
+                    if (tPlayer->IsAlive())
+                    {
+                        if (me->GetExactDist(tPlayer) > 25) continue;
+                        if (GetHealthPCT(tPlayer) < 85)
+                        {
+                            ++LHPcount;
+                            if (GetHealthPCT(tPlayer) < lowestPCT)
+                            lowestPCT = GetHealthPCT(tPlayer);
+                            castTarget = tPlayer;
+                        }
+                    }
+                    if (LHPcount > 2)
+                        break;
+                    if (!tPlayer->HaveBot()) continue;
+                    for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+                    {
+                        Creature* bot = tPlayer->GetBotMap(i)->_Cre();
+                        if (bot && GetHealthPCT(bot) < 70 && me->GetExactDist(bot) < 15)
+                        {
+                            ++LHPcount;
+                            if (GetHealthPCT(bot) < lowestPCT)
+                            lowestPCT = GetHealthPCT(bot);
+                            castTarget = bot;
+                        }
+                        if (LHPcount > 2)
+                            break;
+                    }
+                }
+                if (LHPcount > 2 && castTarget && doCast(castTarget, PRAYER_OF_HEALING))
+                    return true;
+            }
+            return false;
+        }//end MassGroupHeal
+
+        bool ShieldTarget(Unit* target, uint32 diff)
+        {
+            if (PWS_Timer > diff || Rand() > 50 || IsCasting()) return false;
+            if (target->HasAura(WEAKENED_SOUL)) return false;
+            if (HasAuraName(target, PW_SHIELD)) return false;
+            //if (me->GetExactDist(target) > 40) return false;//checked already in HealTarget()
+
+            if (!target->getAttackers().empty() || GetHealthPCT(target) < 33 || target->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+            {
+                if (doCast(target, PW_SHIELD))
+                {
+                    if (me->getLevel() >= 30 || // improved
+                        (target->ToCreature() && target->ToCreature()->GetIAmABot()))
+                        PWS_Timer = 0;
+                    else
+                        PWS_Timer = 4000;
+                    GC_Timer = 800;
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            GetInPosition(force, true);
+            SetBotCommandState(COMMAND_ATTACK);
+        }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit*) { master->SetNpcBotDied(me->GetGUID()); }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (IAmDead()) return;
+            if (!me->GetVictim())
+                Evade();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            CheckAuras();
+            Disperse(diff);
+            BreakCC(diff);
+            if (CCed(me)) return;
+            DoDevCheck(diff);
+
+            if (GetManaPCT(me) < 33 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, MANAPOTION))
+                    Potion_cd = POTION_CD;
+                GC_Timer = temptimer;
+            }
+            //check possible fear
+            doDefend(diff);
+            //buff and heal master's group
+            MassGroupHeal(master, diff);
+            BuffAndHealGroup(master, diff);
+            CureGroup(master, DISPELMAGIC, diff);
+            CureGroup(master, CURE_DISEASE, diff);
+            //ShieldGroup(master);
+            if (master->IsInCombat() || me->IsInCombat())
+            {
+                CheckDispel(diff);
+                CheckSilence(diff);
+            }
+
+            if (me->IsInCombat())
+                CheckShackles(diff);
+            else
+                DoNonCombatActions(diff);
+
+            if (!CheckAttackTarget(CLASS_PRIEST))
+                return;
+
+            AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+
+            if (GetHealthPCT(master) > 90 && GetManaPCT(me) > 35 && GetHealthPCT(me) > 90 && 
+                (m_attackers.size() < 4 || b_attackers.size() + m_attackers.size() < 3) && 
+                !IsCasting())
+                //general rule
+            {
+                opponent = me->GetVictim();
+                if (opponent)
+                {
+                    if (!IsCasting())
+                        StartAttack(opponent);
+                }
+                else
+                    return;
+                bool isBoss = opponent->GetTypeId() == TYPEID_UNIT ? opponent->ToCreature()->isWorldBoss() : false;
+                if (me->GetExactDist(opponent) < 30)
+                {
+                    if (SW_DEATH && Rand() < 50 && SW_Death_Timer <= diff && 
+                        (GetHealthPCT(opponent) < 15 || opponent->GetHealth() < me->GetMaxHealth()/6) && 
+                        doCast(opponent, SW_DEATH))
+                    {
+                        SW_Death_Timer = 10000;
+                        return;
+                    }
+                    if (Rand() < 30 && GC_Timer <= diff && !opponent->HasAura(SW_PAIN, me->GetGUID()) && 
+                        opponent->GetHealth() > me->GetMaxHealth()/4 && 
+                        doCast(opponent, SW_PAIN))
+                        return;
+                    if (VAMPIRIC_TOUCH && GC_Timer <= diff && !isBoss && Rand() < 50 && !opponent->HasAura(VAMPIRIC_TOUCH, me->GetGUID()) && 
+                        opponent->GetHealth() > me->GetMaxHealth()/4 && 
+                        doCast(opponent, VAMPIRIC_TOUCH))
+                        return;
+                    if (DEVOURING_PLAGUE && GC_Timer <= diff && !isBoss && Rand() < 30 && !Devcheck && !opponent->HasAura(DEVOURING_PLAGUE, me->GetGUID()) && 
+                        opponent->GetHealth() > me->GetMaxHealth()/3 && 
+                        doCast(opponent, DEVOURING_PLAGUE))
+                        return;
+                    if (Mind_Blast_Timer <= diff && GC_Timer <= 300 && !isBoss && Rand() < 50 && (!VAMPIRIC_TOUCH || HasAuraName(opponent, VAMPIRIC_TOUCH)) && 
+                        doCast(opponent, MIND_BLAST))
+                    {
+                        Mind_Blast_Timer = 7500 - me->getLevel()/4*100;//5.5 sec on 80 lvl (as improved)
+                        return;
+                    }
+                    if (MIND_FLAY && Mind_Flay_Timer <= diff && GC_Timer <= 300 && !isBoss && !me->isMoving() && Rand() < 40 && me->GetExactDist(opponent) < 30 && 
+                        
+                        (opponent->isMoving() || opponent->GetHealth() < me->GetMaxHealth()/3 || 
+                        (opponent->HasAura(SW_PAIN, me->GetGUID()) && 
+                        opponent->HasAura(DEVOURING_PLAGUE, me->GetGUID()))) && 
+                        doCast(opponent, MIND_FLAY))
+                    {
+                        Mind_Flay_Timer = 3000;
+                        return;
+                    }
+                    if (MIND_SEAR && GC_Timer <= diff && !me->isMoving() && !opponent->isMoving() && Rand() < 50 && 
+                        opponent->HasAura(SW_PAIN, me->GetGUID()) && 
+                        opponent->HasAura(DEVOURING_PLAGUE, me->GetGUID()))
+                        if (Unit* u = FindSplashTarget(30, opponent))
+                            if (doCast(u, MIND_SEAR))
+                                return;
+                }//endif opponent
+            }//endif damage
+            //check horror after dots/damage
+            if (PSYCHIC_HORROR && Psychic_Horror_Timer <= diff && Rand() < 30 && 
+                opponent->GetCreatureType() != CREATURE_TYPE_UNDEAD && 
+                opponent->GetHealth() > me->GetMaxHealth()/5 && 
+                me->GetExactDist(opponent) < 30 && !HasAuraName(opponent, PSYCHIC_HORROR) && 
+                !CCed(opponent))
+            {
+                if (doCast(opponent, PSYCHIC_HORROR))
+                {
+                    Psychic_Horror_Timer = 60000;
+                    return;
+                }
+            }
+        }//end UpdateAI
+
+        bool HealTarget(Unit* target, uint8 hp, uint32 diff)
+        {
+            if (hp > 98) return false;
+            if (!target || target->isDead() || me->GetExactDist(target) > 40)
+                return false;
+            if (Rand() > 50 + 20*target->IsInCombat() + 50*master->GetMap()->IsRaid()) return false;
+
+            //GUARDIAN SPIRIT
+            if (GUARDIAN_SPIRIT && Guardian_Spirit_Timer <= diff && Rand() < 70 && 
+                target->IsInCombat() && !target->getAttackers().empty() && 
+                hp < (5 + std::min(20, uint8(target->getAttackers().size())*5)) && 
+                (master->GetGroup() && master->GetGroup()->IsMember(target->GetGUID()) || target == master) && 
+                !target->HasAura(GUARDIAN_SPIRIT))
+            {
+                temptimer = GC_Timer;
+                if (me->IsNonMeleeSpellCasted(true))
+                    me->InterruptNonMeleeSpells(true);
+                if (doCast(target, GUARDIAN_SPIRIT))
+                {
+                    if (target->GetTypeId() == TYPEID_PLAYER)
+                    {
+                        if (target->HasAura(GUARDIAN_SPIRIT, me->GetGUID()))
+                            me->MonsterWhisper("Guardin Spirit on you!", target->GetGUID());
+                        Guardian_Spirit_Timer = 90000;//1.5 min
+                    }
+                    else
+                        Guardian_Spirit_Timer = 30000;//30 sec for creatures
+                    GC_Timer = temptimer;
+                    return true;
+                }
+            }
+
+            if (IsCasting()) return false;
+
+            //PAIN SUPPRESSION
+            if (hp < 35 && PAIN_SUPPRESSION && Pain_Suppression_Timer <= diff && Rand() < 50 && 
+                (target->IsInCombat() || !target->getAttackers().empty()) && 
+                !target->HasAura(PAIN_SUPPRESSION))
+            {
+                temptimer = GC_Timer;
+                if (doCast(target, PAIN_SUPPRESSION))
+                {
+                    if (target->GetTypeId() == TYPEID_PLAYER)
+                    {
+                        if (target->HasAura(PAIN_SUPPRESSION, me->GetGUID()))
+                            me->MonsterWhisper("Pain Suppression on you!", target->GetGUID());
+                        Pain_Suppression_Timer = 45000;//45 sec
+                    }
+                    else
+                        Pain_Suppression_Timer = 15000;//15 sec for creatures
+                    GC_Timer = temptimer;
+                    return true;
+                }
+            }
+
+            //Now Heals Requires GCD
+            if ((hp < 80 || !target->getAttackers().empty()) && 
+                PWS_Timer <= diff && ShieldTarget(target, diff))
+                return true;
+
+            //PENANCE/Greater Heal
+            if (hp < 75 || GetLostHP(target) > 4000)
+            {
+                if (PENANCE && Penance_Timer <= diff && 
+                    !me->isMoving() && //better check then stop moving every try (furthermore it doesn't always work properly)
+                    (target->GetTypeId() != TYPEID_PLAYER || !(target->ToPlayer()->IsCharmed() || target->ToPlayer()->isPossessed())) && 
+                    doCast(target, PENANCE))
+                {
+                    Penance_Timer = 8000;
+                    return true;
+                }
+                else if (Heal_Timer <= diff && GC_Timer <= diff && hp > 50 && doCast(target, HEAL))
+                {
+                    Heal_Timer = 2500;
+                    return true;
+                }
+            }
+            //Flash Heal
+            if (((hp > 75 && hp < 90) || hp < 50 || GetLostHP(target) > 1500) && 
+                GC_Timer <= diff && FLASH_HEAL && 
+                doCast(target, FLASH_HEAL))
+                    return true;
+            //maintain HoTs
+            Unit* u = target->GetVictim();
+            Creature* boss = u && u->ToCreature() && u->ToCreature()->isWorldBoss() ? u->ToCreature() : NULL;
+            bool tanking = tank == target && boss;
+            //Renew
+            if (((hp < 98 && hp > 70) || GetLostHP(target) > 500 || tanking) && 
+                !HasAuraName(target, RENEW, me->GetGUID()) && 
+                GC_Timer <= diff && doCast(target, RENEW))
+            {
+                GC_Timer = 800;
+                return true;
+            }
+
+            return false;
+        }
+
+        bool BuffTarget(Unit* target, uint32 diff)
+        {
+            if (GC_Timer > diff || Rand() > 60) return false;
+            if (!target || target->isDead() || me->GetExactDist(target) > 30) return false;
+
+            if (Fear_Ward_Timer <= diff && !HasAuraName(target, FEAR_WARD) && doCast(target, FEAR_WARD))
+            {
+                Fear_Ward_Timer = target->GetTypeId() == TYPEID_PLAYER ? 60000 : 30000;//30sec for bots
+                GC_Timer = 800;
+                return true;
+            }
+
+            if (target == me)
+            {
+                if (!me->HasAura(INNER_FIRE) && doCast(me, INNER_FIRE))
+                {
+                    GC_Timer = 800;
+                    return true;
+                }
+                if (VAMPIRIC_EMBRACE && !me->HasAura(VAMPIRIC_EMBRACE) && doCast(me, VAMPIRIC_EMBRACE))
+                {
+                    GC_Timer = 800;
+                    return true;
+                }
+            }
+
+            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
+
+            if (Rand() < 70 && !HasAuraName(target, PW_FORTITUDE) && doCast(target, PW_FORTITUDE))
+            {
+                /*GC_Timer = 800;*/
+                return true;
+            }
+            if (Rand() < 30 && !HasAuraName(target, SHADOW_PROTECTION) && doCast(target, SHADOW_PROTECTION))
+            {
+                /*GC_Timer = 800;*/
+                return true;
+            }
+            if (Rand() < 30 && !HasAuraName(target, DIVINE_SPIRIT) && doCast(target, DIVINE_SPIRIT))
+            {
+                /*GC_Timer = 800;*/
+                return true;
+            }
+            return false;
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (Rand() > 50 || GC_Timer > diff || me->IsMounted()) return;
+
+            RezGroup(RESURRECTION, master);
+
+            if (Feasting()) return;
+
+            if (BuffTarget(master, diff))
+                return;
+            if (BuffTarget(me, diff))
+                return;
+        }
+
+        void CheckDispel(uint32 diff)
+        {
+            if (CheckDispelTimer > diff || Rand() > 25 || IsCasting())
+                return;
+            Unit* target = FindHostileDispelTarget();
+            if (target && doCast(target, DISPELMAGIC))
+            {
+                CheckDispelTimer = 3000;
+                GC_Timer = 500;
+            }
+            CheckDispelTimer = 1000;
+        }
+
+        void CheckShackles(uint32 diff)
+        {
+            if (!SHACKLE_UNDEAD || ShackleTimer > diff || GC_Timer > diff || IsCasting())
+                return;
+            if (FindAffectedTarget(SHACKLE_UNDEAD, me->GetGUID()))
+                return;
+            Unit* target = FindUndeadCCTarget(30, SHACKLE_UNDEAD);
+            if (target && doCast(target, SHACKLE_UNDEAD))
+            {
+                ShackleTimer = 3000;
+                GC_Timer = 800;
+            }
+        }
+
+        void CheckSilence(uint32 diff)
+        {
+            if (IsCasting()) return;
+            temptimer = GC_Timer;
+            if (SILENCE && Silence_Timer <= diff)
+            {
+                if (Unit* target = FindCastingTarget(30))
+                    if (doCast(target, SILENCE))
+                        Silence_Timer = 30000;
+            }
+            else if (PSYCHIC_HORROR && Psychic_Horror_Timer <= 20000)
+            {
+                if (Unit* target = FindCastingTarget(30))
+                    if (doCast(target, PSYCHIC_HORROR))
+                        Psychic_Horror_Timer = 60000;
+            }
+            GC_Timer = temptimer;
+        }
+
+        void doDefend(uint32 diff)
+        {
+            AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+            //fear master's attackers
+            if (!m_attackers.empty() && PSYCHIC_SCREAM && Fear_Timer <= diff && 
+                (master != tank || GetHealthPCT(master) < 75))
+            {
+                uint8 tCount = 0;
+                for (AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+                {
+                    if (!(*iter)) continue;
+                    if ((*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                    if (me->GetExactDist((*iter)) > 7) continue;
+                    if (CCed(*iter) && me->GetExactDist((*iter)) > 5) continue;
+                    if (me->IsValidAttackTarget(*iter))
+                        ++tCount;
+                }
+                if (tCount > 1 && doCast(me, PSYCHIC_SCREAM))
+                {
+                    Fear_Timer = 24000;//with improved 24 sec
+                    return;
+                }
+            }
+
+            // Defend myself (psychic horror)
+            if (!b_attackers.empty() && PSYCHIC_SCREAM && Fear_Timer <= diff)
+            {
+                uint8 tCount = 0;
+                for (AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                {
+                    if (!(*iter)) continue;
+                    if ((*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                    if (me->GetExactDist((*iter)) > 7) continue;
+                    if (CCed(*iter) && me->GetExactDist((*iter)) > 5) continue;
+                    if (me->IsValidAttackTarget(*iter))
+                        ++tCount;
+                }
+                if (tCount > 0 && doCast(me, PSYCHIC_SCREAM))
+                {
+                    Fear_Timer = 24000;//with improved 24 sec
+                    return;
+                }
+            }
+            // Heal myself
+            if (GetHealthPCT(me) < 99 && !b_attackers.empty())
+            {
+                if (ShieldTarget(me, diff)) return;
+
+                if (FADE && Fade_Timer <= diff && me->IsInCombat())
+                {
+                    if (b_attackers.empty()) return; //no aggro
+                    uint8 Tattackers = 0;
+                    for (AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->isDead()) continue;
+                        if (!(*iter)->ToCreature()) continue;
+                        if (!(*iter)->CanHaveThreatList()) continue;
+                        if (me->GetExactDist((*iter)) <= 15)
+                            Tattackers++;
+                    }
+                    if (Tattackers > 0)
+                    {
+                        temptimer = GC_Timer;
+                        if (doCast(me, FADE))
+                        {
+                            for (AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                                if ((*iter)->getThreatManager().getThreat(me) > 0.f)
+                                    (*iter)->getThreatManager().modifyThreatPercent(me, -50);
+                            Fade_Timer = 6000;
+                            GC_Timer = temptimer;
+                            return;
+                        }
+                    }
+                }
+                if (GetHealthPCT(me) < 90 && HealTarget(me, GetHealthPCT(me), diff))
+                    return;
+            }
+        }
+
+        void DoDevCheck(uint32 diff)
+        {
+            if (DevcheckTimer <= diff)
+            {
+                Devcheck = FindAffectedTarget(DEVOURING_PLAGUE, me->GetGUID());
+                DevcheckTimer = 5000;
+            }
+        }
+
+        void Disperse(uint32 diff)
+        {
+            if (!DISPERSION || GC_Timer > diff || Dispersion_Timer > diff || IsCasting()) return;
+            //attackers case
+            if ((me->getAttackers().size() > 3 && Fade_Timer > diff && GetHealthPCT(me) < 90) || 
+                (GetHealthPCT(me) < 20 && me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)) || 
+                (GetManaPCT(me) < 30) || 
+                (me->getAttackers().size() > 1 && me->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT))))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, DISPERSION))
+                    Dispersion_Timer = 75000;//with glyph
+                GC_Timer = temptimer;
+                return;
+            }
+            Dispersion_Timer = 2000;//fail
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            Heal_Timer = 0;
+            Divine_Hymn_Timer = 0;
+            Pain_Suppression_Timer = 0;
+            Guardian_Spirit_Timer = 0;
+            PWS_Timer = 0;
+            Fade_Timer = 0;
+            Fear_Timer = 0;
+            Mind_Blast_Timer = 0;
+            SW_Death_Timer = 0;
+            Fear_Ward_Timer = 0;
+            Psychic_Horror_Timer = 0;
+            Silence_Timer = 0;
+            Dispersion_Timer = 0;
+            Mind_Flay_Timer = 0;
+            Penance_Timer = 0;
+            CheckDispelTimer = 0;
+            ShackleTimer = 0;
+            DevcheckTimer = 20;
+            Devcheck = false;
+
+            if (master)
+            {
+                setStats(CLASS_PRIEST, me->getRace(), master->getLevel(), true);
+                ApplyClassPassives();
+                ApplyPassives(CLASS_PRIEST);
+            }
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            CommonTimers(diff);
+            if (Heal_Timer > diff)                 Heal_Timer -= diff;
+            if (Fade_Timer > diff)                 Fade_Timer -= diff;
+            if (Divine_Hymn_Timer > diff)          Divine_Hymn_Timer -= diff;
+            if (Pain_Suppression_Timer > diff)     Pain_Suppression_Timer -= diff;
+            if (Guardian_Spirit_Timer > diff)      Guardian_Spirit_Timer -= diff;
+            if (PWS_Timer > diff)                  PWS_Timer -= diff;
+            if (Fear_Timer > diff)                 Fear_Timer -= diff;
+            if (Mind_Blast_Timer > diff)           Mind_Blast_Timer -= diff;
+            if (SW_Death_Timer > diff)             SW_Death_Timer -= diff;
+            if (Fear_Ward_Timer > diff)            Fear_Ward_Timer -= diff;
+            if (Psychic_Horror_Timer > diff)       Psychic_Horror_Timer -= diff;
+            if (Silence_Timer > diff)              Silence_Timer -= diff;
+            if (Dispersion_Timer > diff)           Dispersion_Timer -= diff;
+            if (Mind_Flay_Timer > diff)            Mind_Flay_Timer -= diff;
+            if (Penance_Timer > diff)              Penance_Timer -= diff;
+            if (CheckDispelTimer > diff)           CheckDispelTimer -= diff;
+            if (ShackleTimer > diff)               ShackleTimer -= diff;
+            if (DevcheckTimer > diff)              DevcheckTimer -= diff;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            DISPELMAGIC                = lvl >= 70 ? MASS_DISPEL_1 : InitSpell(me, DISPEL_MAGIC_1);
+            CURE_DISEASE                            = InitSpell(me, CURE_DISEASE_1);
+            FEAR_WARD                               = InitSpell(me, FEAR_WARD_1);
+  /*Talent*/PAIN_SUPPRESSION            = lvl >= 50 ? PAIN_SUPPRESSION_1 : 0;
+            PSYCHIC_SCREAM                          = InitSpell(me, PSYCHIC_SCREAM_1);
+            FADE                                    = InitSpell(me, FADE_1);
+  /*Talent*/PSYCHIC_HORROR              = lvl >= 50 ? PSYCHIC_HORROR_1 : 0;
+  /*Talent*/SILENCE                     = lvl >= 30 ? SILENCE_1 : 0;
+  /*Talent*/PENANCE                     = lvl >= 60 ? InitSpell(me, PENANCE_1) : 0;
+  /*Talent*/VAMPIRIC_EMBRACE            = lvl >= 30 ? VAMPIRIC_EMBRACE_1 : 0;
+  /*Talent*/DISPERSION                  = lvl >= 60 ? DISPERSION_1 : 0;
+            MIND_SEAR                               = InitSpell(me, MIND_SEAR_1);
+  /*Talent*/GUARDIAN_SPIRIT             = lvl >= 60 ? GUARDIAN_SPIRIT_1 : 0;
+            SHACKLE_UNDEAD                          = InitSpell(me, SHACKLE_UNDEAD_1);
+            HEAL                        = lvl >= 40 ? InitSpell(me, GREATER_HEAL_1) : lvl >= 16 ? InitSpell(me, NORMAL_HEAL_1) : InitSpell(me, LESSER_HEAL_1);
+            RENEW                                   = InitSpell(me, RENEW_1);
+            FLASH_HEAL                              = InitSpell(me, FLASH_HEAL_1);
+            PRAYER_OF_HEALING                       = InitSpell(me, PRAYER_OF_HEALING_1);
+            DIVINE_HYMN                             = InitSpell(me, DIVINE_HYMN_1);
+            RESURRECTION                            = InitSpell(me, RESURRECTION_1);
+            PW_SHIELD                               = InitSpell(me, PW_SHIELD_1);
+            INNER_FIRE                              = InitSpell(me, INNER_FIRE_1);
+            PW_FORTITUDE                            = InitSpell(me, PW_FORTITUDE_1);
+            SHADOW_PROTECTION                       = InitSpell(me, SHADOW_PROTECTION_1);
+            DIVINE_SPIRIT                           = InitSpell(me, DIVINE_SPIRIT_1);
+            SW_PAIN                                 = InitSpell(me, SW_PAIN_1);
+            MIND_BLAST                              = InitSpell(me, MIND_BLAST_1);
+            SW_DEATH                                = InitSpell(me, SW_DEATH_1);
+            DEVOURING_PLAGUE                        = InitSpell(me, DEVOURING_PLAGUE_1);
+  /*Talent*/MIND_FLAY                   = lvl >= 20 ? InitSpell(me, MIND_FLAY_1) : 0;
+  /*Talent*/VAMPIRIC_TOUCH              = lvl >= 50 ? InitSpell(me, VAMPIRIC_TOUCH_1) : 0;
+        }
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+            if (level >= 65)
+                RefreshAura(BORROWED_TIME); //25%haste/40%bonus
+            if (level >= 55)
+                RefreshAura(DIVINE_AEGIS); //30%
+            if (level >= 55)
+                RefreshAura(EMPOWERED_RENEW3); //15%
+            else if (level >= 50)
+                RefreshAura(EMPOWERED_RENEW2); //10%
+            else if (level >= 45)
+                RefreshAura(EMPOWERED_RENEW1); //5%
+            if (level >= 45)
+                RefreshAura(BODY_AND_SOUL1); //30%
+            if (level >= 50)
+                RefreshAura(PAINANDSUFFERING3); //100%
+            else if (level >= 48)
+                RefreshAura(PAINANDSUFFERING2); //66%
+            else if (level >= 45)
+                RefreshAura(PAINANDSUFFERING1); //33%
+            if (level >= 50)
+                RefreshAura(MISERY3); //3%
+            else if (level >= 48)
+                RefreshAura(MISERY2); //2%
+            else if (level >= 45)
+                RefreshAura(MISERY1); //1%
+            if (level >= 45)
+                RefreshAura(GRACE); //100%
+            if (level >= 35)
+                RefreshAura(IMP_DEV_PLAG); //30%
+            if (level >= 25)
+                RefreshAura(INSPIRATION3); //10%
+            else if (level >= 23)
+                RefreshAura(INSPIRATION2); //6%
+            else if (level >= 20)
+                RefreshAura(INSPIRATION1); //3%
+            if (level >= 30)
+                RefreshAura(SHADOW_WEAVING3); //100%
+            else if (level >= 28)
+                RefreshAura(SHADOW_WEAVING2); //66%
+            else if (level >= 25)
+                RefreshAura(SHADOW_WEAVING1); //33%
+            if (level >= 15)
+            {
+                RefreshAura(GLYPH_SW_PAIN);
+                RefreshAura(GLYPH_PW_SHIELD); //20% heal
+            }
+            if (level >= 40)
+                RefreshAura(SHADOWFORM); //allows dots to crit, passive
+            if (level >= 70)
+                RefreshAura(PRIEST_T10_2P_BONUS);
+        }
+
+    private:
+        uint32
+   /*Buffs*/INNER_FIRE, PW_FORTITUDE, DIVINE_SPIRIT, SHADOW_PROTECTION,
+    /*Disc*/FEAR_WARD, PAIN_SUPPRESSION, SHACKLE_UNDEAD, PW_SHIELD, DISPELMAGIC, CURE_DISEASE, PENANCE,
+    /*Holy*/HEAL, FLASH_HEAL, RENEW, PRAYER_OF_HEALING, DIVINE_HYMN, GUARDIAN_SPIRIT, RESURRECTION,
+  /*Shadow*/SW_PAIN, MIND_BLAST, SW_DEATH, DEVOURING_PLAGUE, MIND_FLAY, VAMPIRIC_TOUCH,
+  /*Shadow*/PSYCHIC_SCREAM, FADE, PSYCHIC_HORROR, VAMPIRIC_EMBRACE, DISPERSION, MIND_SEAR, SILENCE;
+        //Timers/other
+/*Disc*/uint32 Penance_Timer, PWS_Timer, Pain_Suppression_Timer, Fear_Ward_Timer;
+/*Holy*/uint32 Heal_Timer, Divine_Hymn_Timer, Guardian_Spirit_Timer;
+/*Shdw*/uint32 Fade_Timer, Fear_Timer, Mind_Blast_Timer, SW_Death_Timer, Mind_Flay_Timer,
+/*Shdw*/    Psychic_Horror_Timer, Silence_Timer, Dispersion_Timer;
+/*Misc*/uint16 CheckDispelTimer, ShackleTimer, DevcheckTimer;
+/*Misc*/bool Devcheck;
+
+        enum PriestBaseSpells
+        {
+            DISPEL_MAGIC_1                      = 527,
+            MASS_DISPEL_1                       = 32375,
+            CURE_DISEASE_1                      = 528,
+            FEAR_WARD_1                         = 6346,
+  /*Talent*/PAIN_SUPPRESSION_1                  = 33206,
+            PSYCHIC_SCREAM_1                    = 8122,
+            FADE_1                              = 586,
+  /*Talent*/PSYCHIC_HORROR_1                    = 64044,
+  /*Talent*/SILENCE_1                           = 15487,
+  /*Talent*/PENANCE_1                           = 47540,
+  /*Talent*/VAMPIRIC_EMBRACE_1                  = 15286,
+  /*Talent*/DISPERSION_1                        = 47585,
+            MIND_SEAR_1                         = 48045,
+  /*Talent*/GUARDIAN_SPIRIT_1                   = 47788,
+            SHACKLE_UNDEAD_1                    = 9484,
+            LESSER_HEAL_1                       = 2050,
+            NORMAL_HEAL_1                       = 2054,
+            GREATER_HEAL_1                      = 2060,
+            RENEW_1                             = 139,
+            FLASH_HEAL_1                        = 2061,
+            PRAYER_OF_HEALING_1                 = 596,
+            DIVINE_HYMN_1                       = 64843,
+            RESURRECTION_1                      = 2006,
+            PW_SHIELD_1                         = 17,
+            INNER_FIRE_1                        = 588,
+            PW_FORTITUDE_1                      = 1243,
+            SHADOW_PROTECTION_1                 = 976,
+            DIVINE_SPIRIT_1                     = 14752,
+            SW_PAIN_1                           = 589,
+            MIND_BLAST_1                        = 8092,
+            SW_DEATH_1                          = 32379,
+            DEVOURING_PLAGUE_1                  = 2944,
+  /*Talent*/MIND_FLAY_1                         = 15407,
+  /*Talent*/VAMPIRIC_TOUCH_1                    = 34914,
+        };
+        enum PriestPassives
+        {
+            SHADOWFORM  /*For DOT crits*/   = 49868,
+        //Talents
+            IMP_DEV_PLAG                    = 63627,//rank 3
+            MISERY1                         = 33191,
+            MISERY2                         = 33192,
+            MISERY3                         = 33193,
+            PAINANDSUFFERING1               = 47580,
+            PAINANDSUFFERING2               = 47581,
+            PAINANDSUFFERING3               = 47582,
+            SHADOW_WEAVING1                 = 15257,
+            SHADOW_WEAVING2                 = 15331,
+            SHADOW_WEAVING3                 = 15332,
+            DIVINE_AEGIS                    = 47515,//rank 3
+            BORROWED_TIME                   = 52800,//rank 5
+            GRACE                           = 47517,//rank 2
+            EMPOWERED_RENEW1                = 63534,
+            EMPOWERED_RENEW2                = 63542,
+            EMPOWERED_RENEW3                = 63543,
+            INSPIRATION1                    = 14892,
+            INSPIRATION2                    = 15362,
+            INSPIRATION3                    = 15363,
+            BODY_AND_SOUL1                  = 64127,
+        //Glyphs
+            GLYPH_SW_PAIN                   = 55681,
+            GLYPH_PW_SHIELD                 = 55672,
+        //other
+            PRIEST_T10_2P_BONUS             = 70770,//33% renew
+        };
+        enum PriestSpecial
+        {
+            WEAKENED_SOUL                   = 6788,
+        };
+    }; //end priest_bot
+};
+
+void AddSC_priest_bot()
+{
+    new priest_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_rogue_ai.cpp b/src/server/game/AI/NpcBots/bot_rogue_ai.cpp
new file mode 100644
index 0000000..7f4240d
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_rogue_ai.cpp
@@ -0,0 +1,904 @@
+#include "bot_ai.h"
+//#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+/*
+Rogue NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - 25% maybe...
+TODO:
+*/
+
+class rogue_bot : public CreatureScript
+{
+public:
+    rogue_bot() : CreatureScript("rogue_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new rogue_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    struct rogue_botAI : public bot_minion_ai
+    {
+        rogue_botAI(Creature* creature) : bot_minion_ai(creature)
+        {
+            Reset();
+        }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (checkBotCast(victim, spellId, CLASS_ROGUE) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            GetInPosition(force, false);
+        }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit*) { comboPoints = 0; tempComboPoints = 0; master->SetNpcBotDied(me->GetGUID()); }
+        void DoNonCombatActions(uint32 /*diff*/)
+        {}
+
+        //This method should be used to emulate energy usage reduction
+        void modenergy(int32 mod, bool set = false)
+        {
+            //can't set enery to -x (2 cases)
+            if (set && mod < 0)
+                return;
+            if (mod < 0 && energy < uint32(abs(mod)))
+            {
+                mod = 0;
+                set = true;
+            }
+
+            if (set)
+                energy = mod;
+            else
+                energy += mod;
+
+            energy = std::min<uint32>(energy, 100);
+            me->SetPower(POWER_ENERGY, energy);
+        }
+
+        uint32 getenergy()
+        {
+            energy = me->GetPower(POWER_ENERGY);
+            return energy;
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (KidneyTarget)
+            {
+                //tempComboPoints -= 1;
+                if (tempComboPoints)
+                {
+                    if (Unit* u = sObjectAccessor->FindUnit(KidneyTarget))
+                    {
+                        if (Aura* kidney = u->GetAura(KIDNEY_SHOT, me->GetGUID()))
+                        {
+                            uint32 dur = kidney->GetDuration() + tempComboPoints*1000;
+                            kidney->SetDuration(dur);
+                            kidney->SetMaxDuration(dur);
+                        }
+                    }
+                    else //spell is failed to hit: restore cp
+                    {
+                        if (comboPoints == 0)
+                            comboPoints = tempComboPoints;
+                    }
+                    tempComboPoints = 0;
+                }
+                KidneyTarget = 0;
+            }
+            else if (RuptureTarget)
+            {
+                //tempComboPoints -= 1;
+                if (tempComboPoints)
+                {
+                    if (Unit* u = sObjectAccessor->FindUnit(RuptureTarget))
+                    {
+                        if (Aura* rupture = u->GetAura(RUPTURE, me->GetGUID()))
+                        {
+                            uint32 dur = rupture->GetDuration() + tempComboPoints*2000; //use cp
+                            dur += 4000; //Glyph of Rupture
+                            rupture->SetDuration(dur);
+                            rupture->SetMaxDuration(dur);
+                        }
+                    }
+                    else //spell is failed to hit: restore cp
+                    {
+                        if (comboPoints == 0)
+                            comboPoints = tempComboPoints;
+                    }
+                    tempComboPoints = 0;
+                }
+                RuptureTarget = 0;
+            }
+            else if (tempDICE)
+            {
+                //tempComboPoints -= 1;
+                if (tempComboPoints)
+                {
+                    if (Aura* dice = me->GetAura(SLICE_DICE))
+                    {
+                        uint32 dur = dice->GetDuration();
+                        dur += tempComboPoints * 3000; //use cp
+                        dur += 6000; // Glyph of Slice and Dice
+                        dur = (dur * 3) / 2; //Improved Slice and Dice
+                        dice->SetDuration(dur);
+                        dice->SetMaxDuration(dur);
+                    }
+                    tempComboPoints = 0;
+                }
+                tempDICE = false;
+            }
+            if (IAmDead()) return;
+            if (me->GetVictim())
+                DoMeleeAttackIfReady();
+            else
+                Evade();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            if (checkAurasTimer == 0)
+                CheckAuras();
+            BreakCC(diff);
+            if (CCed(me)) return;
+
+            if (GetHealthPCT(me) < 67 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, HEALINGPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            if (!CheckAttackTarget(CLASS_ROGUE))
+                return;
+
+            Attack(diff);
+        }
+
+        void Attack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent, true);
+            }
+            else
+                return;
+
+            comboPoints = std::min<uint8>(comboPoints, 5);
+            //AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+            float dist = me->GetExactDist(opponent);
+            float meleedist = me->GetDistance(opponent);
+
+            //Blade Flurry (434 deprecated)
+            if (BLADE_FLURRY && Blade_Flurry_Timer <= diff && meleedist <= 5 &&
+                Rand() < 30 && FindSplashTarget(7, opponent))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, BLADE_FLURRY))
+                {
+                    Blade_Flurry_Timer = 75000;
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            if (MoveBehind(*opponent))
+                wait = 5;
+
+            //KICK
+            if (KICK && Kick_Timer <= diff && meleedist <= 5 && Rand() < 80 && getenergy() >= 15 &&
+                opponent->IsNonMeleeSpellCasted(false))
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, KICK))
+                {
+                    Kick_Timer = 8000; //improved
+                    GC_Timer = temptimer;
+                    //return;
+                }
+            }
+            //SHADOWSTEP
+            if (SHADOWSTEP && Shadowstep_Timer <= diff && dist < 25 &&
+                (opponent->GetVictim() != me || opponent->GetTypeId() == TYPEID_PLAYER) &&
+                Rand() < 30 && getenergy() >= 10)
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, SHADOWSTEP))
+                {
+                    Shadowstep_Timer = 20000;
+                    GC_Timer = temptimer;
+                    //return;
+                }
+            }
+            //BACKSTAB
+            if (BACKSTAB && GC_Timer <= diff && meleedist <= 5 && comboPoints < 4 &&
+                /*Rand() < 90 && */getenergy() >= 60 && !opponent->HasInArc(M_PI, me))
+            {
+                if (doCast(opponent, BACKSTAB))
+                    return;
+            }
+            //SINISTER STRIKE
+            if (SINISTER_STRIKE && GC_Timer <= diff && meleedist <= 5 && comboPoints < 5 &&
+                Rand() < 25 && getenergy() >= 45)
+            {
+                if (doCast(opponent, SINISTER_STRIKE))
+                    return;
+            }
+            //SLICE AND DICE
+            if (SLICE_DICE && Slice_Dice_Timer <= diff && GC_Timer <= diff && dist < 20 && comboPoints > 1 &&
+                (b_attackers.size() <= 1 || Blade_Flurry_Timer > 60000) && Rand() < 30 && getenergy() >= 25)
+            {
+                if (doCast(opponent, SLICE_DICE))
+                    return;
+            }
+            //KIDNEY SHOT
+            if (KIDNEY_SHOT && GC_Timer <= diff && Kidney_Timer <= diff && meleedist <= 5 && comboPoints > 0 &&
+                !CCed(opponent) && getenergy() >= 25 && ((Rand() < 15 + comboPoints*15 && opponent->GetVictim() == me && comboPoints > 2) || opponent->IsNonMeleeSpellCasted(false)))
+            {
+                if (doCast(opponent, KIDNEY_SHOT))
+                {
+                    KidneyTarget = opponent->GetGUID();
+                    tempComboPoints = comboPoints;
+                    Kidney_Timer = 20000;
+                    return;
+                }
+            }
+            //EVISCERATE
+            if (EVISCERATE && GC_Timer <= diff && meleedist <= 5 && comboPoints > 2 &&
+                getenergy() >= 35 && Rand() < comboPoints*15)
+            {
+                if (doCast(opponent, EVISCERATE))
+                    return;
+            }
+            //MUTILATE
+            //if (isTimerReady(Mutilate_Timer) && energy>60) 
+            //{
+            //    // TODO: calculate correct dmg for mutilate (dont forget poison bonus)
+            //    // for now use same formula as evicerate
+            //    uint32 base_attPower = me->GetUInt32Value(UNIT_FIELD_ATTACK_POWER);
+            //    //float minDmg = me->GetFloatValue(UNIT_FIELD_MINDAMAGE);
+            //    float minDmg = me->GetWeaponDamageRange(BASE_ATTACK, MINDAMAGE);
+            //    int damage = irand(int32(base_attPower*7*0.03f),int32(base_attPower*7*0.08f))+minDmg+me->getLevel();
+
+            //    // compensate for lack of attack power
+            //    damage = damage*(rand()%4+1);
+
+            //    me->CastCustomSpell(opponent, MUTILATE, &damage, NULL, NULL, false, NULL, NULL);
+
+            //    //doCast (me, MUTILATE);
+            //    Mutilate_Timer = 10;
+            //    comboPoints+=3;
+            //    energy -= 60;
+            //}
+
+            //RUPTURE
+            if (RUPTURE && Rupture_Timer <= diff && GC_Timer <= diff && meleedist <= 5 && comboPoints > 3 &&
+                /*opponent->GetHealth() > me->GetMaxHealth()/3 && */getenergy() >= 25 && Rand() < (50 + 70 * opponent->isMoving()))
+            {
+                if (doCast(opponent, RUPTURE))
+                    return;
+            }
+            //DISMANTLE
+            if (DISMANTLE && Dismantle_Timer <= diff && meleedist <= 5 && opponent->GetTypeId() == TYPEID_PLAYER &&
+                Rand() < 20 && getenergy() >= 25 && !CCed(opponent) && !opponent->HasAuraType(SPELL_AURA_MOD_DISARM) &&
+                (opponent->ToPlayer()->GetWeaponForAttack(BASE_ATTACK) || opponent->ToPlayer()->GetWeaponForAttack(RANGED_ATTACK)))
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, DISMANTLE))
+                {
+                    Dismantle_Timer = 60000;
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+        }
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //Puncturing Wounds: 30% additional critical chance for Backstab
+                if (lvl >= 20 && spellId == BACKSTAB)
+                    aftercrit += 30.f;
+                //Puncturing Wounds: 15% additional critical chance for Mutilate
+                else if (spellId == MUTILATE)
+                    aftercrit += 15.f;
+                //Glyph of Eviscerate: 10% additional critical chance for Eviscerate
+                else if (spellId == EVISCERATE)
+                    aftercrit += 10.f;
+                //Improved Ambush: 60% additional critical chance for Ambush
+                //else if (spellId == AMBUSH)
+                //    crit_chance += 60.f;
+                if (lvl >= 50 && spellInfo->HasEffect(SPELL_EFFECT_ADD_COMBO_POINTS) && me->HasAura(TURN_THE_TABLES_EFFECT))
+                    aftercrit += 6.f;
+
+                //second roll (may be illogical)
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                //Lethality: 30% crit damage bonus for Sinister Strike, Backstab, Mutilate and Hemorrhage
+                if (lvl >= 10 &&
+                    (spellId == SINISTER_STRIKE || spellId == BACKSTAB || spellId == MUTILATE/* || spellId == HEMORRHAGE*/))
+                    pctbonus += 0.15f;
+            }
+            //Shadowstep: 20% bonus damage to all abilities once
+            //if (shadowstep == true)
+            //{
+            //    shadowstep = false;
+            //    me->RemoveAurasDueToSpell(SHADOWSTEP_EFFECT_DAMAGE);
+            //    pctbonus += 0.2f;
+            //}
+            //DeathDealer set bonus: 15% damage bonus for Eviscerate
+            if (lvl >= 60 && spellId == EVISCERATE)
+                pctbonus += 0.15f;
+            //Coup de Grace: 20% damage bonus for Eviscerate and Envenom
+            if (lvl >= 10 &&(spellId == EVISCERATE/* || spellId == ENVENOM*/))
+                pctbonus += 0.2f;
+            //Opportunity: 30% damage bonus for Backstab, Mutilate, Garrote and Ambush
+            if (lvl >= 20 && (spellId == BACKSTAB || spellId == MUTILATE/* || 
+                spellId == GARROTE || spellId == AMBUSH*/))
+                pctbonus += 0.3f;
+            //Aggression: 20% damage bonus for Sinister Strike, Backstab and Eviscerate
+            if (lvl >= 20 && (spellId == SINISTER_STRIKE || spellId == BACKSTAB || spellId == EVISCERATE))
+                pctbonus += 0.2f;
+            //Surprise Attacks (434 deprecated): 10% bonus damage for Sinister Strike, Backstab, Shiv, Hemmorhage and Gouge
+            if (lvl >= 60 && (spellId == SINISTER_STRIKE || spellId == BACKSTAB/* ||
+                spellId == SHIV || spellId == HEMORRHAGE || spellId == GOUGE*/))
+                pctbonus += 0.1f;
+            //434 new
+            //Improved Sinister Strike: 30% bonus damage for Sinister Strike
+            if (lvl >= 10 && spellId == SINISTER_STRIKE)
+                pctbonus += 0.3f;
+
+            //Special
+            if (spellId == EVISCERATE)
+            {
+                float ap = me->GetTotalAttackPowerValue(BASE_ATTACK);
+                //434 temp formula - placeholder
+                float damageMin = 5 + me->getLevel() * 2;
+                float damageMax = 10 + me->getLevel() * 5;
+                //base damage
+                fdamage = frand(damageMin, damageMax) + (damageMin + damageMax) * comboPoints;
+
+                //ap bonus (Trinity-based)
+                fdamage += frand(ap * comboPoints * 0.03f, ap * comboPoints * 0.07f);
+            }
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierEffect(SpellInfo const* spellInfo, float& value) const
+        {
+            uint32 spellId = spellInfo->Id;
+
+            //float pct_mod = 1.f;
+            float flat_mod = 0.f;
+
+            if (spellId == RUPTURE)
+            {
+                float ap = me->GetTotalAttackPowerValue(BASE_ATTACK);
+                //434 temp formula - placeholder
+                flat_mod += float(urand(me->getLevel() * 17, me->getLevel() * 22) * comboPoints);
+
+                float AP_per_combo[6] = { 0.0f, 0.015f, 0.024f, 0.03f, 0.03428571f, 0.0375f }; //Trinity-based
+                float divider[6] = { 0.0f, 4.f, 5.f, 6.f, 7.f, 8.f }; //base duration/2 = number of ticks
+                flat_mod /= divider[comboPoints];
+                flat_mod += ap * AP_per_combo[comboPoints];
+            }
+
+            value += flat_mod;
+            //value *= pct_mod;
+        }
+
+        void DamageDealt(Unit* victim, uint32& /*damage*/, DamageEffectType damageType)
+        {
+            if (!WOUND_POISON && !MIND_NUMBING_POISON)
+                return;
+
+            if (damageType == DIRECT_DAMAGE/* || damageType == SPELL_DIRECT_DAMAGE*/)
+            {
+                if (victim && me->GetExactDist(victim) <= 40)
+                {
+                    switch (rand()%2)
+                    {
+                        case 0:
+                            break;
+                        case 1:
+                        {
+                            switch (rand()%2)
+                            {
+                                case 0:
+                                    if (WOUND_POISON)
+                                    {
+                                        currentSpell = WOUND_POISON;
+                                        DoCast(victim, WOUND_POISON, true);
+                                    }
+                                    break;
+                                case 1:
+                                    if (MIND_NUMBING_POISON)
+                                    {
+                                        currentSpell = MIND_NUMBING_POISON;
+                                        DoCast(victim, MIND_NUMBING_POISON, true);
+                                    }
+                                    break;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            if (currentSpell == 0)
+                return;
+
+            uint32 spellId = spell->Id;
+
+            //temp target holders
+            if (spellId == SLICE_DICE)
+            {
+                tempDICE = true;
+                tempComboPoints = comboPoints;
+                Slice_Dice_Timer = 15000 + (comboPoints-1)*4500;
+            }
+            else if (spellId == RUPTURE)
+            {
+                RuptureTarget = target->GetGUID();
+                tempComboPoints = comboPoints;
+                Rupture_Timer = 8000 + (comboPoints-1)*2000 + 4000;
+                GC_Timer = 800;
+            }
+
+            //BONUS CP MANAGEMENT
+
+            //if (spellId == EVISCERATE || spellId == KIDNEY_SHOT || spellId == SLICE_DICE || spellId == RUPTURE/* || spellId == EXPOSE_ARMOR || spellId == ENVENOM*/)
+            //Relentless Strikes
+            if (spell->NeedsComboPoints())
+            {
+                //std::ostringstream msg;
+                //msg << "casting ";
+                //if (spellId == EVISCERATE)
+                //    msg << "Eviscerate, ";
+                //else if (spellId == RUPTURE)
+                //    msg << "Rupture, ";
+                //else if (spellId == SLICE_DICE)
+                //    msg << "Slice and Dice, ";
+                //else if (spellId == KIDNEY_SHOT)
+                //    msg << "Kidney Shot, ";
+                ////else if (spellId == EXPOSE_ARMOR)
+                ////    msg << "Expose Armor, ";
+                ////else if (spellId == ENVENOM)
+                ////    msg << "Envenom, ";
+                //msg << "combo points: " << uint32(std::min<uint32>(comboPoints,5));
+                //me->MonsterWhisper(msg.str().c_str(), master->GetGUID());
+                if (irand(0, 99) < 20 * (comboPoints > 5 ? 5 : comboPoints))
+                {
+                    currentSpell = RELENTLESS_STRIKES_EFFECT;
+                    DoCast(me, RELENTLESS_STRIKES_EFFECT, true);
+                }
+                tempComboPoints = comboPoints;
+                //CP adding effects are handled before actual finisher so use temp value
+                //std::ostringstream msg2;
+                //msg2 << "cp set to 0";
+                if (tempAddCP)
+                {
+                    //msg2 << " + " << uint32(tempAddCP) << " (temp)";
+                    comboPoints = tempAddCP;
+                    tempAddCP = 0;
+                }
+                else
+                    comboPoints = 0;
+                //me->MonsterWhisper(msg2.str().c_str(), master->GetGUID());
+            }
+            else if (spellId == SINISTER_STRIKE ||
+                spellId == BACKSTAB/* ||
+                spellId == GOUGE ||
+                spellId == HEMORRHAGE*/)
+            {
+                ++comboPoints;
+                //std::ostringstream msg;
+                //msg << "1 cp generated ";
+                //if (spellId == SINISTER_STRIKE)
+                //    msg << "(Sinister Strike)";
+                //else if (spellId == BACKSTAB)
+                //    msg << "(Backstab)";
+                //msg << " set to " << uint32(comboPoints);
+                //if (tempAddCP)
+                //    msg << " + " << uint32(tempAddCP) << " (triggered)";
+                //me->MonsterWhisper(msg.str().c_str(), master->GetGUID());
+                if (tempAddCP)
+                {
+                    comboPoints += tempAddCP;
+                    tempAddCP = 0;
+                }
+            }
+            else if (spellId == MUTILATE/* ||
+                spellId == AMBUSH*/)
+            {
+                comboPoints += 2;
+                //std::ostringstream msg;
+                //msg << "2 cp generated (Mutilate), set to " << uint32(comboPoints);
+                //if (tempAddCP)
+                //    msg << " + " << uint32(tempAddCP) << " (triggered)";
+                //me->MonsterWhisper(msg.str().c_str(), master->GetGUID());
+                if (tempAddCP)
+                {
+                    comboPoints += tempAddCP;
+                    tempAddCP = 0;
+                }
+            }
+            else if (spellId == SEAL_FATE_EFFECT || spellId == RUTHLESSNESS_EFFECT)
+            {
+                ++tempAddCP;
+                //std::ostringstream msg;
+                //msg << "1 temp cp generated ";
+                //if (spellId == SEAL_FATE_EFFECT)
+                //    msg << "(Seal Fate)";
+                //else if (spellId == RUTHLESSNESS_EFFECT)
+                //    msg << "(Ruthleness)";
+                //me->MonsterWhisper(msg.str().c_str(), master->GetGUID());
+            }
+
+            //Glyph of Sinister Strike (20% to add cp on hit)
+            //Seal Fate means crit so this glyph is enabled from lvl 35)
+            //as addition always add cp on ss crit
+            if (currentSpell == SINISTER_STRIKE && (spellId == SEAL_FATE_EFFECT || urand(0,100) >= 20))
+            {
+                ++tempAddCP;
+                //me->MonsterWhisper("1 temp cp generated (glyph of SS)", master->GetGUID());
+            }
+
+            //ENERGY COST REDUCTION
+
+            if (spellId == SINISTER_STRIKE)
+            {
+                //Improved Sinister Strike
+                //instead of restoring energy we should override current value
+                if (me->getLevel() >= 10)
+                    modenergy(-40, true);//45 - 5
+            }
+            //Slaughter from the Shadows energy restore
+            //instead of restoring energy we should override current value
+            if (me->getLevel() >= 55)
+            {
+                if (spellId == BACKSTAB/* || spellId == AMBUSH*/)
+                    modenergy(-40, true);
+                //else if (spellId == HEMORRHAGE)
+                //    modenergy(-30, true);
+            }
+
+            //OTHER
+
+            if (spellId == EVISCERATE)
+            {
+                //Eviscerate speedup
+                GC_Timer = 800;
+
+                //Serrated Blades: Eviscerate has 20% chance per cp to refresh Rupture
+                //getting cheaty - remove roll
+                //getting cheaty - increase duration
+                //if (irand(0, 99) < 20 * (comboPoints > 5 ? 5 : comboPoints))
+                {
+                    if (Aura* rupture = target->GetAura(RUPTURE, me->GetGUID()))
+                    {
+                        int32 dur = rupture->GetMaxDuration() + 2000;
+                        dur = std::min<int32>(dur, 30000);
+                        rupture->SetDuration(dur);
+                        rupture->SetMaxDuration(dur);
+                        Rupture_Timer = dur - 2000;
+                    }
+                }
+            }
+
+            //Cut to the Chase: Eviscerate and Envenom will refresh Slice and Dice duration
+            //getting cheaty - increase duration
+            if (spellId == EVISCERATE/* || spellId == ENVENOM*/)
+            {
+                if (Aura* dice = me->GetAura(SLICE_DICE))
+                {
+                    int32 dur = dice->GetMaxDuration() + 2000;
+                    dur = std::min<int32>(dur, 59000);
+                    dice->SetDuration(dur);
+                    dice->SetMaxDuration(dur);
+                    Slice_Dice_Timer = dur - 2000;
+                }
+            }
+
+            //Murderous Intent: When Backstabbing enemy that is below 35% hp, instantly restoring 30 energy
+            if (spellId == BACKSTAB)
+            {
+                if (target->HealthBelowPct(35))
+                {
+                    //since talent doesn't work just restore energy manually
+                    //DoCast(me, MURDEROUS_INTENT_EFFECT, true);
+                    modenergy(30);
+                }
+            }
+
+            //Waylay
+            if (spellId == BACKSTAB/* || spellId == AMBUSH*/)
+            {
+                DoCast(target, WAYLAY_EFFECT, true);
+            }
+
+            //if (spellId == SHADOWSTEP)
+            //{
+            //    Shadowstep_eff_Timer = 10000;
+            //    shadowstep = true;
+            //}
+
+            //move behind on Kidney Shot and Gouge (optionally)
+            if (spellId == KIDNEY_SHOT/* || spellId == GOUGE*/)
+                if (MoveBehind(*target))
+                    wait = 3;
+
+            if (spellId == currentSpell)
+                currentSpell = 0;
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            Mutilate_Timer = 0;
+            Rupture_Timer = 0;
+            Dismantle_Timer = 0;
+            Kick_Timer = 0;
+            Kidney_Timer = 0;
+            Shadowstep_Timer = 0;
+            Blade_Flurry_Timer = 0;
+            Slice_Dice_Timer = 0;
+            //Shadowstep_eff_Timer = 0;
+
+            comboPoints = 0;
+            tempComboPoints = 0;
+            tempAddCP = 0;
+
+            KidneyTarget = 0;
+            RuptureTarget = 0;
+
+            tempDICE = false;
+            //shadowstep = false;
+
+            me->setPowerType(POWER_ENERGY);
+            //10 energy gained per stack
+            RefreshAura(GLADIATOR_VIGOR, 10);
+
+            if (master)
+            {
+                setStats(CLASS_ROGUE, me->getRace(), master->getLevel(), true);
+                ApplyClassPassives();
+                ApplyPassives(CLASS_ROGUE);
+            }
+
+            me->SetPower(POWER_ENERGY, me->GetMaxPower(POWER_ENERGY));
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            CommonTimers(diff);
+            if (Kick_Timer > diff)                  Kick_Timer -= diff;
+            if (Rupture_Timer > diff)               Rupture_Timer -= diff;
+            if (Shadowstep_Timer > diff)            Shadowstep_Timer -= diff;
+            if (Mutilate_Timer > diff)              Mutilate_Timer -= diff;
+            if (Kidney_Timer > diff)                Kidney_Timer -= diff;
+            if (Dismantle_Timer > diff)             Dismantle_Timer -= diff;
+            if (Blade_Flurry_Timer > diff)          Blade_Flurry_Timer -= diff;
+            if (Slice_Dice_Timer > diff)            Slice_Dice_Timer -= diff;
+            //if (Shadowstep_eff_Timer > diff)        Shadowstep_eff_Timer -= diff;
+            //else if (shadowstep)                    shadowstep = false;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            BACKSTAB                                = InitSpell(me, BACKSTAB_1);
+            SINISTER_STRIKE                         = InitSpell(me, SINISTER_STRIKE_1);
+            SLICE_DICE                              = InitSpell(me, SLICE_DICE_1);
+            EVISCERATE                              = InitSpell(me, EVISCERATE_1);
+            KICK                                    = InitSpell(me, KICK_1);
+            RUPTURE                                 = InitSpell(me, RUPTURE_1);
+            KIDNEY_SHOT                             = InitSpell(me, KIDNEY_SHOT_1);
+            MUTILATE                    = lvl >= 10 ? MUTILATE_1 : 0;
+            SHADOWSTEP                  = lvl >= 15 ? SHADOWSTEP_1 : 0;
+            DISMANTLE                               = InitSpell(me, DISMANTLE_1);
+            BLADE_FLURRY                = lvl >= 20 ? BLADE_FLURRY_1 : 0;
+
+            WOUND_POISON                            = InitSpell(me, WOUND_POISON_1);
+            MIND_NUMBING_POISON                     = InitSpell(me, MIND_NUMBING_POISON_1);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+
+            if (level >= 67)
+                RefreshAura(COMBAT_POTENCY3,2);
+            else if (level >= 43)
+                RefreshAura(COMBAT_POTENCY3);
+            else if (level >= 41)
+                RefreshAura(COMBAT_POTENCY2);
+            else if (level >= 39)
+                RefreshAura(COMBAT_POTENCY1);
+            if (level >= 40)
+                RefreshAura(SEAL_FATE);
+            if (level >= 82)
+                RefreshAura(VITALITY,4);
+            else if (level >= 67)
+                RefreshAura(VITALITY,3);
+            else if (level >= 58)
+                RefreshAura(VITALITY,2);
+            else if (level >= 40)
+                RefreshAura(VITALITY);
+            if (level >= 21)
+                RefreshAura(QUICKENING2);
+            else if (level >= 19)
+                RefreshAura(QUICKENING1);
+            if (level >= 57)
+                RefreshAura(TURN_THE_TABLES);
+            if (level >= 30)
+                RefreshAura(DEADLY_BREW);
+            if (level >= 39)
+                RefreshAura(BLADE_TWISTING1);//allow rank 1 only
+            if (level >= 15)
+                RefreshAura(QUICK_RECOVERY2);
+            if (level >= 35)
+                RefreshAura(IMPROVED_KIDNEY_SHOT);
+            if (level >= 10)
+                RefreshAura(GLYPH_BACKSTAB);
+            if (level >= 10)
+                RefreshAura(SURPRISE_ATTACKS);
+            if (level >= 11)
+                RefreshAura(IMPROVED_KICK);
+
+            if (level >= 82)
+                RefreshAura(ROGUE_VIGOR,3);
+            else if (level >= 35)
+                RefreshAura(ROGUE_VIGOR,2);
+            else if (level >= 10)
+                RefreshAura(ROGUE_VIGOR);
+        }
+
+    private:
+        uint32
+            BACKSTAB, SINISTER_STRIKE, SLICE_DICE, EVISCERATE, KICK, RUPTURE, KIDNEY_SHOT, MUTILATE,
+            SHADOWSTEP, DISMANTLE, BLADE_FLURRY,
+            WOUND_POISON, MIND_NUMBING_POISON;
+        //Timers/other
+        uint64 KidneyTarget, RuptureTarget;
+        uint32 Rupture_Timer, Dismantle_Timer,
+            Kick_Timer, Shadowstep_Timer, Mutilate_Timer, Kidney_Timer,
+            Blade_Flurry_Timer, Slice_Dice_Timer/*, Shadowstep_eff_Timer*/;
+        uint32 energy;
+        uint8 comboPoints, tempComboPoints, tempAddCP;
+        bool tempDICE/*, shadowstep*/;
+
+        enum RogueBaseSpells
+        {
+            BACKSTAB_1                          = 53,
+            SINISTER_STRIKE_1                   = 1752,
+            SLICE_DICE_1                        = 5171,
+            EVISCERATE_1                        = 2098,
+            KICK_1                              = 1766,
+            RUPTURE_1                           = 1943,
+            KIDNEY_SHOT_1                       = 408,
+  /*Talent*/MUTILATE_1                          = 1329,
+  /*Talent*/SHADOWSTEP_1                        = 36554,
+            DISMANTLE_1                         = 51722,
+            BLADE_FLURRY_1                      = 33735,
+        //Special
+            WOUND_POISON_1                      = 13218,
+            MIND_NUMBING_POISON_1               = 5760
+        };
+
+        enum RoguePassives
+        {
+            //Talents
+            SEAL_FATE                           = 14190,
+            COMBAT_POTENCY1                     = 35541,
+            COMBAT_POTENCY2                     = 35550,
+            COMBAT_POTENCY3                     = 35551,
+            //QUICK_RECOVERY1                     = 31244,//deprecated
+            QUICK_RECOVERY2                     = 31245,//deprecated
+            BLADE_TWISTING1                     = 31124,
+            //BLADE_TWISTING2                     = 31126,
+            VITALITY                            = 61329,
+            DEADLY_BREW                         = 51626,//rank 2
+            IMPROVED_KICK                       = 13867,
+            //434 talents
+            QUICKENING1                         = 31208,
+            QUICKENING2                         = 31209,
+            //Other
+            IMPROVED_KIDNEY_SHOT                = 14176,//3.3.5 talent, deprecated
+            TURN_THE_TABLES                     = 51629,//3.3.5 talent, deprecated
+            SURPRISE_ATTACKS                    = 32601,//3.3.5 talent, deprecated
+            ROGUE_VIGOR                         = 14983,//3.3.5 talent, deprecated
+            GLADIATOR_VIGOR                     = 21975,
+            GLYPH_BACKSTAB                      = 56800
+        };
+
+        enum RogueSpecial
+        {
+            RELENTLESS_STRIKES_EFFECT           = 14181,
+            RUTHLESSNESS_EFFECT                 = 14157,
+            SEAL_FATE_EFFECT                    = 14189,
+            //SHADOWSTEP_EFFECT_DAMAGE            = 36563,
+            TURN_THE_TABLES_EFFECT              = 52910,//'rank 3'
+            WAYLAY_EFFECT                       = 51693,
+            //434
+            MURDEROUS_INTENT_EFFECT             = 79132
+        };
+    };
+};
+
+void AddSC_rogue_bot()
+{
+    new rogue_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_shaman_ai.cpp b/src/server/game/AI/NpcBots/bot_shaman_ai.cpp
new file mode 100644
index 0000000..cbe11fa
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_shaman_ai.cpp
@@ -0,0 +1,474 @@
+#include "bot_ai.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+#include "Totem.h"
+/*
+Shaman NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - 1%
+TODO:
+*/
+enum TotemSlot
+{
+    T_FIRE  = 0,
+    T_WATER = 1,
+    T_EARTH = 2,
+    T_AIR   = 3,
+    MAX_TOTEMS
+};
+typedef std::pair<uint64, Position> BotTotem;
+class shaman_bot : public CreatureScript
+{
+public:
+    shaman_bot() : CreatureScript("shaman_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new shaman_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    struct shaman_botAI : public bot_minion_ai
+    {
+        shaman_botAI(Creature* creature) : bot_minion_ai(creature)
+        {
+            Reset();
+        }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (checkBotCast(victim, spellId, CLASS_SHAMAN) != SPELL_CAST_OK)
+                return false;
+            uint64 originalCaster = me->GetGUID();
+            return bot_ai::doCast(victim, spellId, triggered, originalCaster);
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            GetInPosition(force, false/*STYLE == MELEE*//*SPEC == ENCHANCEMENT*/);
+            SetBotCommandState(COMMAND_ATTACK);
+        }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit*) { master->SetNpcBotDied(me->GetGUID()); }
+
+        void CheckTotems(uint32 diff)
+        {
+            //update rate
+            if (Rand() > 50)
+                return;
+            //Unsummon
+            for (uint8 i = 0; i != MAX_TOTEMS; ++i)
+            {
+                if (_totems[i].first != 0 && me->GetDistance(_totems[i].second) > 18)
+                {
+                    Unit* to = sObjectAccessor->FindUnit(_totems[i].first);
+                    //reset
+                    _totems[i].first = 0;
+                    if (!to)
+                    {
+                        TC_LOG_ERROR(LOG_FILTER_PLAYER, "%s has lost totem in slot %u! Despawned normally?", me->GetName().c_str(), i);
+                        continue;
+                    }
+                    to->ToTotem()->UnSummon();
+                }
+            }
+            if (GC_Timer > diff || IsCasting() || me->GetDistance(master) > 15 || Feasting())
+                return;
+            //Summon
+            //TODO: role-based totems (attack/heal)
+            if (me->IsInCombat())
+            {
+                if (WINDFURY_TOTEM && !_totems[T_AIR].first)
+                {
+                    if (doCast(me, WINDFURY_TOTEM))
+                        return;
+                }
+                else if (STONESKIN_TOTEM && !_totems[T_EARTH].first)
+                {
+                    if (doCast(me, STONESKIN_TOTEM))
+                        return;
+                }
+
+                if (Unit* u = me->GetVictim())
+                {
+                    if (SEARING_TOTEM && Searing_Totem_Timer <= diff)
+                    {
+                        if (me->GetExactDist(u) < (u->isMoving() ? 10 : 25))
+                        {
+                            if (doCast(me, SEARING_TOTEM))
+                            {
+                                Searing_Totem_Timer = 30000;
+                                return;
+                            }
+                        }
+                    }
+                }
+            }
+            else if (!me->isMoving() && !master->isMoving())
+            {
+                if (!_totems[T_WATER].first)
+                {
+                    uint8 manapct = GetManaPCT(master);
+                    uint8 hppct = GetHealthPCT(master);
+                    if (HEALINGSTREAM_TOTEM &&
+                        (master->getPowerType() != POWER_MANA || !MANASPRING_TOTEM || hppct < 25 || manapct > hppct) &&
+                        hppct < 98)
+                    {
+                        if (doCast(me, HEALINGSTREAM_TOTEM))
+                            return;
+                    }
+                    else if (MANASPRING_TOTEM && manapct < 98)
+                    {
+                        if (doCast(me, MANASPRING_TOTEM))
+                            return;
+                    }
+                }
+            }
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (IAmDead()) return;
+            if (!me->GetVictim()) Evade();
+            if (me->GetVictim())
+                DoMeleeAttackIfReady();
+            else
+                Evade();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            CheckAuras();
+            BreakCC(diff);
+            if (CCed(me)) return;
+
+            if (GetManaPCT(me) < 30 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, MANAPOTION))
+                    Potion_cd = POTION_CD;
+                GC_Timer = temptimer;
+            }
+
+            BuffAndHealGroup(master, diff);
+            CheckTotems(diff);
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+            //buff myself
+            if (LIGHTNING_SHIELD && GC_Timer <= diff && !me->HasAura(LIGHTNING_SHIELD))
+                if (doCast(me, LIGHTNING_SHIELD))
+                    GC_Timer = 500;
+
+            if (!CheckAttackTarget(CLASS_SHAMAN))
+                return;
+
+            //Counter(diff);
+            DoNormalAttack(diff);
+        }
+
+        void Counter(uint32 const /*diff*/)
+        {}
+
+        void DoNormalAttack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent, true);
+            }
+            else
+                return;
+
+            Counter(diff);
+
+            //AttackerSet m_attackers = master->getAttackers();
+            //AttackerSet b_attackers = me->getAttackers();
+            float dist = me->GetExactDist(opponent);
+            //float meleedist = me->GetDistance(opponent);
+
+            if (MoveBehind(*opponent))
+                wait = 5;
+
+            if (Shock_Timer <= diff && GC_Timer <= diff && dist < 20)
+            {
+                if (!opponent->HasAura(FLAME_SHOCK, me->GetGUID()))
+                {
+                    if (doCast(opponent, FLAME_SHOCK))
+                    {
+                        Shock_Timer = 9000;
+                        return;
+                    }
+                }
+                else if (!opponent->HasAura(EARTH_SHOCK))
+                {
+                    if (doCast(opponent, EARTH_SHOCK))
+                    {
+                        Shock_Timer = 9000;
+                        return;
+                    }
+                }
+            }
+
+            if (Lightning_Bolt_Timer <= diff && GC_Timer <= diff && dist < 25)
+            {
+                if (doCast(opponent, LIGHTNING_BOLT))
+                {
+                    Lightning_Bolt_Timer = uint32(float(sSpellMgr->GetSpellInfo(LIGHTNING_BOLT)->CalcCastTime()/100) * me->GetFloatValue(UNIT_MOD_CAST_SPEED) + 200);
+                    return;
+                }
+            }
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || Rand() > 50 || me->IsMounted()) return;
+
+            RezGroup(ANCESTRAL_SPIRIT, master);
+
+            //if (Feasting()) return;
+            //BuffAndHealGroup(master, diff);
+            //CureGroup(master, diff);
+        }
+
+        bool HealTarget(Unit* target, uint8 hp, uint32 diff)
+        {
+            if (hp > 95) return false;
+            if (!target || target->isDead() || me->GetExactDist(target) > 40)
+                return false;
+            if (Rand() > 50 + 20*target->IsInCombat() + 50*master->GetMap()->IsRaid()) return false;
+
+            //PLACEHOLDER: Instant spell req. interrupt current spell
+
+            if (IsCasting()) return false;
+
+            
+            /*if (hp < 70 && Heal_Timer <= diff)
+            {
+                doCast(target, HEALING_WAVE);
+            }
+            else */if (hp < 90 && Heal_Timer <= diff)
+            {
+                doCast(target, CHAIN_HEAL);
+            }
+            else if (hp < 95)
+            {
+                doCast(target, LESSER_HEAL);
+                return true;
+            }
+            return true;
+        }
+
+        //void ApplyBotDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& /*crit*/) const
+        //{
+        //    uint32 spellId = spellInfo->Id;
+        //    uint8 lvl = me->getLevel();
+        //    float fdamage = float(damage);
+        //    //1) apply additional crit chance. This new chance roll will replace original (balance unsafe)
+        //    if (!crit)
+        //    {
+        //        float crit_chance = me->GetUnitCriticalChance(BASE_ATTACK, me);
+        //        float aftercrit = crit_chance;
+
+        //        //second roll (may be illogical)
+        //        if (aftercrit > crit_chance)
+        //            crit = roll_chance_f(aftercrit);
+        //    }
+
+        //    2) apply bonus damage mods
+        //    float pctbonus = 0.0f;
+        //    if (crit)
+        //    {
+        //    }
+
+        //    fdamage *= (1.0f + pctbonus);
+        //    damage = int32(fdamage);
+        //    //last: overall multiplier
+        //    bot_ai::ApplyBotDamageMultiplierMelee(damage, damageinfo, spellInfo, attackType, crit);
+        //}
+
+        void DamageDealt(Unit* /*victim*/, uint32& /*damage*/, DamageEffectType /*damageType*/)
+        {
+        }
+
+        void OnBotSummon(Creature* summon)
+        {
+            TempSummon* totem = summon->ToTempSummon();
+            if (!totem)
+            {
+                TC_LOG_ERROR(LOG_FILTER_PLAYER, "shaman bot %s summoned creature %s which is not a temp summon...");
+                return;
+            }
+
+            int8 slot = -1;
+            switch (totem->m_Properties->Id)
+            {
+                case SUMMON_TYPE_TOTEM_FIRE:
+                    slot = T_FIRE;
+                    break;
+                case SUMMON_TYPE_TOTEM_EARTH:
+                    slot = T_EARTH;
+                    break;
+                case SUMMON_TYPE_TOTEM_WATER:
+                    slot = T_WATER;
+                    break;
+                case SUMMON_TYPE_TOTEM_AIR:
+                    slot = T_AIR;
+                    break;
+                default:
+                    TC_LOG_ERROR(LOG_FILTER_PLAYER, "unknown totem type %u", totem->m_Properties->Id);
+                    return;
+            }
+            _totems[slot].first = summon->GetGUID();
+            _totems[slot].second.Relocate(*summon);
+            //TC_LOG_ERROR(LOG_FILTER_PLAYER, "shaman bot: summoned %s (type %u) at x='%f', y='%f', z='%f'",
+            //    summon->GetName().c_str(), slot, _totems[slot].second.GetPositionX(), _totems[slot].second.GetPositionY(), _totems[slot].second.GetPositionZ());
+
+            summon->SetDisplayId(me->GetModelForTotem(PlayerTotemType(totem->m_Properties->Id)));
+            //summon->SetDisplayId(summon->GetNativeDisplayId());
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void UnsummonAll()
+        {
+            for (uint8 i = 0; i != MAX_TOTEMS; ++i)
+            {
+                if (_totems[i].first != 0)
+                {
+                    Unit* to = sObjectAccessor->FindUnit(_totems[i].first);
+                    if (!to)
+                    {
+                        TC_LOG_ERROR(LOG_FILTER_PLAYER, "%s has no totem in slot %u during remove!", me->GetName().c_str(), i);
+                        continue;
+                    }
+                    to->ToTotem()->UnSummon();
+                }
+            }
+        }
+
+        void Reset()
+        {
+            Heal_Timer = 0;
+            Shock_Timer = 0;
+            Lightning_Bolt_Timer = 0;
+            Searing_Totem_Timer = 0;
+
+            if (master)
+            {
+                setStats(CLASS_SHAMAN, me->getRace(), master->getLevel(), true);
+                ApplyClassPassives();
+                ApplyPassives(CLASS_SHAMAN);
+            }
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            CommonTimers(diff);
+            if (Heal_Timer > diff)              Heal_Timer -= diff;
+            if (Shock_Timer > diff)             Shock_Timer -= diff;
+            if (Lightning_Bolt_Timer > diff)    Lightning_Bolt_Timer -= diff;
+            if (Searing_Totem_Timer > diff)     Searing_Totem_Timer -= diff;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            //uint8 lvl = me->getLevel();
+            CHAIN_HEAL                              = InitSpell(me, CHAIN_HEAL_1);
+            LESSER_HEAL                             = InitSpell(me, LESSER_HEAL_1);
+            ANCESTRAL_SPIRIT                        = InitSpell(me, ANCESTRAL_SPIRIT_1);
+            FLAME_SHOCK                             = InitSpell(me, FLAME_SHOCK_1);
+            EARTH_SHOCK                             = InitSpell(me, EARTH_SHOCK_1);
+            LIGHTNING_BOLT                          = InitSpell(me, LIGHTNING_BOLT_1);
+            LIGHTNING_SHIELD                        = InitSpell(me, LIGHTNING_SHIELD_1);
+            STONESKIN_TOTEM                         = InitSpell(me, STONESKIN_TOTEM_1);
+            HEALINGSTREAM_TOTEM                     = InitSpell(me, HEALINGSTREAM_TOTEM_1);
+            MANASPRING_TOTEM                        = InitSpell(me, MANASPRING_TOTEM_1);
+            SEARING_TOTEM                           = InitSpell(me, SEARING_TOTEM_1);
+            WINDFURY_TOTEM                          = InitSpell(me, WINDFURY_TOTEM_1);
+        }
+
+        void ApplyClassPassives()
+        {
+        }
+
+    private:
+        BotTotem _totems[MAX_TOTEMS];
+        uint32
+            CHAIN_HEAL, LESSER_HEAL, ANCESTRAL_SPIRIT,
+            FLAME_SHOCK, EARTH_SHOCK, LIGHTNING_BOLT, LIGHTNING_SHIELD,
+            STONESKIN_TOTEM, HEALINGSTREAM_TOTEM, MANASPRING_TOTEM, SEARING_TOTEM, WINDFURY_TOTEM;
+        //Timers
+        uint32 Heal_Timer, Shock_Timer, Lightning_Bolt_Timer, Searing_Totem_Timer;
+
+        enum ShamanBaseSpells
+        {
+            CHAIN_HEAL_1                        = 1064,
+            LESSER_HEAL_1                       = 8004,
+            ANCESTRAL_SPIRIT_1                  = 2008,
+            FLAME_SHOCK_1                       = 8050,
+            EARTH_SHOCK_1                       = 8042,
+            LIGHTNING_BOLT_1                    = 403,
+            LIGHTNING_SHIELD_1                  = 324,
+            STONESKIN_TOTEM_1                   = 8071,
+            HEALINGSTREAM_TOTEM_1               = 5394,
+            MANASPRING_TOTEM_1                  = 5675,
+            SEARING_TOTEM_1                     = 3599,
+            WINDFURY_TOTEM_1                    = 8512,
+        };
+
+        enum ShamanPassives
+        {
+        };
+
+        enum ShamanSpecial
+        {
+            STONESKIN_AURA                      = 8072,
+            HEALINGSTREAM_AURA                  = 5672,
+            MANASPRING_AURA                     = 5677,
+        };
+    };
+};
+
+
+void AddSC_shaman_bot()
+{
+    new shaman_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_warlock_ai.cpp b/src/server/game/AI/NpcBots/bot_warlock_ai.cpp
new file mode 100644
index 0000000..9060024
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_warlock_ai.cpp
@@ -0,0 +1,458 @@
+#include "bot_ai.h"
+//#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+
+/*
+Warlock NpcBot (reworked by Graff onlysuffering@gmail.com)
+Voidwalker pet AI included
+Complete - 3%
+TODO:
+*/
+class warlock_bot : public CreatureScript
+{
+public:
+    warlock_bot() : CreatureScript("warlock_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new warlock_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    struct warlock_botAI : public bot_minion_ai
+    {
+        warlock_botAI(Creature* creature) : bot_minion_ai(creature) { }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (checkBotCast(victim, spellId, CLASS_WARRIOR) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit*) { me->SetBotsPetDied(); master->SetNpcBotDied(me->GetGUID()); }
+        void DoNonCombatActions()
+        {}
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            GetInPosition(force, true);
+            SetBotCommandState(COMMAND_ATTACK);
+            fear_cd = std::max<uint32>(fear_cd, 1000);
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (IAmDead()) return;
+            if (!me->GetVictim())
+                Evade();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            CheckAuras();
+            if (CCed(me)) return;
+
+            //if pet is dead or unreachable
+            Creature* m_botsPet = me->GetBotsPet();
+            if (!m_botsPet || m_botsPet->FindMap() != master->GetMap() || (me->GetDistance2d(m_botsPet) > sWorld->GetMaxVisibleDistanceOnContinents() - 20.f))
+                if (master->getLevel() >= 10 && !me->IsInCombat() && !IsCasting() && !me->IsMounted())
+                    SummonBotsPet(PET_VOIDWALKER);
+
+            //TODO: implement healthstone
+            if (GetHealthPCT(me) < 50 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, HEALINGPOTION))
+                    Potion_cd = POTION_CD;
+                GC_Timer = temptimer;
+            }
+            if (GetManaPCT(me) < 50 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, MANAPOTION))
+                    Potion_cd = POTION_CD;
+                GC_Timer = temptimer;
+            }
+            if (!me->IsInCombat())
+                DoNonCombatActions();
+
+            if (!CheckAttackTarget(CLASS_WARLOCK))
+                return;
+
+            DoNormalAttack(diff);
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent);
+            }
+            else
+                return;
+
+            //TODO: add more damage spells
+
+            if (fear_cd <= diff && GC_Timer <= diff)
+            { CheckFear(); fear_cd = 2000; }
+
+            if (RAIN_OF_FIRE && Rand() < 25 && Rain_of_fire_cd <= diff && GC_Timer <= diff)
+            {
+                Unit* blizztarget = FindAOETarget(30, true);
+                if (blizztarget && doCast(blizztarget, RAIN_OF_FIRE))
+                {
+                    Rain_of_fire_cd = 5000;
+                    return;
+                }
+                Rain_of_fire_cd = 2000;//fail
+            }
+
+            if (Rand() < 25 && CURSE_OF_THE_ELEMENTS && GC_Timer <= diff && !HasAuraName(opponent, CURSE_OF_THE_ELEMENTS) && 
+                doCast(opponent, CURSE_OF_THE_ELEMENTS))
+            {
+                GC_Timer = 800;
+                return;
+            }
+
+            if (GC_Timer <= 0 && Rand() < 25 && !opponent->HasAura(CORRUPTION, me->GetGUID()) && 
+                doCast(opponent, CORRUPTION))
+                { return; }
+
+            if (HAUNT && Rand() < 25 && Haunt_cd <= diff && GC_Timer <= diff && !opponent->HasAura(HAUNT, me->GetGUID()) && 
+                doCast(opponent, HAUNT))
+            {
+                Haunt_cd = 8000;
+                return;
+            }
+
+            if (GC_Timer <= diff && Rand() < 15 && !Afflicted(opponent))
+            {
+                if (conflagarate_cd <= 8000 && doCast(opponent, IMMOLATE))
+                    return;
+                else if (UNSTABLE_AFFLICTION && doCast(opponent, UNSTABLE_AFFLICTION))
+                    return;
+            }
+
+            if (CONFLAGRATE && Rand() < 35 && conflagarate_cd <= diff && GC_Timer <= diff && 
+                HasAuraName(opponent, IMMOLATE) && 
+                doCast(opponent, CONFLAGRATE))
+            {
+                conflagarate_cd = 10000;
+                return;
+            }
+
+            if (CHAOS_BOLT && Rand() < 50 && chaos_bolt_cd <= diff && GC_Timer <= diff && doCast(opponent, CHAOS_BOLT))
+            {
+                chaos_bolt_cd = 16000 - me->getLevel() * 100;
+                return;
+            }
+
+            if (GC_Timer <= diff && doCast(opponent, SHADOW_BOLT))
+                return;
+
+        }
+
+        uint8 Afflicted(Unit* target)
+        {
+            if (!target || target->isDead()) return 0;
+            bool aff = HasAuraName(target, UNSTABLE_AFFLICTION, me->GetGUID());
+            bool imm = HasAuraName(target, IMMOLATE, me->GetGUID());
+            if (imm) return 1;
+            if (aff) return 2;
+            return 0;
+        }
+
+        void CheckFear()
+        {
+            if (Unit* u = FindAffectedTarget(FEAR, me->GetGUID()))
+                if (Aura* aura = u->GetAura(FEAR, me->GetGUID()))
+                    if (aura->GetDuration() > 3000)
+                        return;
+            Unit* feartarget = FindFearTarget();
+            if (feartarget && doCast(feartarget, FEAR)) {}
+        }
+
+        //void SummonedCreatureDies(Creature* summon, Unit* /*killer*/)
+        //{
+        //    if (summon == me->GetBotsPet())
+        //        me->SetBotsPetDied();
+        //}
+
+        //void SummonedCreatureDespawn(Creature* summon)
+        //{
+        //    if (summon == me->GetBotsPet())
+        //        me->SetBotsPet(NULL);
+        //}
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            Rain_of_fire_cd = 0;
+            Haunt_cd = 0;
+            conflagarate_cd = 0;
+            chaos_bolt_cd = 0;
+            fear_cd = 0;
+
+            if (master)
+            {
+                setStats(CLASS_WARLOCK, me->getRace(), master->getLevel(), true);
+                //TODO: passives
+                ApplyClassPassives();
+                ApplyPassives(CLASS_WARLOCK);
+            }
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            CommonTimers(diff);
+            if (Rain_of_fire_cd > diff)     Rain_of_fire_cd -= diff;
+            if (Haunt_cd > diff)            Haunt_cd -= diff;
+            if (conflagarate_cd > diff)     conflagarate_cd -= diff;
+            if (chaos_bolt_cd > diff)       chaos_bolt_cd -= diff;
+            if (fear_cd > diff)             fear_cd -= diff;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            CURSE_OF_THE_ELEMENTS                   = InitSpell(me, CURSE_OF_THE_ELEMENTS_1);
+            SHADOW_BOLT                             = InitSpell(me, SHADOW_BOLT_1);
+            IMMOLATE                                = InitSpell(me, IMMOLATE_1);
+            CONFLAGRATE                 = lvl >= 40 ? CONFLAGRATE_1 : 0;
+  /*Talent*/CHAOS_BOLT                  = lvl >= 60 ? InitSpell(me, CHAOS_BOLT_1) : 0;
+            RAIN_OF_FIRE                            = InitSpell(me, RAIN_OF_FIRE_1);
+  /*Talent*/HAUNT                       = lvl >= 60 ? InitSpell(me, HAUNT_1) : 0;
+            CORRUPTION                              = InitSpell(me, CORRUPTION_1);
+  /*Talent*/UNSTABLE_AFFLICTION         = lvl >= 50 ? InitSpell(me, UNSTABLE_AFFLICTION_1) : 0;
+            FEAR                                    = InitSpell(me, FEAR_1);
+        }
+
+        void ApplyClassPassives() {}
+
+    private:
+        uint32 
+  /*Curses*/CURSE_OF_THE_ELEMENTS, 
+/*Destruct*/SHADOW_BOLT, IMMOLATE, CONFLAGRATE, CHAOS_BOLT, RAIN_OF_FIRE, 
+ /*Afflict*/HAUNT, CORRUPTION, UNSTABLE_AFFLICTION, 
+   /*Other*/FEAR;
+        //Timers
+        uint32 Rain_of_fire_cd, Haunt_cd, conflagarate_cd, chaos_bolt_cd, fear_cd;
+
+        enum WarlockBaseSpells// all orignals
+        {
+            CURSE_OF_THE_ELEMENTS_1             = 1490,
+            SHADOW_BOLT_1                       = 686,
+            IMMOLATE_1                          = 348,
+            CONFLAGRATE_1                       = 17962,
+            CHAOS_BOLT_1                        = 50796,
+            RAIN_OF_FIRE_1                      = 5740,
+            HAUNT_1                             = 59164,
+            CORRUPTION_1                        = 172,
+            UNSTABLE_AFFLICTION_1               = 30404,
+            FEAR_1                              = 6215,
+        };
+        enum WarlockPassives
+        {
+        };
+    };
+};
+
+class voidwalker_bot : public CreatureScript
+{
+public:
+    voidwalker_bot() : CreatureScript("voidwalker_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new voidwalker_botAI(creature);
+    }
+
+    struct voidwalker_botAI : public bot_pet_ai
+    {
+        voidwalker_botAI(Creature* creature) : bot_pet_ai(creature) { }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (checkBotCast(victim, spellId, CLASS_NONE) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit*) { m_creatureOwner->SetBotsPetDied(); }
+
+        void DoNonCombatActions()
+        {}
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            GetInPosition(force, false);
+            SetBotCommandState(COMMAND_ATTACK);
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (IAmDead()) return;
+            if (me->GetVictim())
+                DoMeleeAttackIfReady();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            CheckAuras();
+            if (CCed(me)) return;
+
+            //TODO: add checks to help owner
+
+            if (!me->IsInCombat())
+                DoNonCombatActions();
+
+            if (!CheckAttackTarget(PET_TYPE_VOIDWALKER))
+                return;
+
+            DoNormalAttack(diff);
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent, true);
+            }
+            else
+                return;
+            if (MoveBehind(*opponent))
+                wait = 5;
+
+            //TORMENT
+            if (Torment_cd <= diff && me->GetDistance(opponent) <= 5 && (!tank || tank == me || opponent->GetVictim() == m_creatureOwner))
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, TORMENT))
+                    Torment_cd = 5000;
+                GC_Timer = temptimer;
+            }
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            if (m_creatureOwner->IsAIEnabled)
+                if (bot_minion_ai* ai = m_creatureOwner->GetBotMinionAI())
+                    ai->OnOwnerDamagedBy(u);
+        }
+
+        //debug
+        //void ListSpells(ChatHandler* ch) const
+        //{
+        //    ch->PSendSysMessage("Spells list:");
+        //    ch->PSendSysMessage("Torment: %u", TORMENT);
+        //    ch->PSendSysMessage("End of spells list.");
+        //}
+
+        void Reset()
+        {
+            Torment_cd = 0;
+
+            if (master && m_creatureOwner)
+            {
+                setStats(master->getLevel(), PET_TYPE_VOIDWALKER, true);
+                ApplyPassives(PET_TYPE_VOIDWALKER);
+                ApplyClassPassives();
+                SetBaseArmor(162 * master->getLevel());
+            }
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            CommonTimers(diff);
+            if (Torment_cd > diff)              Torment_cd -= diff;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            TORMENT                             = InitSpell(me, TORMENT_1);
+        }
+
+        void ApplyClassPassives() {}
+
+    private:
+        uint32 
+            TORMENT;
+        //Timers
+        uint32 Torment_cd;
+
+        enum VoidwalkerBaseSpells
+        {
+            TORMENT_1                           = 3716,
+        };
+        enum VoidwalkerPassives
+        {
+        };
+    };
+};
+
+void AddSC_warlock_bot()
+{
+    new warlock_bot();
+    new voidwalker_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_warrior_ai.cpp b/src/server/game/AI/NpcBots/bot_warrior_ai.cpp
new file mode 100644
index 0000000..a543fe4
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_warrior_ai.cpp
@@ -0,0 +1,1114 @@
+#include "bot_ai.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+#include "WorldSession.h"
+/*
+Warrior NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - Around 40-45%
+TODO: Thunder Clap, Piercing Howl, Challenging Shout, other tanking stuff
+*/
+class warrior_bot : public CreatureScript
+{
+public:
+    warrior_bot() : CreatureScript("warrior_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new warrior_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    struct warrior_botAI : public bot_minion_ai
+    {
+        warrior_botAI(Creature* creature) : bot_minion_ai(creature) { }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (checkBotCast(victim, spellId, CLASS_WARRIOR) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (IAmDead()) return;
+            if (me->GetVictim())
+                DoMeleeAttackIfReady();
+            else
+                Evade();
+
+            if (ragetimer <= diff)
+            {
+                if (!me->IsInCombat())
+                {
+                    if (getrage() > uint32(10.f*rageLossMult))
+                        me->SetPower(POWER_RAGE, rage - uint32(10.f*rageLossMult));//-1 rage per 1.5 sec
+                    else
+                        me->SetPower(POWER_RAGE, 0);//min
+                }
+                ragetimer = 1500;
+            }
+
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            if (checkAurasTimer == 0)
+            {
+                SS = SWEEPING_STRIKES && me->HasAura(SWEEPING_STRIKES);
+                CheckAuras();
+            }
+            BreakCC(diff);
+            if (CCed(me)) return;
+
+            if (GetHealthPCT(me) < 67 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, HEALINGPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+            CheckIntervene(diff);
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            if (Rand() < 30 && batcomShout_cd <= diff && GC_Timer <= diff && me->GetDistance(master) < 30 &&
+                !master->HasAura(BATTLESHOUT) &&
+                master->IsWithinLOSInMap(me) &&
+                doCast(me, BATTLESHOUT))
+                batcomShout_cd = SHOUT_CD;
+
+            if (!CheckAttackTarget(CLASS_WARRIOR))
+            {
+                if (tank != me && !me->IsInCombat() && battleStance != true && master->getAttackers().empty() && stancetimer <= diff)
+                    stanceChange(diff, 1);
+                return;
+            }
+
+            if (Rand() < 20 && BLOODRAGE && bloodrage_cd <= diff && me->IsInCombat() && getrage() < 600)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, BLOODRAGE))
+                {
+                    bloodrage_cd = BLOODRAGE_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+
+            Attack(diff);
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == (COMMAND_ATTACK) && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            GetInPosition(force, false);
+        }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit* u)
+        {
+            //victorious state emulation
+            if (me->getLevel() >= 5 && u->getLevel() + 9 >= me->getLevel())
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, VICTORIOUS_SPELL, true))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+        }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit*) { master->SetNpcBotDied(me->GetGUID()); }
+        void DoNonCombatActions(uint32 /*diff*/) {}
+
+        void modrage(int32 mod, bool set = false)
+        {
+            if (set && mod < 0)
+                return;
+            if (mod < 0 && rage < uint32(abs(mod)))
+            {
+                //debug set rage to 0
+                mod = 0;
+                set = true;
+                return;
+            }
+
+            if (set)
+                rage = mod ? mod*10 : 0;
+            else
+                rage += mod*10;
+
+            me->SetPower(POWER_RAGE, rage);
+        }
+
+        uint32 getrage()
+        {
+            rage = me->GetPower(POWER_RAGE);
+            return rage;
+        }
+
+        void BreakCC(uint32 diff)
+        {
+            if (me->HasAuraWithMechanic((1<<MECHANIC_FEAR)|(1<<MECHANIC_SAPPED)|(1<<MECHANIC_DISORIENTED)))
+            {
+                if (BERSERKERRAGE && berserkerRage_cd <= diff && GC_Timer <= diff && doCast(me, BERSERKERRAGE))
+                {
+                    berserkerRage_cd = BERSERKERRAGE_CD;
+                    if (me->getLevel() >= 54)
+                        doCast(me, 58096, true); //Berserker Rage Effect (434 unused)
+                    return;
+                }
+            }
+            bot_minion_ai::BreakCC(diff);
+        }
+
+        void Attack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent, true);
+            }
+            else
+                return;
+            //Keep stance in raid if tank
+            if (tank == me && defensiveStance != true && stancetimer <= diff)
+                stanceChange(diff, 2);
+            //SelfHeal
+            if (ENRAGED_REGENERATION)
+            {
+                if (Rand() < 40 && GetHealthPCT(me) < 40 && getrage() > 150 && regen_cd <= diff && GC_Timer <= diff &&
+                    me->HasAuraWithMechanic(MECHANIC_ENRAGED))
+                {
+                    temptimer = 0;
+                    if (doCast(me, ENRAGED_REGENERATION))
+                    {
+                        regen_cd = ENRAGED_REGENERATION_CD;
+                        GC_Timer = temptimer;
+                        return;
+                    }
+                }
+            }
+
+            AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+            float dist = me->GetExactDist(opponent);
+            float meleedist = me->GetDistance(opponent);
+            //charge + warbringer
+            if (CHARGE && charge_cd <= diff && dist > 11 && dist < 25 && me->HasInArc(M_PI, opponent) &&
+                (me->getLevel() >= 50 ||
+                (!me->IsInCombat() && (battleStance || stanceChange(diff, 1)))))
+            {
+                temptimer = GC_Timer;
+                if (me->getLevel() >= 29)
+                    me->RemoveMovementImpairingAuras();
+                if (doCast(opponent, CHARGE, me->IsInCombat()))
+                {
+                    charge_cd = CHARGE_CD;
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //intercept
+            if (INTERCEPT && intercept_cd <= diff && tank != me &&
+                getrage() > 100 && dist > 11 && dist < 25 && me->HasInArc(M_PI, opponent) &&
+                !CCed(opponent) && (berserkerStance || stanceChange(diff, 3)))
+            {
+                if (doCast(opponent, INTERCEPT))
+                {
+                    intercept_cd = INTERCEPT_CD;
+                    return;
+                }
+            }
+            //SelfHeal 2
+            if (VICTORY_RUSH && VICTORIOUS && meleedist <= 5 && GC_Timer <= diff &&
+                (b_attackers.size() <= 1 || (GetHealthPCT(me) < std::max<int32>(100 - b_attackers.size() * 10, 75))))
+            {
+                if (doCast(opponent, VICTORY_RUSH))
+                {
+                    me->RemoveAura(VICTORIOUS_SPELL);
+                    return;
+                }
+            }
+            //FEAR
+            if (INTIMIDATING_SHOUT && intimidatingShout_cd <= diff && GC_Timer <= diff && Rand() < 70 && getrage() > 250)
+            {
+                if (opponent->IsNonMeleeSpellCasted(false, false, true) && dist <= 8 &&
+                    !(opponent->ToCreature() && opponent->ToCreature()->GetCreatureType() == CREATURE_TYPE_UNDEAD))
+                {
+                    if (doCast(opponent, INTIMIDATING_SHOUT))
+                    {
+                        intimidatingShout_cd = INTIMIDATINGSHOUT_CD;
+                        return;
+                    }
+                }
+                Unit* fearTarget = NULL;
+                bool triggered = false;
+                uint8 tCount = 0;
+                //fear master's attackers
+                if (!m_attackers.empty() && 
+                    ((master->getClass() != CLASS_DEATH_KNIGHT && 
+                    master->getClass() != CLASS_WARRIOR && 
+                    master->getClass() != CLASS_PALADIN) || 
+                    GetHealthPCT(master) < 70))
+                {
+                    for(AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                        if (me->GetExactDist((*iter)) <= 8 && (*iter)->isTargetableForAttack())
+                        {
+                            ++tCount;
+                            fearTarget = (*iter);
+                            if (tCount > 1) break;
+                        }
+                    }
+                    if (tCount > 0 && !fearTarget)
+                    {
+                        fearTarget = opponent;
+                        triggered = true;
+                    }
+                    if (tCount > 1 && doCast(fearTarget, INTIMIDATING_SHOUT, triggered))
+                    {
+                        intimidatingShout_cd = INTIMIDATINGSHOUT_CD;
+                        return;
+                    }
+                }
+                //Defend myself
+                if (b_attackers.size() > 1)
+                {
+                    tCount = 0;
+                    fearTarget = NULL;
+                    triggered = false;
+                    for(AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                        if (me->GetExactDist((*iter)) <= 8 && (*iter)->isTargetableForAttack())
+                        {
+                            ++tCount;
+                            fearTarget = (*iter);
+                            if (tCount > 0) break;
+                        }
+                    }
+                    if (tCount > 0 && !fearTarget)
+                    {
+                        fearTarget = opponent;
+                        triggered = true;
+                    }
+                    if (tCount > 0 && doCast(fearTarget, INTIMIDATING_SHOUT, triggered))
+                    {
+                        intimidatingShout_cd = INTIMIDATINGSHOUT_CD;
+                        return;
+                    }
+                }
+            }//end FEAR
+            //OVERPOWER
+            if (OVERPOWER && Rand() < 50 && getrage() > 50 && meleedist <= 5 && GC_Timer <= diff &&
+                (battleStance || stancetimer <= diff))
+            {
+                if (me->HasAura(TASTE_FOR_BLOOD_BUFF))
+                {
+                    if (battleStance || stanceChange(diff, 1))
+                    {
+                        if (doCast(opponent, OVERPOWER))
+                        {
+                            me->RemoveAura(TASTE_FOR_BLOOD_BUFF);
+                            return;
+                        }
+                    }
+                }
+            }
+
+            if (MoveBehind(*opponent))
+                wait = 5;
+            //HAMSTRING
+            if (HAMSTRING && Rand() < 50 && getrage() > 100 && GC_Timer <= diff && meleedist <= 5 && opponent->isMoving() &&
+                (battleStance || berserkerStance || stancetimer <= diff) &&
+                !opponent->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT)))
+            {
+                if (battleStance || berserkerStance || stanceChange(diff, 5))
+                    if (doCast(opponent, HAMSTRING))
+                        return;
+            }
+            //UBERS
+            //Dont use RETA unless capable circumstances
+            if (Rand() < 20 && uber_cd <= diff && GC_Timer <= diff)
+            {
+                if (RETALIATION && b_attackers.size() > 4)
+                {
+                    if (doCast(me, RETALIATION))
+                    {
+                        uber_cd = UBER_CD;
+                        return;
+                    }
+                }
+                //Dont use RECKL unless capable circumstances
+                if (RECKLESSNESS && tank != me &&
+                    (m_attackers.size() > 3 || opponent->GetHealth() > me->GetHealth() * 10))
+                {
+                    if (doCast(me, RECKLESSNESS))
+                    {
+                        uber_cd = UBER_CD;
+                        return;
+                    }
+                }
+            }
+            //DEATHWISH
+            if (DEATHWISH && Rand() < 20 && deathwish_cd <= diff && GC_Timer <= diff && 
+                getrage() > 100 && opponent->GetHealth() > me->GetHealth()/2)
+            {
+                if (doCast(me, DEATHWISH))
+                {
+                    deathwish_cd = DEATHWISH_CD;
+                    return;
+                }
+            }
+            //TAUNT
+            Unit* u = opponent->GetVictim();
+            if (TAUNT && taunt_cd <= diff && u && u != me && u != tank && dist <= 30 &&
+                !CCed(opponent) && !isTankingClass(u->getClass()) && (IsInBotParty(u) || tank == me) &&
+                (defensiveStance || (stancetimer <= diff && stanceChange(diff, 2))))//No GCD
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, TAUNT, true))
+                {
+                    taunt_cd = TAUNT_CD;
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //EXECUTE
+            if (EXECUTE && tank != me && Rand() < 70 && GC_Timer <= diff && getrage() > 100 &&
+                meleedist <= 5 && GetHealthPCT(opponent) < 20 && 
+                (battleStance || berserkerStance || (stancetimer <= diff && stanceChange(diff, 5))))
+            {
+                if (doCast(opponent, EXECUTE))
+                {
+                    //sudden death part 2
+                    if (me->getLevel() >= 50 && getrage() <= 200)
+                       modrage(10, true);
+                    return;
+                }
+            }
+            //SUNDER
+            if (SUNDER && Rand() < 35 && meleedist <= 5 && tank == me &&
+                opponent->GetHealth() > me->GetMaxHealth() &&
+                GC_Timer <= diff && getrage() > 150 && (sunder_cd <= diff || getrage() > 500))
+            {
+                Aura* sunder = opponent->GetAura(SUNDER, me->GetGUID());
+                if ((!sunder || sunder->GetStackAmount() < 5 || sunder->GetDuration() < 15000) &&
+                    doCast(opponent, SUNDER))
+                {
+                    sunder_cd = SUNDER_CD;
+                    GC_Timer = 800;
+                    return;
+                }
+            }
+            //SS
+            if (SWEEPING_STRIKES && sweeping_strikes_cd <= diff && tank != me && Rand() < 25 &&
+                (battleStance || berserkerStance || stancetimer <= diff) &&
+                (b_attackers.size() > 1 || FindSplashTarget(7, opponent)))
+            {
+                temptimer = GC_Timer;
+                if ((battleStance || berserkerStance || stanceChange(diff, 5)) &&
+                    doCast(me, SWEEPING_STRIKES, true))//no rage use as with glyph
+                {
+                    SS = true;
+                    sweeping_strikes_cd = SWEEPING_STRIKES_CD;
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //WHIRLWIND
+            if (WHIRLWIND && Rand() < 50 && whirlwind_cd <= diff && GC_Timer <= diff && getrage() >= 200 && tank != me &&
+               (FindSplashTarget(7, opponent) || (getrage() > 800 && dist <= 7)) &&
+               (berserkerStance || stancetimer <= diff))
+            {
+                if ((berserkerStance || stanceChange(diff, 3)) &&
+                    doCast(me, WHIRLWIND))
+                {
+                    whirlwind_cd = WHIRLWIND_CD;
+                    return;
+                }
+            }
+            //BLADESTORM
+            if (BLADESTORM && bladestorm_cd <= diff && GC_Timer <= diff &&
+               getrage() >= 250 && (Rand() < 20 || me->HasAura(RECKLESSNESS)) &&
+               (b_attackers.size() > 1 || opponent->GetHealth() > me->GetMaxHealth()))
+            {
+                if (doCast(me, BLADESTORM))
+                {
+                    bladestorm_cd = BLADESTORM_CD;
+                    return;
+                }
+            }
+            //Mortal Strike
+            if (MORTALSTRIKE && getrage() > 200 && meleedist <= 5 && mortalStrike_cd <= diff && GC_Timer <= diff)
+            {
+                if (doCast(opponent, MORTALSTRIKE))
+                {
+                    mortalStrike_cd = MORTALSTRIKE_CD;
+                    slam_cd = 0;//reset here
+                }
+            }
+            //Slam
+            bool triggered = (mortalStrike_cd == MORTALSTRIKE_CD);
+            if (SLAM && Rand() < (30 + triggered * 30) && slam_cd <= diff && getrage() > 150 && meleedist <= 5)
+            {
+                if (doCast(opponent, SLAM, true))
+                {
+                    slam_cd = 3000; //must be > MORTALSTRIKE_CD/2
+                    modrage(-15);
+                    return;
+                }
+            }
+            //PUMMEL
+            if (PUMMEL && Rand() < 80 && pummel_cd <= diff && getrage() > 100 && meleedist <= 5 &&
+                opponent->IsNonMeleeSpellCasted(false))
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, PUMMEL))
+                {
+                    pummel_cd = PUMMEL_CD;
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //REND
+            if (REND && Rand() < 50 && getrage() > 100 && GC_Timer <= diff && meleedist <= 5 &&
+                opponent->GetHealth() > me->GetHealth()/2 &&
+                !opponent->HasAura(REND, me->GetGUID()) &&
+                (battleStance || defensiveStance || (stancetimer <= diff && stanceChange(diff, 4))))
+            {
+                if (doCast(opponent, REND))
+                    return;
+            }
+            //Cleave
+            if (Rand() < 30 && CLEAVE && cleave_cd <= diff && me->getLevel() >= 20 && getrage() > 250 && meleedist <= 5)
+            {
+                temptimer = GC_Timer;
+                u = FindSplashTarget(5);
+                if (u && doCast(opponent, CLEAVE))
+                {
+                    cleave_cd = me->getAttackTimer(BASE_ATTACK); //once per swing, prevents rage loss
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            else {}//HEROIC STRIKE placeholder
+            //DISARM DEPRECATED
+            /*if (disarm_cd <= diff && meleedist < 5 &&
+                (opponent->GetVictim()->GetGUID() == master->GetGUID() || 
+                opponent->GetVictim()->GetGUID() == m_creature->GetGUID()) &&
+                getrage() > 15 &&
+                !HasAuraName(opponent, GetSpellName(DISARM)) &&
+                GC_Timer <= diff)
+            {
+                if (opponent->getClass() == CLASS_ROGUE  ||
+                    opponent->getClass() == CLASS_WARRIOR   ||
+                    opponent->getClass() == CLASS_SHAMAN    ||
+                    opponent->getClass() == CLASS_PALADIN)
+                {
+                    if (defensiveStance == true)
+                    {
+                        doCast(opponent, DISARM, true);
+                        //rage -= 100;
+                        disarm_cd = DISARM_CD;
+                    }
+                    else stanceChange(diff, 2);
+                }
+            }*/
+        }//end Attack
+
+        void CheckIntervene(uint32 diff)
+        {
+            if (INTERVENE && intervene_cd <= diff && getrage() > 100 && Rand() < ((tank == me) ? 80 : 30) &&
+                (defensiveStance || stancetimer <= diff))
+            {
+                if (!master->IsInCombat() && master->getAttackers().empty() && master->isMoving())
+                {
+                    float mydist = me->GetExactDist(master);
+                    if (mydist < 24 && mydist > 19 && (defensiveStance || stanceChange(diff, 2)))
+                    {
+                        temptimer = GC_Timer;
+                        if (doCast(master, INTERVENE))
+                        {
+                            intervene_cd = INTERVENE_CD;
+                            GC_Timer = temptimer;
+                            Follow(true);
+                            return;
+                        }
+                    }
+                }
+                Group* gr = master->GetGroup();
+                if (!gr)
+                {
+                    if (GetHealthPCT(master) < 95 && !master->getAttackers().empty() &&
+                        me->getAttackers().size() <= master->getAttackers().size())
+                    {
+                        float dist = me->GetExactDist(master);
+                        if (dist > 25 || dist < 10) return;
+                        if (!(defensiveStance || stanceChange(diff, 2))) return;
+                        temptimer = GC_Timer;
+                        if (doCast(master, INTERVENE))
+                        {
+                            intervene_cd = INTERVENE_CD;
+                            GC_Timer = temptimer;
+                            return;
+                        }
+                    }
+                }
+                else
+                {
+                    bool Bots = false;
+                    float dist;
+                    for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        Player* tPlayer = itr->GetSource();
+                        if (!tPlayer) continue;
+                        if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+                        if (tPlayer->FindMap() != me->GetMap()) continue;
+                        if (tPlayer->HaveBot())
+                            Bots = true;
+                        if (tPlayer->isDead() || GetHealthPCT(tPlayer) > 90 || tank == tPlayer) continue;
+                        if (tPlayer->getAttackers().size() < me->getAttackers().size()) continue;
+                        dist = me->GetExactDist(tPlayer);
+                        if (dist > 24 || dist < 10) continue;
+                        if (defensiveStance || stanceChange(diff, 2))
+                        {
+                            temptimer = GC_Timer;
+                            if (doCast(tPlayer, INTERVENE))
+                            {
+                                intervene_cd = INTERVENE_CD;
+                                GC_Timer = temptimer;
+                                return;
+                            }
+                        }
+                    }
+                    if (!Bots) return;
+                    for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        Player* tPlayer = itr->GetSource();
+                        if (!tPlayer || !tPlayer->HaveBot()) continue;
+                        if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+                        if (tPlayer->FindMap() != me->GetMap()) continue;
+                        for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+                        {
+                            Creature* bot = tPlayer->GetBotMap(i)->_Cre();
+                            if (!bot || !bot->IsInWorld() || bot == me || bot->isDead()) continue;
+                            if (GetHealthPCT(bot) > 90 || tank == bot) continue;
+                            dist = me->GetExactDist(bot);
+                            if (dist > 25 || dist < 10) continue;
+                            if (bot->getAttackers().size() <= me->getAttackers().size()) continue;
+                            if (defensiveStance || stanceChange(diff, 2))
+                            {
+                                temptimer = GC_Timer;
+                                if (doCast(bot, INTERVENE))
+                                {
+                                    intervene_cd = INTERVENE_CD/2;
+                                    GC_Timer = temptimer;
+                                    return;
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            switch (spell->Id)
+            {
+                case OVERPOWER_1:
+                    //Unrelenting Assault
+                    if (UNRELENTING_ASSAULT && target->HasUnitState(UNIT_STATE_CASTING))
+                        target->CastSpell(target, UNRELENTING_ASSAULT_SPELL, true);
+                case MORTALSTRIKE_1:
+                case CLEAVE_1:
+                case SLAM_1:
+                case EXECUTE_1:
+                case WHIRLWIND_1:
+                case PUMMEL_1:
+                case SUNDER_1:
+                case VICTORY_RUSH_1:
+                case 50622: //whirlwind (bladestorm)
+                case 44949: //whirlwind off-hand
+                    //Warrior T13 Arms and Fury 4P Bonus (Colossus Smash)
+                    if (me->getLevel() >= 50 && urand(1, 100) <= 18)
+                        me->CastSpell(target, COLOSSUS_SMASH_EFFECT, true);
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        bool stanceChange(uint32 diff, uint8 stance)
+        {
+            if (!(stancetimer <= diff) || !stance)
+                return false;
+
+            if (stance == 5)
+            {
+                switch (urand(0,1))
+                {
+                    case 0:
+                        stance = 1;
+                        break;
+                    case 1:
+                        stance = me->getLevel() < 30 ? 1 : (urand(1,100) > 75 ? 3 : 1);
+                        break;
+                }
+            }
+            else if (stance == 4)
+            {
+                switch (urand(0,1))
+                {
+                    case 0:
+                        stance = 1;
+                        break;
+                    case 1:
+                        stance = me == tank ? 2 : 1;
+                        break;
+                }
+            }
+
+            if (stance == 2 && me->getLevel() < 10)
+                return false;
+            if (stance == 3 && me->getLevel() < 30)
+                return false;
+
+            temptimer = GC_Timer;
+            //stance mastery impl
+            uint32 temprage = 0;
+            uint32 myrage = me->GetPower(POWER_RAGE);
+            if (me->getLevel() >= 20)
+                temprage = myrage > 500 ? 500 : myrage;
+            else if (me->getLevel() >= 15)
+                temprage = myrage > 250 ? 250 : myrage;
+            switch (stance)
+            {
+                case 1:
+                    if (doCast(me, BATTLESTANCE))
+                    {
+                        if (me->HasAura(BATTLESTANCE)) 
+                        {
+                            battleStance = true;
+                            defensiveStance = false;
+                            berserkerStance = false;
+                            me->SetPower(POWER_RAGE, temprage);
+                            stancetimer = 1520 - me->getLevel() * 12;//500 on 85
+                            GC_Timer = temptimer;
+                            return true;
+                        }
+                    }
+                    break;
+                case 2:
+                    if (doCast(me, DEFENSIVESTANCE))
+                    {
+                        if (me->HasAura(DEFENSIVESTANCE))
+                        {
+                            defensiveStance = true;
+                            battleStance = false;
+                            berserkerStance = false;
+                            me->SetPower(POWER_RAGE, temprage);
+                            stancetimer = 1520 - me->getLevel() * 12;//500 on 85
+                            GC_Timer = temptimer;
+                            return true;
+                        }
+                    }
+                    break;
+                case 3:
+                    if (doCast(me, BERSERKERSTANCE))
+                    {
+                        if (me->HasAura(BERSERKERSTANCE))
+                        {
+                            berserkerStance = true;
+                            battleStance = false;
+                            defensiveStance = false;
+                            me->SetPower(POWER_RAGE, temprage);
+                            stancetimer = 1520 - me->getLevel() * 12;//500 on 85
+                            GC_Timer = temptimer;
+                            return true;
+                        }
+                    }
+                    break;
+                default:
+                    break;
+            }
+            GC_Timer = temptimer;
+            return false;
+        }
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //Taste For Blood part 1: 60% additional critical chance for Overpower
+                if (lvl >= 30 && spellId == OVERPOWER)
+                    aftercrit += 60.f;
+                //Cruelty: 10% additional crit chance for Bloodthirst, Mortal Strike and Shield Slam
+                if (lvl >= 10 && (spellId == MORTALSTRIKE/* || || */))
+                    aftercrit += 10.f;
+                //Incite: 15% additional crit chance for Heroic Strike (lvl 10) TODO
+
+                //second roll (may be illogical)
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //2.1 crit damage bonus
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                //Impale: 20% crit damage bonus for all abilities
+                if (lvl >= 20)
+                    pctbonus += 0.10f;
+            }
+
+            //2.2 normal damage
+
+            //Lambs to the Slaughter: 10% bonus damage for Execute, Overpower, Slam and MS per stack
+            if (lvl >= 50 && spellId == EXECUTE || spellId == OVERPOWER || spellId == SLAM || spellId == MORTALSTRIKE)
+            {
+                if (Aura* sl = me->GetAura(LAMBS_TO_THE_SLAUGHTER_BUFF))
+                    pctbonus += 0.1f * sl->GetStackAmount();
+            }
+            //Meat Cleaver: 30% bonus damage for Whirlwind and Cleave (3 stacks) - placeholder
+            if (lvl >= 50 && spellId == WHIRLWIND || spellId == CLEAVE)
+                pctbonus += 0.3f;
+            //Improved Slam: 20% bonus damage for Slam
+            if (lvl >= 40 && spellId == SLAM)
+                pctbonus += 0.2f;
+            //War Academy: 15% bonus damage for MS, Raging Blow, Devastate, Victory Rush and Slam
+            if (lvl >= 10 && (spellId == MORTALSTRIKE || spellId == SLAM/* || || || */))
+                pctbonus += 0.15f;
+
+            //2.3 debug
+            //execute 250% - fix too low damage
+            if (spellId == EXECUTE)
+                pctbonus += 1.5f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            switch (spell->Id)
+            {
+                case VICTORIOUS_SPELL:
+                    VICTORIOUS = true;
+                    break;
+                default:
+                    break;
+            }
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            slam_cd = 0;
+            regen_cd = 20000;
+            sweeping_strikes_cd = 0;
+            charge_cd = 0;
+            deathwish_cd = 7000;
+            mortalStrike_cd = 0;
+            uber_cd = 10000;
+            berserkerRage_cd = 0;
+            batcomShout_cd = 0;
+            intercept_cd = 0;
+            intimidatingShout_cd = 0;
+            pummel_cd = 0;
+            whirlwind_cd = 5000;
+            cleave_cd = 0;
+            bladestorm_cd = 10000;
+            bloodrage_cd = 0;
+            intervene_cd = 0;
+            taunt_cd = 5000;
+            sunder_cd = 0;
+            stancetimer = 0;
+            ragetimer = 1500;
+
+            battleStance = true;
+            defensiveStance = false;
+            berserkerStance = false;
+
+            rageIncomeMult = sWorld->getRate(RATE_POWER_RAGE_INCOME);
+            rageLossMult = sWorld->getRate(RATE_POWER_RAGE_LOSS);
+            me->setPowerType(POWER_RAGE);
+            rage = 0;
+
+            if (master)
+            {
+                setStats(CLASS_WARRIOR, me->getRace(), master->getLevel(), true);
+                ApplyClassPassives();
+                ApplyPassives(CLASS_WARRIOR);
+            }
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            CommonTimers(diff);
+            if (regen_cd > diff)                    regen_cd -= diff;
+            if (slam_cd > diff)                     slam_cd -= diff;
+            if (batcomShout_cd > diff)              batcomShout_cd -= diff;
+            if (sweeping_strikes_cd > diff)         sweeping_strikes_cd -= diff;
+            if (deathwish_cd > diff)                deathwish_cd -= diff;
+            if (mortalStrike_cd > diff)             mortalStrike_cd -= diff;
+            if (uber_cd > diff)                     uber_cd -= diff;
+            if (berserkerRage_cd > diff)            berserkerRage_cd -= diff;
+            if (charge_cd > diff)                   charge_cd -= diff;
+            if (intercept_cd > diff)                intercept_cd -= diff;
+            if (intimidatingShout_cd > diff)        intimidatingShout_cd -= diff;
+            if (pummel_cd > diff)                   pummel_cd -= diff;
+            if (whirlwind_cd > diff)                whirlwind_cd -= diff;
+            if (bladestorm_cd > diff)               bladestorm_cd -= diff;
+            if (cleave_cd > diff)                   cleave_cd -= diff;
+            if (bloodrage_cd > diff)                bloodrage_cd -= diff;
+            if (intervene_cd > diff)                intervene_cd -= diff;
+            if (taunt_cd > diff)                    taunt_cd -= diff;
+            if (sunder_cd > diff)                   sunder_cd -= diff;
+
+            if (stancetimer > diff)                 stancetimer -= diff;
+            if (ragetimer > diff)                   ragetimer -= diff;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            //CHALLENGING_SHOUT                       = InitSpell(me, CHALLENGING_SHOUT_1);
+            INTIMIDATING_SHOUT                      = InitSpell(me, INTIMIDATING_SHOUT_1);
+            ENRAGED_REGENERATION                    = InitSpell(me, ENRAGED_REGENERATION_1);
+            CHARGE                                  = InitSpell(me, CHARGE_1);
+            OVERPOWER                               = InitSpell(me, OVERPOWER_1);
+   /*Quest*/TAUNT                       = lvl >= 10 ? TAUNT_1 : 0;
+            //DISARM                                  = InitSpell(DISARM_1);
+            BLOODRAGE                               = InitSpell(me, BLOODRAGE_1);
+            BERSERKERRAGE                           = InitSpell(me, BERSERKERRAGE_1);
+            INTERCEPT                               = InitSpell(me, INTERCEPT_1);
+            CLEAVE                                  = InitSpell(me, CLEAVE_1);
+            HAMSTRING                               = InitSpell(me, HAMSTRING_1);
+            INTERVENE                               = InitSpell(me, INTERVENE_1);
+            WHIRLWIND                               = InitSpell(me, WHIRLWIND_1);
+  /*Talent*/BLADESTORM                  = lvl >= 60 ? BLADESTORM_1 : 0;
+            BATTLESHOUT                             = InitSpell(me, BATTLESHOUT_1);
+            REND                                    = InitSpell(me, REND_1);
+            EXECUTE                                 = InitSpell(me, EXECUTE_1);
+            PUMMEL                                  = InitSpell(me, PUMMEL_1);
+  /*Talent*/MORTALSTRIKE                            = InitSpell(me, MORTALSTRIKE_1);
+            SLAM                                    = InitSpell(me, SLAM_1);
+   /*Quest*/SUNDER                      = lvl >= 10 ? InitSpell(me, SUNDER_1) : 0;
+  /*Talent*/SWEEPING_STRIKES            = lvl >= 30 ? SWEEPING_STRIKES_1 : 0;
+            BATTLESTANCE                            = BATTLESTANCE_1;
+   /*Quest*/DEFENSIVESTANCE             = lvl >= 10 ? DEFENSIVESTANCE_1 : 0;
+   /*Quest*/BERSERKERSTANCE             = lvl >= 30 ? BERSERKERSTANCE_1 : 0;
+            RECKLESSNESS                            = InitSpell(me, RECKLESSNESS_1);
+            RETALIATION                             = InitSpell(me, RETALIATION_1);
+  /*Talent*/DEATHWISH                   = lvl >= 30 ? DEATHWISH_1 : 0;
+            VICTORY_RUSH                            = InitSpell(me, VICTORY_RUSH_1);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+            if (level >= 61)
+                RefreshAura(WC2); //10%
+            else if (level >= 59)
+                RefreshAura(WC1); //5%
+            if (level >= 53)
+                RefreshAura(LAMBS_TO_THE_SLAUGHTER); //10% x3
+            if (level >= 37)
+                RefreshAura(FLURRY3); //30%
+            else if (level >= 35)
+                RefreshAura(FLURRY2); //20%
+            else if (level >= 33)
+                RefreshAura(FLURRY1); //10%
+            if (level >= 60)
+                RefreshAura(RAMPAGE);
+            if (level >= 45)
+                RefreshAura(BLOOD_FRENZY);
+            if (level >= 40)
+                RefreshAura(SECOND_WIND);
+            if (level >= 40)
+                RefreshAura(TOUGHNESS,2); //-60%
+            else if (level >= 15)
+                RefreshAura(TOUGHNESS); //-30%
+            if (level >= 35)
+                RefreshAura(IMP_HAMSTRING);
+            if (level >= 35)
+                UNRELENTING_ASSAULT = true;
+            if (level >= 30)
+                RefreshAura(TASTE_FOR_BLOOD3); //100%
+            else if (level >= 28)
+                RefreshAura(TASTE_FOR_BLOOD2); //66%
+            else if (level >= 25)
+                RefreshAura(TASTE_FOR_BLOOD1); //33%
+            if (level >= 13)
+                RefreshAura(BLOOD_CRAZE3);
+            else if (level >= 11)
+                RefreshAura(BLOOD_CRAZE2);
+            else if (level >= 10)
+                RefreshAura(BLOOD_CRAZE1);
+            //BloodRage Absorb
+            if (level >= 60)
+                RefreshAura(WARRIOR_T10_4P);
+        }
+
+    private:
+        uint32
+  /*Shouts*/INTIMIDATING_SHOUT, BATTLESHOUT, CHALLENGING_SHOUT, 
+ /*Charges*/CHARGE, INTERCEPT, INTERVENE, 
+  /*Damage*/OVERPOWER, CLEAVE, REND, EXECUTE, WHIRLWIND, BLADESTORM, MORTALSTRIKE, SLAM, 
+ /*Stances*/BATTLESTANCE, DEFENSIVESTANCE, BERSERKERSTANCE, 
+   /*Ubers*/RECKLESSNESS, RETALIATION, DEATHWISH, 
+  /*Others*/TAUNT, DISARM, BLOODRAGE, ENRAGED_REGENERATION, VICTORY_RUSH,
+        BERSERKERRAGE, HAMSTRING, PUMMEL, SUNDER, SWEEPING_STRIKES;
+
+        //CDs/Timers/misc
+/*shts*/uint32 batcomShout_cd, intimidatingShout_cd;
+/*chrg*/uint32 charge_cd, intercept_cd, intervene_cd;
+ /*Dmg*/uint32 mortalStrike_cd, slam_cd, whirlwind_cd, cleave_cd, bladestorm_cd;
+/*else*/uint32 regen_cd, sweeping_strikes_cd, deathwish_cd, uber_cd, berserkerRage_cd, pummel_cd, 
+            bloodrage_cd, taunt_cd, sunder_cd;
+/*tmrs*/uint32 stancetimer, ragetimer;
+/*misc*/uint32 rage;
+/*misc*/float rageIncomeMult, rageLossMult;
+/*Chck*/bool battleStance, defensiveStance, berserkerStance, SS, UNRELENTING_ASSAULT, VICTORIOUS;
+
+        enum WarriorBaseSpells
+        {
+            //CHALLENGING_SHOUT_1                     = 1161,
+            INTIMIDATING_SHOUT_1                    = 5246,
+            ENRAGED_REGENERATION_1                  = 55694,
+            CHARGE_1                                = 100,//11578,
+            OVERPOWER_1                             = 7384,
+            TAUNT_1                                 = 355,
+            //DISARM_1                                = 676,
+            BLOODRAGE_1                             = 29131,//2687,
+            BERSERKERRAGE_1                         = 18499,
+            INTERCEPT_1                             = 20252,
+            CLEAVE_1                                = 90981,//'90981 - (150% damage 3 targets)'//845,
+            HAMSTRING_1                             = 1715,
+            INTERVENE_1                             = 3411,
+            WHIRLWIND_1                             = 1680,
+            BLADESTORM_1                            = 46924,
+            BATTLESHOUT_1                           = 6673,
+            REND_1                                  = 772,
+            EXECUTE_1                               = 5308,
+            PUMMEL_1                                = 6552,
+            MORTALSTRIKE_1                          = 12294,
+            SLAM_1                                  = 1464,
+            SUNDER_1                                = 7386,
+            SWEEPING_STRIKES_1                      = 12328,
+            BATTLESTANCE_1                          = 2457,
+            DEFENSIVESTANCE_1                       = 71,
+            BERSERKERSTANCE_1                       = 2458,
+            RECKLESSNESS_1                          = 13847,//1719, original warrior spell
+            RETALIATION_1                           = 20230,
+            DEATHWISH_1                             = 12292,
+            VICTORY_RUSH_1                          = 34428
+        };
+        enum WarriorPassives
+        {
+        //Talents
+            WC1  /*WRECKING CREW1*/                 = 46867,
+            WC2  /*WRECKING CREW2*/                 = 56611,
+            FLURRY1                                 = 16256,
+            FLURRY2                                 = 16281,
+            FLURRY3                                 = 16282,
+            BLOOD_CRAZE1                            = 16487,
+            BLOOD_CRAZE2                            = 16489,
+            BLOOD_CRAZE3                            = 16492,
+            TASTE_FOR_BLOOD1                        = 56636,
+            TASTE_FOR_BLOOD2                        = 56637,
+            TASTE_FOR_BLOOD3                        = 56638,
+            BLOOD_FRENZY                            = 29859,
+            RAMPAGE                                 = 29801,
+            SECOND_WIND                             = 29838,//rank 2
+            TOUGHNESS                               = 12762,//rank 3
+            IMP_HAMSTRING                           = 12668,//rank 2
+            LAMBS_TO_THE_SLAUGHTER                  = 84588,//rank 3
+        //other
+            WARRIOR_T10_4P                          = 70844
+        };
+        enum WarriorSpecial
+        {
+            TASTE_FOR_BLOOD_BUFF                    = 60503,
+            LAMBS_TO_THE_SLAUGHTER_BUFF             = 84586,
+            UNRELENTING_ASSAULT_SPELL               = 65925,//64849
+            VICTORIOUS_SPELL                        = 32216,
+            COLOSSUS_SMASH_EFFECT                   = 108126
+        };
+        enum WarriorCooldowns
+        {
+            ENRAGED_REGENERATION_CD = 90000,  //1.5 min
+            SWEEPING_STRIKES_CD     = 20000,
+            CHARGE_CD               = 12000,
+            DEATHWISH_CD            = 144000, //3 min improved -20%
+            MORTALSTRIKE_CD         = 4500,
+            UBER_CD                 = 150000, //RETALIATION_RECKLESSNESS_SHIELDWALL 2.5 min NEED SEPARATE
+            BERSERKERRAGE_CD        = 25000,
+            INTERCEPT_CD            = 20000,  //30 sec improved -10
+            INTIMIDATINGSHOUT_CD    = 45000,
+            PUMMEL_CD               = 9000,
+            WHIRLWIND_CD            = 6500,   //average assuming ~20% chance to strike 4+ targets
+            BLADESTORM_CD           = 60000,
+            BLOODRAGE_CD            = 20000,  //generic
+            //DISARM_CD               = 40000,
+            INTERVENE_CD            = 20000,  //-10 sec for bots
+            SHOUT_CD                = 60000,
+            //SPELLREFLECTION_CD      = 8000,
+            TAUNT_CD                = 8000,
+            SUNDER_CD               = 7000
+        };
+    };
+};
+
+void AddSC_warrior_bot()
+{
+    new warrior_bot();
+}
diff --git a/src/server/game/AI/NpcBots/botcommands.cpp b/src/server/game/AI/NpcBots/botcommands.cpp
new file mode 100644
index 0000000..f8dbfc6
--- /dev/null
+++ b/src/server/game/AI/NpcBots/botcommands.cpp
@@ -0,0 +1,633 @@
+/*
+Name: script_bot_commands
+%Complete: ???
+Comment: Npcbot related commands
+Category: commandscripts/custom/
+*/
+
+#include "bot_ai.h"
+#include "bothelper.h"
+#include "Chat.h"
+#include "Config.h"
+#include "Group.h"
+#include "Language.h"
+#include "Player.h"
+#include "ScriptedGossip.h"
+#include "ScriptMgr.h"
+
+class script_bot_commands : public CommandScript
+{
+public:
+    script_bot_commands() : CommandScript("script_bot_commands") { }
+
+    ChatCommand* GetCommands() const
+    {
+        static ChatCommand npcbotCommandTable[] =
+        {
+            { "info",           SEC_PLAYER,         false, &HandleNpcBotInfoCommand,                    "", NULL },
+            { "add",            SEC_PLAYER,         false, &HandleNpcBotAddCommand,                     "", NULL },
+            { "revive",         SEC_MODERATOR,      false, &HandleNpcBotReviveCommand,                  "", NULL },
+            { "remove",         SEC_PLAYER,         false, &HandleNpcBotRemoveCommand,                  "", NULL },
+            { "reset",          SEC_PLAYER,         false, &HandleNpcBotResetCommand,                   "", NULL },
+            { "command",        SEC_PLAYER,         false, &HandleNpcBotCommandCommand,                 "", NULL },
+            { "distance",       SEC_PLAYER,         false, &HandleNpcBotDistanceCommand,                "", NULL },
+            { "helper",         SEC_PLAYER,         false, &HandleBotHelperCommand,                     "", NULL },
+            //{ "reloadequips",   SEC_ADMINISTRATOR,  false, &HandleReloadEquipsCommand,                  "", NULL },
+            { NULL,             0,                  false, NULL,                                        "", NULL }
+        };
+
+        static ChatCommand commandTable[] =
+        {
+            { "maintank",       SEC_PLAYER,         false, &HandleMainTankCommand,                      "", NULL },
+            { "mt",             SEC_PLAYER,         false, &HandleMainTankCommand,                      "", NULL },
+            { "npcbot",         SEC_PLAYER,         false, NULL,                          "", npcbotCommandTable },
+            { NULL,             0,                  false, NULL,                                        "", NULL }
+        };
+        return commandTable;
+    }
+
+    //static bool HandleReloadEquipsCommand(ChatHandler* handler, const char* /*args*/)
+    //{
+    //    sLog->outInfo(LOG_FILTER_GENERAL, "Re-Loading Creature Equips...");
+    //    sObjectMgr->LoadEquipmentTemplates();
+    //    handler->SendGlobalGMSysMessage("DB table `creature_equip_template` (creature equipment) reloaded.");
+    //    return true;
+    //}
+
+    static bool HandleBotHelperCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* player = handler->GetSession()->GetPlayer();
+        handler->SetSentErrorMessage(true);
+        if (/*player->IsInCombat() ||*/
+            player->isDead() ||
+            !player->IsAlive() ||
+            player->IsInFlight() ||
+            player->IsCharmed() ||
+            bot_ai::CCed(player))
+        {
+            handler->SendSysMessage("You cannot do this right now");
+            return false;
+        }
+        //close current menu
+        player->PlayerTalkClass->SendCloseGossip();
+        if (player->GetTrader())
+            player->GetSession()->SendCancelTrade();
+
+        BotHelper* hlpr = player->GetBotHelper();
+        if (!hlpr)
+        {
+            hlpr = new BotHelper(player);
+            player->SetBotHelper(hlpr);
+        }
+        return hlpr->OnGossipHello(player);
+    }
+
+    static bool HandleMainTankCommand(ChatHandler* handler, const char* args)
+    {
+        Group* group = handler->GetSession()->GetPlayer()->GetGroup();
+        if (!group)
+        {
+            handler->PSendSysMessage("Must be in a group to use main tank command.");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        uint64 myguid = handler->GetSession()->GetPlayer()->GetGUID();
+        if (!group->IsLeader(myguid) && !group->IsAssistant(myguid))
+        {
+            handler->PSendSysMessage("you have no permission to set main tank.");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (!*args)
+        {
+            if (uint64 selection = handler->GetSession()->GetPlayer()->GetSelection())
+            {
+                if (group->IsMember(selection))
+                {
+                    if (Unit* u = ObjectAccessor::FindUnit(selection))
+                    {
+                        bool isabot = u->GetTypeId() == TYPEID_UNIT && u->ToCreature()->GetIAmABot();
+                        if (isabot && group->GetMemberSlots().size() < 3 && handler->GetSession()->GetSecurity() == SEC_PLAYER)
+                        {
+                            handler->PSendSysMessage("Your party is too small to set a npcbot main tank.");
+                            handler->SetSentErrorMessage(true);
+                            return false;
+                        }
+                        group->RemoveUniqueGroupMemberFlag(MEMBER_FLAG_MAINTANK);
+                        Group::MemberSlotList const& members = group->GetMemberSlots();
+                        for (Group::MemberSlotList::const_iterator itr = members.begin(); itr != members.end(); ++itr)
+                        {
+                            uint8 flags = itr->flags;
+                            if (group->isRaidGroup())
+                            {
+                                //try to set flags in group (will fail if not raid)
+                                group->SetGroupMemberFlag(itr->guid, itr->guid == selection, MEMBER_FLAG_MAINTANK);
+                            }
+                            else //force flags for non-raid group (DB only) this will allow bots to find tank
+                            {
+                                if (itr->guid == selection && !(flags & MEMBER_FLAG_MAINTANK))
+                                    flags |= MEMBER_FLAG_MAINTANK;
+                            }
+                            //store result if DB
+                            if (itr->guid != selection || !group->isRaidGroup())
+                            {
+                                PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_GROUP_MEMBER_FLAG);
+                                stmt->setUInt8(0, flags);
+                                stmt->setUInt32(1, GUID_LOPART(itr->guid));
+                                CharacterDatabase.Execute(stmt);
+                            }
+                            //send result to players and their bots
+                            if (!IS_PLAYER_GUID(itr->guid))
+                                continue;
+                            if (Player* player = ObjectAccessor::FindPlayer(itr->guid))
+                            {
+                                ChatHandler chp(player->GetSession());
+                                chp.PSendSysMessage("Main tank is set to %s.", u->GetName().c_str());
+                                player->SetBotTank(selection);
+                                if (player->HaveBot())
+                                {
+                                    for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
+                                    {
+                                        Creature* cre = player->GetBotMap(i)->_Cre();
+                                        if (cre)
+                                            cre->SetBotTank(u);
+                                    }
+                                }
+                            }
+                        }
+                        u->HandleEmoteCommand(EMOTE_ONESHOT_CHEER);
+                        handler->SetSentErrorMessage(true);
+                        return true;
+                    }
+                }
+            }
+            if (Unit* unit = bot_ai::GetBotGroupMainTank(group))
+            {
+                bool bot = unit->GetTypeId() == TYPEID_UNIT && unit->ToCreature()->GetIAmABot();
+                handler->PSendSysMessage("Main tank is %s (%s%s).", unit->GetName().c_str(), (bot ? "npcbot" : "player"), (unit->IsAlive() ? "" : ", dead"));
+                handler->SetSentErrorMessage(true);
+                return true;
+            }
+            handler->PSendSysMessage(".maintank");
+            handler->PSendSysMessage("Allows to set a main tank in bot party (can be used on npcbots). Determines npcbots' actions");
+            handler->PSendSysMessage("Npcbot maintank also receives damage reduction, avoidance and threat generation bonus");
+            handler->SetSentErrorMessage(true);
+            return true;
+        }
+        else
+        {
+            //clear tank in whole bot party
+            std::string cmdStr = strtok((char*)args, " ");
+            if (!cmdStr.compare("clear") || !cmdStr.compare("cl") || !cmdStr.compare("cle") ||
+                !cmdStr.compare("reset") || !cmdStr.compare("res"))
+            {
+                Group::MemberSlotList const& members = group->GetMemberSlots();
+                for (Group::MemberSlotList::const_iterator itr = members.begin(); itr != members.end(); ++itr)
+                {
+                    uint8 flags = itr->flags;
+                    if (group->isRaidGroup())
+                    {
+                        if (flags & MEMBER_FLAG_MAINTANK)
+                            group->SetGroupMemberFlag(itr->guid, false, MEMBER_FLAG_MAINTANK);
+                    }
+                    else
+                    {
+                        if (itr->flags & MEMBER_FLAG_MAINTANK)
+                            flags &= ~MEMBER_FLAG_MAINTANK;
+                    }
+                    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_GROUP_MEMBER_FLAG);
+                    stmt->setUInt8(0, flags);
+                    stmt->setUInt32(1, GUID_LOPART(itr->guid));
+                    CharacterDatabase.Execute(stmt);
+                    if (!IS_PLAYER_GUID(itr->guid))
+                        continue;
+                    Player* player = ObjectAccessor::FindPlayer(itr->guid);
+                    if (!player) continue;
+                    ChatHandler(player->GetSession()).PSendSysMessage("Main tank has been reset by %s.", handler->GetSession()->GetPlayer()->GetName().c_str());
+                    player->SetBotTank(0);
+                    if (player->HaveBot())
+                    {
+                        for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
+                        {
+                            Creature* cre = player->GetBotMap(i)->_Cre();
+                            if (cre)
+                                cre->SetBotTank(NULL);
+                        }
+                    }
+                }
+                handler->SetSentErrorMessage(true);
+                return true;
+            }
+        }
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    static bool HandleNpcBotInfoCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        if (!owner->GetSelection())
+        {
+            handler->PSendSysMessage(".npcbot info");
+            handler->PSendSysMessage("Lists NpcBots count of each class owned by selected player. You can use this on self and your party memebers");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        Player* master = owner->GetSelectedPlayer();
+        if (!master || (owner->GetGroup() ? !owner->GetGroup()->IsMember(master->GetGUID()) : master->GetGUID() != owner->GetGUID()))
+        {
+            handler->PSendSysMessage("You should select self or one of your party memebers.");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (!master->HaveBot())
+        {
+            handler->PSendSysMessage("%s has no NpcBots!", master->GetName().c_str());
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        handler->PSendSysMessage("Listing NpcBots for %s", master->GetName().c_str());
+        handler->PSendSysMessage("Owned NpcBots: %u", master->GetNpcBotsCount());
+        for (uint8 i = CLASS_WARRIOR; i != MAX_CLASSES; ++i)
+        {
+            uint8 count = 0;
+            uint8 alivecount = 0;
+            for (uint8 pos = 0; pos != master->GetMaxNpcBots(); ++pos)
+            {
+                if (Creature* cre = master->GetBotMap(pos)->_Cre())
+                {
+                    if (cre->GetBotClass() == i)
+                    {
+                        ++count;
+                        if (cre->IsAlive())
+                            ++alivecount;
+                    }
+                }
+            }
+            char const* bclass;
+            switch (i)
+            {
+            case CLASS_WARRIOR:         bclass = "Warriors";        break;
+            case CLASS_PALADIN:         bclass = "Paladins";        break;
+            case CLASS_MAGE:            bclass = "Mages";           break;
+            case CLASS_PRIEST:          bclass = "Priests";         break;
+            case CLASS_WARLOCK:         bclass = "Warlocks";        break;
+            case CLASS_DRUID:           bclass = "Druids";          break;
+            case CLASS_DEATH_KNIGHT:    bclass = "DeathKnights";    break;
+            case CLASS_ROGUE:           bclass = "Rogues";          break;
+            case CLASS_SHAMAN:          bclass = "Shamans";         break;
+            case CLASS_HUNTER:          bclass = "Hunters";         break;
+            default:                    bclass = "Unknown Class";   break;
+            }
+            if (count > 0)
+                handler->PSendSysMessage("%s: %u (alive: %u)", bclass, count, alivecount);
+        }
+        return true;
+    }
+
+    static bool HandleNpcBotDistanceCommand(ChatHandler* handler, const char* args)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        if (!*args)
+        {
+            if (owner->HaveBot())
+            {
+                handler->PSendSysMessage("bot follow distance is %u", owner->GetBotFollowDist());
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+            handler->PSendSysMessage(".npcbot distance");
+            handler->PSendSysMessage("Sets 'distance to target' at which bots will follow you");
+            handler->PSendSysMessage("if set to 0, bots will not attack anything unless you point them");
+            handler->PSendSysMessage("min: 0, max: 75");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        char* distance = strtok((char*)args, " ");
+        int8 dist = -1;
+
+        if (distance)
+            dist = (int8)atoi(distance);
+
+        if (dist >= 0 && dist <= 75)
+        {
+            owner->SetBotFollowDist(dist);
+            if (!owner->IsInCombat() && owner->HaveBot())
+            {
+                for (uint8 i = 0; i != owner->GetMaxNpcBots(); ++i)
+                {
+                    Creature* cre = owner->GetBotMap(i)->_Cre();
+                    if (!cre || !cre->IsInWorld()) continue;
+                    owner->SendBotCommandState(cre, COMMAND_FOLLOW);
+                }
+            }
+            Group* gr = owner->GetGroup();
+            if (gr && owner->GetMap()->Instanceable() && /*gr->isRaidGroup() &&*/ gr->IsLeader(owner->GetGUID()))
+            {
+                for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* pl = itr->GetSource();
+                    if (pl && pl->IsInWorld() && pl->GetMap() == owner->GetMap())
+                    {
+                        pl->SetBotFollowDist(dist);
+                        if (!pl->IsInCombat() && pl->HaveBot())
+                        {
+                            for (uint8 i = 0; i != pl->GetMaxNpcBots(); ++i)
+                            {
+                                Creature* cre = pl->GetBotMap(i)->_Cre();
+                                if (!cre || !cre->IsInWorld()) continue;
+                                pl->SendBotCommandState(cre, COMMAND_FOLLOW);
+                            }
+                        }
+                    }
+                }
+            }
+            handler->PSendSysMessage("bot follow distance set to %u", dist);
+            return true;
+        }
+        handler->SendSysMessage("follow distance should be between 0 and 75");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    static bool HandleNpcBotCommandCommand(ChatHandler* handler, const char* args)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        if (!*args)
+        {
+            handler->PSendSysMessage(".npcbot command <command>");
+            handler->PSendSysMessage("Forces npcbots to either follow you or hold position.");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        char* command = strtok((char*)args, " ");
+        int8 state = -1;
+        if (!strncmp(command, "s", 2) || !strncmp(command, "st", 3) || !strncmp(command, "stay", 5) || !strncmp(command, "stand", 6))
+            state = COMMAND_STAY;
+        else if (!strncmp(command, "f", 2) || !strncmp(command, "follow", 7) || !strncmp(command, "fol", 4) || !strncmp(command, "fo", 3))
+            state = COMMAND_FOLLOW;
+        if (state >= 0 && owner->HaveBot())
+        {
+            for (uint8 i = 0; i != owner->GetMaxNpcBots(); ++i)
+            {
+                Creature* cre = owner->GetBotMap(i)->_Cre();
+                if (!cre || !cre->IsInWorld()) continue;
+                owner->SendBotCommandState(cre, CommandStates(state));
+            }
+            return true;
+        }
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    static bool HandleNpcBotRemoveCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        uint64 guid = owner->GetSelection();
+        if (!guid)
+        {
+            handler->PSendSysMessage(".npcbot remove");
+            handler->PSendSysMessage("Remove selected npcbots. Select yourself to remove all npcbots");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (guid == owner->GetGUID())
+        {
+            if (owner->HaveBot())
+            {
+                for (uint8 i = 0; i != owner->GetMaxNpcBots(); ++i)
+                    owner->RemoveBot(owner->GetBotMap(i)->_Guid(), true);
+
+                if (!owner->HaveBot())
+                {
+                    handler->PSendSysMessage("Npcbots successfully removed");
+                    handler->SetSentErrorMessage(true);
+                    return true;
+                }
+                handler->PSendSysMessage("Some npcbots were not removed!");
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+            handler->PSendSysMessage("Npcbots are not found!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        
+        Creature* cre = ObjectAccessor::GetCreature(*owner, guid);
+        if (cre && cre->GetIAmABot())
+        {
+            Player* master = cre->GetBotOwner();
+            if (!master || (master->GetGUID() != owner->GetGUID()))
+            {
+                handler->PSendSysMessage("You can only remove your own bots");
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+            uint8 pos = master->GetNpcBotSlot(guid);
+            master->RemoveBot(cre->GetGUID(), true);
+            if (master->GetBotMap(pos)->_Cre() == NULL)
+            {
+                handler->PSendSysMessage("NpcBot successfully removed");
+                handler->SetSentErrorMessage(true);
+                return true;
+            }
+            handler->PSendSysMessage("NpcBot was NOT removed for some stupid reason!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        handler->PSendSysMessage("You should select self or your npcbot!");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    static bool HandleNpcBotResetCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        Player* master = NULL;
+        bool all = false;
+        uint64 guid = owner->GetSelection();
+        if (!guid)
+        {
+            handler->PSendSysMessage(".npcbot reset");
+            handler->PSendSysMessage("Reset selected npcbot, or all npcbots if used on self");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (IS_PLAYER_GUID(guid))
+        {
+            master = owner;
+            all = true;
+        }
+        else if (IS_CREATURE_GUID(guid))
+        {
+            if (Creature* cre = ObjectAccessor::GetCreature(*owner, guid))
+                master = cre->GetBotOwner();
+        }
+        if (master && master->GetGUID() == owner->GetGUID())
+        {
+            if (master->IsInCombat() && master->GetSession()->GetSecurity() == SEC_PLAYER)
+            {
+                handler->PSendSysMessage("Cannot reset bots in combat!");
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+            if (!master->HaveBot())
+            {
+                handler->PSendSysMessage("Npcbots are not found!");
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+            for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
+            {
+                if (all)
+                    master->RemoveBot(master->GetBotMap(i)->_Guid());
+                else if (master->GetBotMap(i)->_Guid() == guid)
+                {
+                    master->RemoveBot(guid);
+                    break;
+                }
+            }
+            handler->SetSentErrorMessage(true);
+            return true;
+        }
+        handler->PSendSysMessage(".npcbot reset");
+        handler->PSendSysMessage("Reset selected npcbot. Cannot be used in combat");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+    //For debug purposes only
+    static bool HandleNpcBotReviveCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        if (handler->GetSession()->GetSecurity() == SEC_PLAYER)
+        {
+            handler->PSendSysMessage("Revive command is disabled");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Player* owner = handler->GetSession()->GetPlayer();
+        if (owner->InBattleground())
+        {
+            handler->PSendSysMessage("Bot revival is disabled in pvp matches");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (owner->IsInFlight())
+        {
+            handler->PSendSysMessage("Bot revival is disabled in flight");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (owner->HaveBot())
+        {
+            for (uint8 i = 0; i != owner->GetMaxNpcBots(); ++i)
+            {
+                Creature* bot = owner->GetBotMap(i)->_Cre();
+                if (!bot) continue;
+                if (bot->isDead())
+                {
+                    owner->SetBot(bot);
+                    owner->CreateBot(0, 0, 0, false, true);
+                }
+            }
+            handler->PSendSysMessage("NpcBots revived");
+            handler->SetSentErrorMessage(true);
+            return true;
+        }
+        handler->PSendSysMessage(".npcbot revive");
+        handler->PSendSysMessage("Revive your npcbots if you are all hopelessly dead");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    static bool HandleNpcBotAddCommand(ChatHandler* handler, const char* args)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        uint64 sel = owner->GetSelection();
+        if (!*args || sel != owner->GetGUID())
+        {
+            handler->PSendSysMessage(".npcbot add");
+            handler->PSendSysMessage("Allows to create npcbot of given class, you should select yourself");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (owner->RestrictBots())
+        {
+            handler->GetSession()->SendNotification("This place is restricted for NpcBots");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (owner->isDead())
+        {
+            owner->GetSession()->SendNotification("You're dead!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (owner->GetGroup() && owner->GetGroup()->isRaidGroup() && owner->GetGroup()->IsFull())
+        {
+            handler->PSendSysMessage("Group is full, aborted");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (owner->GetNpcBotsCount() >= owner->GetMaxNpcBots())
+        {
+            handler->PSendSysMessage("NpcBots limit exceed");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        char* bclass = strtok((char*)args, " ");
+        uint8 botclass = CLASS_NONE;
+
+        if (!strncmp(bclass, "deathknight", 12) || !strncmp(bclass, "dk", 3) || !strncmp(bclass, "de", 3))
+            botclass = CLASS_DEATH_KNIGHT;
+        else if (!strncmp(bclass, "druid", 6) || !strncmp(bclass, "dru", 4) || !strncmp(bclass, "dr", 3))
+            botclass = CLASS_DRUID;
+        else if (!strncmp(bclass, "hunter", 7) || !strncmp(bclass, "hunt", 5) || !strncmp(bclass, "hu", 3))
+            botclass = CLASS_HUNTER;
+        else if (!strncmp(bclass, "mage", 5) || !strncmp(bclass, "ma", 3))
+            botclass = CLASS_MAGE;
+        else if (!strncmp(bclass, "paladin", 8) || !strncmp(bclass, "pal", 4) || !strncmp(bclass, "pa", 3))
+            botclass = CLASS_PALADIN;
+        else if (!strncmp(bclass, "priest", 7) || !strncmp(bclass, "pri", 4) || !strncmp(bclass, "pr", 3))
+            botclass = CLASS_PRIEST;
+        else if (!strncmp(bclass, "rogue", 6) || !strncmp(bclass, "rog", 4) || !strncmp(bclass, "ro", 3))
+            botclass = CLASS_ROGUE;
+        else if (!strncmp(bclass, "shaman", 7) || !strncmp(bclass, "sha", 4) || !strncmp(bclass, "sh", 3))
+            botclass = CLASS_SHAMAN;
+        else if (!strncmp(bclass, "warlock", 8) || !strncmp(bclass, "warl", 5) || !strncmp(bclass, "lock", 5))
+            botclass = CLASS_WARLOCK;
+        else if (!strncmp(bclass, "warrior", 8) || !strncmp(bclass, "warr", 5))
+            botclass = CLASS_WARRIOR;
+
+        if (botclass == CLASS_NONE)
+        {
+            handler->PSendSysMessage("Wrong bot class");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        uint8 bots = owner->GetNpcBotsCount();
+        owner->CreateNPCBot(botclass);
+        owner->RefreshBot(0);
+        if (owner->GetNpcBotsCount() > bots)
+        {
+            if (owner->IsInCombat())
+                handler->PSendSysMessage("NpcBot successfully created (%s). Will appear out of combat", owner->GetName().c_str());
+            else
+                handler->PSendSysMessage("NpcBot successfully created (%s).", owner->GetName().c_str());
+            handler->SetSentErrorMessage(true);
+            return true;
+        }
+        handler->PSendSysMessage("NpcBot is NOT created for some reason!");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+};
+
+void AddSC_script_bot_commands()
+{
+    new script_bot_commands();
+}
diff --git a/src/server/game/AI/NpcBots/bothelper.cpp b/src/server/game/AI/NpcBots/bothelper.cpp
new file mode 100644
index 0000000..d5e322b
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bothelper.cpp
@@ -0,0 +1,421 @@
+/*
+Bot Helper by Graff (onlysuffering@gmail.com)
+Type: empty-type player-to-self dialog-like manager for npcbot mod
+Complete: ???
+Category: scripts/custom/bots
+*/
+
+#include "bothelper.h"
+#include "Chat.h"
+#include "Config.h"
+#include "GridNotifiers.h"
+#include "GridNotifiersImpl.h"
+#include "Group.h"
+#include "Language.h"
+#include "ObjectMgr.h"
+#include "Player.h"
+#include "ScriptedCreature.h"
+#include "ScriptedGossip.h"
+#include "ScriptMgr.h"
+
+const uint8 GroupIcons[TARGETICONCOUNT] =
+{
+    /*STAR        = */0x001,
+    /*CIRCLE      = */0x002,
+    /*DIAMOND     = */0x004,
+    /*TRIANGLE    = */0x008,
+    /*MOON        = */0x010,
+    /*SQUARE      = */0x020,
+    /*CROSS       = */0x040,
+    /*SKULL       = */0x080
+};
+
+enum HelperActions
+{
+    ACTION_ENABLE                                               = 1,
+    ACTION_DISABLE                                              = 2,
+    ACTION_TOGGLE                                               = 3
+};
+
+enum BotgiverTexIDs
+{
+    ABANDON_MINION                                              = 3,
+    RECRUIT_MINION                                              = 4,
+    HELP_STR                                                    = 5,
+    ADD_ALL                                                     = 6,
+    REMOVE_ALL                                                  = 7,
+    RECRUIT_WARRIOR                                             = 8,
+    RECRUIT_HUNTER                                              = 9,
+    RECRUIT_PALADIN                                             = 10,
+    RECRUIT_SHAMAN                                              = 11,
+    RECRUIT_ROGUE                                               = 12,
+    RECRUIT_DRUID                                               = 13,
+    RECRUIT_MAGE                                                = 14,
+    RECRUIT_PRIEST                                              = 15,
+    RECRUIT_WARLOCK                                             = 16,
+    RECRUIT_DEATH_KNIGHT                                        = 17,
+    ABOUT_BASIC_STR1                                            = 18,
+    ABOUT_BASIC_STR2                                            = 19,
+    ABOUT_BASIC_STR3                                            = 20,
+    ABOUT_ICONS_STR1                                            = 21,
+    ABOUT_ICONS_STR2                                            = 22,
+    ICON_STRING_STAR                                            = 23,
+    ICON_STRING_CIRCLE                                          = 24,
+    ICON_STRING_DIAMOND                                         = 25,
+    ICON_STRING_TRIANGLE                                        = 26,
+    ICON_STRING_MOON                                            = 27,
+    ICON_STRING_SQUARE                                          = 28,
+    ICON_STRING_CROSS                                           = 29,
+    ICON_STRING_SKULL                                           = 30,
+    ICON_STRING_UNKNOWN                                         = 31,
+    NO_MORE_AVAILABLE                                           = 32,
+    ONE_MORE_AVAILABLE                                          = 33,
+    SOME_MORE_AVAILABLE                                         = 34,
+    ONE_AVAILABLE                                               = 35,
+    SOME_AVAILABLE                                              = 36,
+
+    ENABLE_STRING,
+    DISABLE_STRING,
+    TOGGLE_STRING,
+    BACK_STRING,
+    ALL_STRING,
+    MAX_STRINGS
+};
+
+enum HelperGossip
+{
+    SENDER_CREATE_NBOT_MENU                                     = 1,
+    SENDER_CREATE_NBOT                                          = 2,
+    SENDER_REMOVE_NBOT_MENU                                     = 7,
+    SENDER_REMOVE_NBOT                                          = 8,
+
+    SENDER_INFO_WHISPER                                         = 9,
+
+    SENDER_MAIN_PAGE,
+    MAX_SENDERS
+};
+
+BotHelper::BotHelper(Player* const master) : _master(master) { }
+BotHelper::~BotHelper() {}
+
+bool BotHelper::OnGossipSelect(Player* player, uint32 sender, uint32 action)
+{
+    switch (sender)
+    {
+        case SENDER_MAIN_PAGE:                          OnGossipHello(player);                              break;
+
+        case SENDER_CREATE_NBOT_MENU:                   SendCreateNPCBotMenu(player, action);               break;
+        case SENDER_CREATE_NBOT:                        SendCreateNPCBot(player, action);                   break;
+        case SENDER_REMOVE_NBOT_MENU:                   SendRemoveNPCBotMenu(player, action);               break;
+        case SENDER_REMOVE_NBOT:                        SendRemoveNPCBot(player, action);                   break;
+
+        case SENDER_INFO_WHISPER:                       SendBotHelpWhisper(player, action);                 break;
+
+        default:
+            break;
+    }
+    return true;
+}
+
+bool BotHelper::OnGossipHello(Player* player)
+{
+    player->PlayerTalkClass->ClearMenus(); //in case of return;
+
+    uint8 count = 0;
+
+    uint8 maxNBcount = player->GetMaxNpcBots();
+
+    bool allowNBots = sConfigMgr->GetBoolDefault("Bot.EnableNpcBots", true) && !player->RestrictBots();
+
+    std::string tempstr;
+
+    if (player->HaveBot())
+    {
+        count = player->GetNpcBotsCount();
+        if (count > 0)
+        {
+            tempstr = "Abandon my Minion";
+            player->PlayerTalkClass->GetGossipMenu().AddMenuItem(4, 0, GetLocaleStringForTextID(tempstr, ABANDON_MINION, player->GetSession()->GetSessionDbLocaleIndex()), SENDER_REMOVE_NBOT_MENU, GOSSIP_ACTION_INFO_DEF + 4, "", 0);
+        }
+        if (count < maxNBcount && allowNBots)
+        {
+            tempstr = "Recruit a Minion";
+            player->PlayerTalkClass->GetGossipMenu().AddMenuItem(2, 0, GetLocaleStringForTextID(tempstr, RECRUIT_MINION, player->GetSession()->GetSessionDbLocaleIndex()), SENDER_CREATE_NBOT_MENU, GOSSIP_ACTION_INFO_DEF + 2, "", 0);
+        }
+    }
+    else if (allowNBots && maxNBcount != 0)
+    {
+        tempstr = "Recruit a Minion";
+        player->PlayerTalkClass->GetGossipMenu().AddMenuItem(2, 0, GetLocaleStringForTextID(tempstr, RECRUIT_MINION, player->GetSession()->GetSessionDbLocaleIndex()), SENDER_CREATE_NBOT_MENU, GOSSIP_ACTION_INFO_DEF + 2, "", 0);
+    }
+
+    tempstr = "Help";
+    player->PlayerTalkClass->GetGossipMenu().AddMenuItem(6, 0, GetLocaleStringForTextID(tempstr, HELP_STR, player->GetSession()->GetSessionDbLocaleIndex()), SENDER_INFO_WHISPER, GOSSIP_ACTION_INFO_DEF + 6, "", 0);
+
+    player->PlayerTalkClass->SendGossipMenu(8446, player->GetGUID());
+    return true;
+}
+
+void BotHelper::SendRemoveNPCBot(Player* player, uint32 action)
+{
+    int8 x = action - GOSSIP_ACTION_INFO_DEF;
+    if (x == 1)
+    {
+        player->CLOSE_GOSSIP_MENU();
+        for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
+            player->RemoveBot(player->GetBotMap(i)->_Guid(), true);
+        return;
+    }
+    for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
+    {
+        if (!player->GetBotMap(i)->_Cre())
+            continue;
+        if (x == 2)
+        {
+            player->RemoveBot(player->GetBotMap(i)->_Guid(), true);
+            break;
+        }
+        --x;
+    }
+    player->CLOSE_GOSSIP_MENU();
+}
+
+void BotHelper::SendRemoveNPCBotMenu(Player* player, uint32 /*action*/)
+{
+    player->PlayerTalkClass->ClearMenus();
+    if (player->GetNpcBotsCount() == 1)
+    {
+        for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
+            player->RemoveBot(player->GetBotMap(i)->_Guid(), true);
+        player->CLOSE_GOSSIP_MENU();
+        return;
+    }
+    std::string tempstr = "REMOVE ALL";
+    player->ADD_GOSSIP_ITEM(9, GetLocaleStringForTextID(tempstr, REMOVE_ALL, player->GetSession()->GetSessionDbLocaleIndex()), SENDER_REMOVE_NBOT, GOSSIP_ACTION_INFO_DEF + 1);
+
+    uint8 x = 2;
+    for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
+    {
+        Creature* bot = player->GetBotMap(i)->_Cre();
+        if (!bot) continue;
+        player->ADD_GOSSIP_ITEM(9, bot->GetName(), SENDER_REMOVE_NBOT, GOSSIP_ACTION_INFO_DEF + x);
+        ++x;
+    }
+
+    tempstr = "BACK";
+    player->ADD_GOSSIP_ITEM(0, GetLocaleStringForTextID(tempstr, BACK_STRING, player->GetSession()->GetSessionDbLocaleIndex()), SENDER_MAIN_PAGE, GOSSIP_ACTION_INFO_DEF + x);
+
+    player->PlayerTalkClass->SendGossipMenu(8446, player->GetGUID());
+}
+
+void BotHelper::SendCreateNPCBot(Player* player, uint32 action)
+{
+    uint8 bot_class = 0;
+    if (action == GOSSIP_ACTION_INFO_DEF + 1)//"Back"
+    {
+        player->CLOSE_GOSSIP_MENU();
+        return;
+    }
+    else if (action == GOSSIP_ACTION_INFO_DEF + 2)
+        bot_class = CLASS_WARRIOR;
+    //else if (action == GOSSIP_ACTION_INFO_DEF + 3)
+    //    bot_class = CLASS_HUNTER;
+    else if (action == GOSSIP_ACTION_INFO_DEF + 4)
+        bot_class = CLASS_PALADIN;
+    //else if (action == GOSSIP_ACTION_INFO_DEF + 5)
+    //    bot_class = CLASS_SHAMAN;
+    else if (action == GOSSIP_ACTION_INFO_DEF + 6)
+        bot_class = CLASS_ROGUE;
+    else if (action == GOSSIP_ACTION_INFO_DEF + 7)
+        bot_class = CLASS_DRUID;
+    else if (action == GOSSIP_ACTION_INFO_DEF + 8)
+        bot_class = CLASS_MAGE;
+    else if (action == GOSSIP_ACTION_INFO_DEF + 9)
+        bot_class = CLASS_PRIEST;
+    else if (action == GOSSIP_ACTION_INFO_DEF + 10)
+        bot_class = CLASS_WARLOCK;
+    //else if (action == GOSSIP_ACTION_INFO_DEF + 11)
+    //    bot_class = CLASS_DEATH_KNIGHT;
+
+    if (bot_class != 0)
+        player->CreateNPCBot(bot_class);
+    player->CLOSE_GOSSIP_MENU();
+    return;
+}
+
+void BotHelper::SendCreateNPCBotMenu(Player* player, uint32 /*action*/)
+{
+    std::string cost = player->GetNpcBotCostStr();
+    player->PlayerTalkClass->ClearMenus();
+
+    std::string tempstr = "Recruit a Warrior ";
+    player->ADD_GOSSIP_ITEM(9, GetLocaleStringForTextID(tempstr, RECRUIT_WARRIOR, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 2);
+    //tempstr = "Recruit a Hunter ";
+    //player->ADD_GOSSIP_ITEM(9, GetLocaleStringForTextID(tempstr, RECRUIT_HUNTER, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 3);
+    tempstr = "Recruit a Paladin ";
+    player->ADD_GOSSIP_ITEM(9, GetLocaleStringForTextID(tempstr, RECRUIT_PALADIN, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 4);
+    //tempstr = "Recruit a Shaman ";
+    //player->ADD_GOSSIP_ITEM(9, GetLocaleStringForTextID(tempstr, RECRUIT_SHAMAN, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 5);
+    tempstr = "Recruit a Rogue ";
+    player->ADD_GOSSIP_ITEM(9, GetLocaleStringForTextID(tempstr, RECRUIT_ROGUE, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 6);
+    tempstr = "Recruit a Druid ";
+    player->ADD_GOSSIP_ITEM(3, GetLocaleStringForTextID(tempstr, RECRUIT_DRUID, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 7);
+    tempstr = "Recruit a Mage ";
+    player->ADD_GOSSIP_ITEM(3, GetLocaleStringForTextID(tempstr, RECRUIT_MAGE, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 8);
+    tempstr = "Recruit a Priest ";
+    player->ADD_GOSSIP_ITEM(3, GetLocaleStringForTextID(tempstr, RECRUIT_PRIEST, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 9);
+    tempstr = "Recruit a Warlock ";
+    player->ADD_GOSSIP_ITEM(3, GetLocaleStringForTextID(tempstr, RECRUIT_WARLOCK, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 10);
+    //tempstr = "Recruit a Death Knight ";
+    //player->ADD_GOSSIP_ITEM(9, GetLocaleStringForTextID(tempstr, RECRUIT_DEATH_KNIGHT, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 11);
+
+    std::ostringstream buff;
+    uint8 bots = player->GetNpcBotsCount();
+    uint8 maxNBcount = player->GetMaxNpcBots();
+    uint32 freeNBSlots = maxNBcount - bots;
+
+    if (freeNBSlots == 0)
+    {
+        tempstr = "no more bots available";
+        buff << GetLocaleStringForTextID(tempstr, NO_MORE_AVAILABLE, player->GetSession()->GetSessionDbLocaleIndex());
+    }
+    else
+    {
+        buff << freeNBSlots;
+        buff << ' ';
+        if (freeNBSlots == 1)
+        {
+            if (bots == 0)
+            {
+                tempstr = "bot available";
+                buff << GetLocaleStringForTextID(tempstr, ONE_AVAILABLE, player->GetSession()->GetSessionDbLocaleIndex());
+            }
+            else
+            {
+                tempstr = "more bot available";
+                buff << GetLocaleStringForTextID(tempstr, ONE_MORE_AVAILABLE, player->GetSession()->GetSessionDbLocaleIndex());
+            }
+        }
+        else
+        {
+            if (bots == 0)
+            {
+                tempstr = "bots available";
+                buff << GetLocaleStringForTextID(tempstr, SOME_AVAILABLE, player->GetSession()->GetSessionDbLocaleIndex());
+            }
+            else
+            {
+                tempstr = "more bots available";
+                buff << GetLocaleStringForTextID(tempstr, SOME_MORE_AVAILABLE, player->GetSession()->GetSessionDbLocaleIndex());
+            }
+        }
+    }
+    player->ADD_GOSSIP_ITEM(0, buff.str(), SENDER_CREATE_NBOT_MENU, GOSSIP_ACTION_INFO_DEF + 12);
+
+    tempstr = "BACK";
+    player->ADD_GOSSIP_ITEM(0, GetLocaleStringForTextID(tempstr, BACK_STRING, player->GetSession()->GetSessionDbLocaleIndex()), SENDER_MAIN_PAGE, GOSSIP_ACTION_INFO_DEF + 13);
+
+    player->PlayerTalkClass->SendGossipMenu(8446, player->GetGUID());
+}
+
+void BotHelper::SendBotHelpWhisper(Player* player, uint32 /*action*/)
+{
+    player->CLOSE_GOSSIP_MENU();
+    ChatHandler ch(player->GetSession());
+    //Basic
+    std::string tempstr = "To see list of available npcbot commands type .npcbot or .npcb";
+    std::string msg2 = GetLocaleStringForTextID(tempstr, ABOUT_BASIC_STR2, player->GetSession()->GetSessionDbLocaleIndex());
+    tempstr = "You can also use .maintank (or .mt or .main) command on any party member (even npcbot) so your bots will stick to your plan";
+    std::string msg3 = GetLocaleStringForTextID(tempstr, ABOUT_BASIC_STR3, player->GetSession()->GetSessionDbLocaleIndex());
+    ch.SendSysMessage(msg2.c_str());
+    ch.SendSysMessage(msg3.c_str());
+    //Heal Icons
+    uint8 mask = sConfigMgr->GetIntDefault("Bot.HealTargetIconsMask", 8);
+    std::string msg4 = "";
+    if (mask == 255)
+    {
+        tempstr = "If you want your npcbots to heal someone out of your party set any raid target icon on them";
+        msg4 = GetLocaleStringForTextID(tempstr, ABOUT_ICONS_STR1, player->GetSession()->GetSessionDbLocaleIndex());
+        ch.SendSysMessage(msg4.c_str());
+    }
+    else if (mask != 0)
+    {
+        tempstr = "If you want your npcbots to heal someone out of your party set proper raid target icon on them, one of these: ";
+        msg4 = GetLocaleStringForTextID(tempstr, ABOUT_ICONS_STR2, player->GetSession()->GetSessionDbLocaleIndex());
+        std::string iconrow = "";
+        uint8 count = 0;
+        for (uint8 i = 0; i != TARGETICONCOUNT; ++i)
+        {
+            if (mask & GroupIcons[i])
+            {
+                if (count != 0)
+                    iconrow += ", ";
+                ++count;
+                switch (i)
+                {
+                    case 0:
+                        tempstr = "star";
+                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_STAR, player->GetSession()->GetSessionDbLocaleIndex());
+                        break;
+                    case 1:
+                        tempstr = "circle";
+                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_CIRCLE, player->GetSession()->GetSessionDbLocaleIndex());
+                        break;
+                    case 2:
+                        tempstr = "diamond";
+                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_DIAMOND, player->GetSession()->GetSessionDbLocaleIndex());
+                        break;
+                    case 3:
+                        tempstr = "triangle";
+                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_TRIANGLE, player->GetSession()->GetSessionDbLocaleIndex());
+                        break;
+                    case 4:
+                        tempstr = "moon";
+                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_MOON, player->GetSession()->GetSessionDbLocaleIndex());
+                        break;
+                    case 5:
+                        tempstr = "square";
+                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_SQUARE, player->GetSession()->GetSessionDbLocaleIndex());
+                        break;
+                    case 6:
+                        tempstr = "cross";
+                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_CROSS, player->GetSession()->GetSessionDbLocaleIndex());
+                        break;
+                    case 7:
+                        tempstr = "skull";
+                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_SKULL, player->GetSession()->GetSessionDbLocaleIndex());
+                        break;
+                    default:
+                        tempstr = "unknown icon";
+                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_UNKNOWN, player->GetSession()->GetSessionDbLocaleIndex());
+                        break;
+                }
+            }
+        }
+        msg4 += iconrow;
+        ch.SendSysMessage(msg4.c_str());
+    }
+}
+
+std::string BotHelper::GetLocaleStringForTextID(std::string& textValue, uint32 textId, int32 localeIdx)
+{
+    if (textId >= MAX_STRINGS)
+    {
+        TC_LOG_ERROR(LOG_FILTER_PLAYER, "botgiver:GetLocaleStringForTextID:: unknown text id: %u!", uint32(textId));
+        return textValue;
+    }
+
+    if (localeIdx == DEFAULT_LOCALE)
+        return textValue; //use default
+
+    if (localeIdx < 0)
+    {
+        TC_LOG_ERROR(LOG_FILTER_PLAYER, "botgiver:GetLocaleStringForTextID:: unknown locale: %i! Sending default locale text...", localeIdx);
+        return textValue;
+    }
+
+    uint32 idxEntry = MAKE_PAIR32(60000, textId);
+    if (GossipMenuItemsLocale const* no = sObjectMgr->GetGossipMenuItemsLocale(idxEntry))
+        ObjectMgr::GetLocaleString(no->OptionText, localeIdx, textValue);
+    return textValue;
+}
diff --git a/src/server/game/AI/NpcBots/bothelper.h b/src/server/game/AI/NpcBots/bothelper.h
new file mode 100644
index 0000000..1310b4d
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bothelper.h
@@ -0,0 +1,32 @@
+#ifndef _BOTHLP_H
+#define _BOTHLP_H
+
+#include "Common.h"
+
+class Player;
+
+class BotHelper
+{
+    public:
+        BotHelper(Player* const master);
+        ~BotHelper();
+
+        Player* GetOwner() const { return _master; }
+
+        static bool OnGossipHello(Player* player);
+        static bool OnGossipSelect(Player* player, uint32 sender, uint32 action);
+
+    private:
+        static void SendRemoveNPCBot(Player* player, uint32 action);
+        static void SendRemoveNPCBotMenu(Player* player, uint32 /*action*/);
+        static void SendCreateNPCBot(Player* player, uint32 action);
+        static void SendCreateNPCBotMenu(Player* player, uint32 /*action*/);
+
+
+        static void SendBotHelpWhisper(Player* player, uint32 /*action*/);
+        static std::string GetLocaleStringForTextID(std::string& textValue, uint32 textId, int32 localeIdx = 0);
+
+        Player* const _master;
+};
+
+#endif
diff --git a/src/server/game/CMakeLists.txt b/src/server/game/CMakeLists.txt
index c8d1a94..a6207b2 100644
--- a/src/server/game/CMakeLists.txt
+++ b/src/server/game/CMakeLists.txt
@@ -130,6 +130,7 @@ include_directories(
   ${CMAKE_CURRENT_SOURCE_DIR}/Addons
   ${CMAKE_CURRENT_SOURCE_DIR}/AI
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/CoreAI
+  ${CMAKE_CURRENT_SOURCE_DIR}/AI/NpcBots
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/ScriptedAI
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/SmartScripts
   ${CMAKE_CURRENT_SOURCE_DIR}/AuctionHouse
diff --git a/src/server/game/Entities/Creature/Creature.cpp b/src/server/game/Entities/Creature/Creature.cpp
index 779cffa..4fd42ab 100644
--- a/src/server/game/Entities/Creature/Creature.cpp
+++ b/src/server/game/Entities/Creature/Creature.cpp
@@ -54,6 +54,9 @@
 
 // apply implementation of the singletons
 
+// npcbot
+#include "bot_ai.h"
+
 TrainerSpell const* TrainerSpellData::Find(uint32 spell_id) const
 {
     TrainerSpellMap::const_iterator itr = spellList.find(spell_id);
@@ -165,6 +168,13 @@ m_creatureInfo(NULL), m_creatureData(NULL), m_path_id(0), m_formation(NULL)
     ResetLootMode(); // restore default loot mode
     TriggerJustRespawned = false;
     m_isTempWorldObject = false;
+
+    //bot
+    m_bot_owner = NULL;
+    m_creature_owner = NULL;
+    m_bots_pet = NULL;
+    m_bot_class = CLASS_NONE;
+    bot_AI = NULL;
 }
 
 Creature::~Creature()
@@ -233,6 +243,8 @@ void Creature::RemoveCorpse(bool setSpawnTime)
 {
     if (getDeathState() != CORPSE)
         return;
+    if (bot_AI)
+        return;
 
     m_corpseRemoveTime = time(NULL);
     setDeathState(DEAD);
@@ -2533,3 +2545,131 @@ void Creature::SetDisplayId(uint32 modelId)
         SetFloatValue(UNIT_FIELD_COMBATREACH, minfo->combat_reach * GetFloatValue(OBJECT_FIELD_SCALE_X));
     }
 }
+
+void Creature::SetIAmABot(bool bot)
+{
+    if (!bot)
+    {
+        bot_AI->UnsummonAll();
+        IsAIEnabled = false;
+        bot_AI = NULL;
+        SetUInt64Value(UNIT_FIELD_CREATEDBY, 0);
+    }
+}
+
+void Creature::SetBotsPetDied()
+{
+    if (!m_bots_pet)
+        return;
+    m_bots_pet->SetCharmerGUID(0);
+    m_bots_pet->SetCreatureOwner(NULL);
+    //m_bots_pet->GetBotPetAI()->SetCreatureOwner(NULL);
+    m_bots_pet->SetIAmABot(false);
+    m_bot_owner->SetMinion((Minion*)m_bots_pet, false);
+    m_bots_pet->CleanupsBeforeDelete();
+    m_bots_pet->AddObjectToRemoveList();
+    m_bots_pet = NULL;
+}
+
+void Creature::SetBotTank(Unit* newtank)
+{
+    if (!bot_AI || !IsAIEnabled)
+        return;
+    uint64 tankGuid = bot_AI->GetBotTankGuid();
+    if (newtank && newtank->GetGUID() == tankGuid) return;
+    Creature* oldtank = tankGuid && IS_CREATURE_GUID(tankGuid) ? sObjectAccessor->GetObjectInWorld(tankGuid, (Creature* )NULL) : NULL;
+    if (oldtank && oldtank->IsInWorld() && (oldtank->GetIAmABot() || oldtank->GetIAmABotsPet()))
+    {
+        oldtank->RemoveAurasDueToSpell(DEFENSIVE_STANCE_PASSIVE);
+        uint8 ClassOrPetType = oldtank->GetIAmABotsPet() ? bot_pet_ai::GetPetType(oldtank) : oldtank->GetBotClass();
+        oldtank->GetBotAI()->ApplyPassives(ClassOrPetType);
+    }
+    if (newtank == this)
+    {
+        for (uint8 i = 0; i < 3; ++i)
+            AddAura(DEFENSIVE_STANCE_PASSIVE, this);
+        if (Player* owner = m_bot_owner)
+        {
+            switch (urand(1,5))
+            {
+            case 1: MonsterWhisper("I am tank here!", owner->GetGUID()); break;
+            case 2: MonsterWhisper("I will tank now.", owner->GetGUID()); break;
+            case 3: MonsterWhisper("I gonna tank", owner->GetGUID()); break;
+            case 4: MonsterWhisper("I think I will be best tank here...", owner->GetGUID()); break;
+            case 5: MonsterWhisper("I AM the tank!", owner->GetGUID()); break;
+            }
+        }
+        bot_AI->UpdateHealth();
+        if (!IsInCombat())
+            SetBotCommandState(COMMAND_FOLLOW, true);
+    }
+    bot_AI->SetBotTank(newtank);
+}
+
+void Creature::SetBotCommandState(CommandStates st, bool force)
+{
+    if (bot_AI && IsAIEnabled)
+        bot_AI->SetBotCommandState(st, force);
+}
+//Bot damage mods
+void Creature::ApplyBotDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotDamageMultiplierMelee(damage, damageinfo);
+}
+void Creature::ApplyBotDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotDamageMultiplierMelee(damage, damageinfo, spellInfo, attackType, crit);
+}
+void Creature::ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotDamageMultiplierSpell(damage, damageinfo, spellInfo, attackType, crit);
+}
+
+void Creature::ApplyBotDamageMultiplierEffect(SpellInfo const* spellInfo, uint8 effect_index, float &value) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotDamageMultiplierEffect(spellInfo, effect_index, value);
+}
+
+bool Creature::GetIAmABot() const
+{
+    return bot_AI ? bot_AI->IsMinionAI() : false;
+}
+
+bool Creature::GetIAmABotsPet() const
+{
+    return bot_AI ? bot_AI->IsPetAI() : false;
+}
+
+bot_minion_ai* Creature::GetBotMinionAI() const
+{
+    return IsAIEnabled && bot_AI && bot_AI->IsMinionAI() ? const_cast<bot_minion_ai*>(bot_AI->GetMinionAI()) : NULL;
+}
+
+bot_pet_ai* Creature::GetBotPetAI() const
+{
+    return IsAIEnabled && bot_AI && bot_AI->IsPetAI() ? const_cast<bot_pet_ai*>(bot_AI->GetPetAI()) : NULL;
+}
+
+void Creature::InitBotAI(bool asPet)
+{
+    ASSERT(!bot_AI);
+
+    if (asPet)
+        bot_AI = (bot_pet_ai*)AI();
+    else
+        bot_AI = (bot_minion_ai*)AI();
+}
+
+void Creature::SetBotShouldUpdateStats()
+{
+    if (bot_AI) bot_AI->SetShouldUpdateStats();
+}
+
+void Creature::OnBotSummon(Creature* summon)
+{
+    if (bot_AI) bot_AI->OnBotSummon(summon);
+}
diff --git a/src/server/game/Entities/Creature/Creature.h b/src/server/game/Entities/Creature/Creature.h
index 13ed277..6fe838d 100644
--- a/src/server/game/Entities/Creature/Creature.h
+++ b/src/server/game/Entities/Creature/Creature.h
@@ -37,6 +37,11 @@ class Player;
 class SpellInfo;
 class WorldSession;
 
+// npcbot
+class bot_ai;
+class bot_minion_ai;
+class bot_pet_ai;
+
 enum CreatureFlagsExtra
 {
     CREATURE_FLAG_EXTRA_INSTANCE_BIND   = 0x00000001,       // creature kill bind instance with killer and killer's group
@@ -692,6 +697,33 @@ class Creature : public Unit, public GridObject<Creature>, public MapCreature
 
         bool m_isTempWorldObject; //true when possessed
 
+        //Bot commands
+        Player* GetBotOwner() const { return m_bot_owner; }
+        void SetBotOwner(Player* newowner) { m_bot_owner = newowner; }
+        Creature* GetCreatureOwner() const { return m_creature_owner; }
+        void SetCreatureOwner(Creature* newCreOwner) { m_creature_owner = newCreOwner; } 
+        Creature* GetBotsPet() const { return m_bots_pet; }
+        void SetBotsPetDied();
+        void SetBotsPet(Creature* newpet) { /*ASSERT (!m_bots_pet);*/ m_bots_pet = newpet; }
+        void SetIAmABot(bool bot = true);
+        bool GetIAmABot() const;
+        bool GetIAmABotsPet() const;
+        void SetBotClass(uint8 myclass) { m_bot_class = myclass; }
+        uint8 GetBotClass() const { return m_bot_class; }
+        void SetBotTank(Unit* newtank);
+        bot_ai* GetBotAI() const { return bot_AI; }
+        bot_minion_ai* GetBotMinionAI() const;
+        bot_pet_ai* GetBotPetAI() const;
+        void InitBotAI(bool asPet = false);
+        void SetBotCommandState(CommandStates st, bool force = false);
+        void ApplyBotDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const;
+        void ApplyBotDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const;
+        void ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const;
+        void ApplyBotDamageMultiplierEffect(SpellInfo const* spellInfo, uint8 effect_index, float &value) const;
+        void SetBotShouldUpdateStats();
+        void OnBotSummon(Creature* summon);
+        //Bot commands
+
     protected:
         bool CreateFromProto(uint32 guidlow, uint32 Entry, uint32 vehId, uint32 team, const CreatureData* data = NULL);
         bool InitEntry(uint32 entry, uint32 team=ALLIANCE, const CreatureData* data=NULL);
@@ -742,6 +774,14 @@ class Creature : public Unit, public GridObject<Creature>, public MapCreature
         bool IsInvisibleDueToDespawn() const;
         bool CanAlwaysSee(WorldObject const* obj) const;
     private:
+        //bot system
+        Player* m_bot_owner;
+        Creature* m_creature_owner;
+        Creature* m_bots_pet;
+        bot_ai* bot_AI;
+        uint8 m_bot_class;
+        //end bot system
+
         void ForcedDespawn(uint32 timeMSToDespawn = 0);
 
         //WaypointMovementGenerator vars
diff --git a/src/server/game/Entities/Creature/TemporarySummon.cpp b/src/server/game/Entities/Creature/TemporarySummon.cpp
index b14d74e..d89018b 100644
--- a/src/server/game/Entities/Creature/TemporarySummon.cpp
+++ b/src/server/game/Entities/Creature/TemporarySummon.cpp
@@ -254,6 +254,14 @@ void TempSummon::UnSummon(uint32 msTime)
     if (owner && owner->GetTypeId() == TYPEID_UNIT && owner->ToCreature()->IsAIEnabled)
         owner->ToCreature()->AI()->SummonedCreatureDespawn(this);
 
+    //npcbot
+    if (GetIAmABot() || GetIAmABotsPet())
+    {
+        //TC_LOG_ERROR("TempSummon::UnSummon(): Trying to unsummon Bot %s(owner: %s). Aborted", GetName(), GetBotOwner()->GetName());
+        return;
+    }
+    //end npcbots
+
     AddObjectToRemoveList();
 }
 
diff --git a/src/server/game/Entities/Object/Object.cpp b/src/server/game/Entities/Object/Object.cpp
index e8bbf09..a0d209a 100644
--- a/src/server/game/Entities/Object/Object.cpp
+++ b/src/server/game/Entities/Object/Object.cpp
@@ -2395,6 +2395,11 @@ TempSummon* Map::SummonCreature(uint32 entry, Position const& pos, SummonPropert
             summon = new Puppet(properties, summoner);
             break;
         case UNIT_MASK_TOTEM:
+            //npcbot: totem emul step 1
+            if (summoner && summoner->GetTypeId() == TYPEID_UNIT && summoner->ToCreature()->GetIAmABot())
+                summon = new Totem(properties, summoner->ToCreature()->GetBotOwner());
+            else
+            //end npcbot
             summon = new Totem(properties, summoner);
             break;
         case UNIT_MASK_MINION:
@@ -2418,6 +2423,12 @@ TempSummon* Map::SummonCreature(uint32 entry, Position const& pos, SummonPropert
     AddToMap(summon->ToCreature());
     summon->InitSummon();
 
+    //npcbot: totem emul step 2
+    if (mask == UNIT_MASK_TOTEM)
+        if (summoner && summoner->GetTypeId() == TYPEID_UNIT && summoner->ToCreature()->GetIAmABot())
+            summoner->ToCreature()->OnBotSummon(summon);
+    //end npcbot
+
     //ObjectAccessor::UpdateObjectVisibility(summon);
 
     return summon;
diff --git a/src/server/game/Entities/Player/Player.cpp b/src/server/game/Entities/Player/Player.cpp
index 35d1d15..3aaeaae 100644
--- a/src/server/game/Entities/Player/Player.cpp
+++ b/src/server/game/Entities/Player/Player.cpp
@@ -81,6 +81,10 @@
 #include "WorldSession.h"
 #include "MovementStructures.h"
 
+//Bot
+#include "Config.h"
+#include "bothelper.h"
+
 #define ZONE_UPDATE_INTERVAL (1*IN_MILLISECONDS)
 
 enum CharacterFlags
@@ -529,6 +533,18 @@ inline void KillRewarder::_RewardXP(Player* player, float rate)
         for (Unit::AuraEffectList::const_iterator i = auras.begin(); i != auras.end(); ++i)
             AddPct(xp, (*i)->GetAmount());
 
+        //npcbot 4.2.2.1. Apply NpcBot XP reduction
+        if (player->HaveBot() && player->GetNpcBotsCount() > 1)
+        {
+            if (uint8 xp_rate = player->GetNpcBotXpReduction())
+            {
+                int32 ratePct = 100 - (player->GetNpcBotsCount() - 1) * xp_rate;
+                ratePct = std::max<int32>(ratePct, 10); // minimum
+                //ratePct = std::min<int32>(ratePct, 100); // maximum // dead code
+                xp = xp * ratePct / 100;
+            }
+        }
+
         // 4.2.3. Calculate expansion penalty
         if (_victim->GetTypeId() == TYPEID_UNIT && player->getLevel() >= GetMaxLevelForExpansion(_victim->ToCreature()->GetCreatureTemplate()->expansion))
             xp = CalculatePct(xp, 10); // Players get only 10% xp for killing creatures of lower expansion levels than himself
@@ -863,6 +879,30 @@ Player::Player(WorldSession* session): Unit(true), phaseMgr(this)
 
     m_ChampioningFaction = 0;
 
+    ///////////////////// Bot System ////////////////////////
+    _botHlpr = NULL;
+    //Npcbot
+    m_botTimer = 500;
+    m_bot = NULL;
+    m_botTankGuid = 0;
+    m_enableNpcBots = sConfigMgr->GetBoolDefault("Bot.EnableNpcBots", true);
+    m_followdist = sConfigMgr->GetIntDefault("Bot.BaseFollowDistance", 30);
+    m_maxNpcBots = std::min<uint8>(sConfigMgr->GetIntDefault("Bot.MaxNpcBots", 1), MAX_NPCBOTS);
+    uint8 maxcbots = sConfigMgr->GetIntDefault("Bot.MaxNpcBotsPerClass", 1);
+    m_maxClassNpcBots = maxcbots > 0 ? maxcbots : MAX_NPCBOTS;
+    m_xpReductionNpcBots = std::min<uint8>(sConfigMgr->GetIntDefault("Bot.XpReductionPercent", 0), 100);
+    m_enableAllNpcBots = sConfigMgr->GetBoolDefault("Bot.AllowAllClasses", false);
+    m_enableNpcBotsArenas = sConfigMgr->GetBoolDefault("Bot.EnableInArenas", true);
+    m_enableNpcBotsBGs = sConfigMgr->GetBoolDefault("Bot.EnableInBGs", true);
+    m_enableNpcBotsDungeons = sConfigMgr->GetBoolDefault("Bot.EnableInDungeons", true);
+    m_enableNpcBotsRaids = sConfigMgr->GetBoolDefault("Bot.EnableInRaids", true);
+    m_limitNpcBotsDungeons = sConfigMgr->GetBoolDefault("Bot.InstanceLimit.Dungeons", false);
+    m_limitNpcBotsRaids = sConfigMgr->GetBoolDefault("Bot.InstanceLimit.Raids", false);
+    m_NpcBotsCost = sConfigMgr->GetIntDefault("Bot.Cost", 0);
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+        m_botmap[i] = new NpcBotMap();
+    ///////////////////// End Bot System ////////////////////////
+
     for (uint8 i = 0; i < MAX_POWERS_PER_CLASS; ++i)
         m_powerFraction[i] = 0;
 
@@ -923,6 +963,16 @@ Player::~Player()
 
     ClearResurrectRequestData();
 
+    if (_botHlpr)
+    {
+        delete _botHlpr;
+        _botHlpr = NULL;
+    }
+
+    //Npcbot mod: delete botmap
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+        delete m_botmap[i];
+
     sWorld->DecreasePlayerCount();
 }
 
@@ -1840,6 +1890,17 @@ void Player::Update(uint32 p_time)
     //because we don't want player's ghost teleported from graveyard
     if (IsHasDelayedTeleport() && IsAlive())
         TeleportTo(m_teleport_dest, m_teleport_options);
+
+    //NpcBot mod: Update
+    if (m_botTimer > 0)
+    {
+        if (p_time >= m_botTimer)
+            m_botTimer = 0;
+        else
+            m_botTimer -= p_time;
+    }
+    else
+        RefreshBot(p_time);
 }
 
 void Player::setDeathState(DeathState s)
@@ -2229,6 +2290,13 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
         if (!sMapMgr->CanPlayerEnter(mapid, this, false))
             return false;
 
+        //Npcbot mod: prevent crash on InstanceMap::DestroyInstance()... Unit::RemoveFromWorld()
+        //if last player being kicked out of instance while having npcbots
+        //we must remove creature Before it will be removed in Map::UnloadAll()
+        if (GetMapId() != mapid)
+            for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+                RemoveBot(m_botmap[i]->m_guid);
+
         //I think this always returns true. Correct me if I am wrong.
         // If the map is not created, assume it is possible to enter it.
         // It will be created in the WorldPortAck.
@@ -2486,6 +2554,768 @@ void Player::RemoveFromWorld()
     }
 }
 
+void Player::RefreshBot(uint32 diff)
+{
+    if (m_botTimer > 0) return;
+    m_botTimer = 100 + IsInFlight()*3000;//x2 ms //temp hack
+    if (!HaveBot()) return;
+
+    //addition for revive timer (maybe we should check whole party?)
+    bool partyInCombat = IsInCombat();
+    if (!partyInCombat)
+    {
+        for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+        {
+            if (Creature* bot = m_botmap[i]->m_creature)
+            {
+                if (bot->IsInCombat())
+                {
+                    partyInCombat = true;
+                    break;
+                }
+                else if (Creature* pet = bot->GetBotsPet())
+                {
+                    if (pet->IsInCombat())
+                    {
+                        partyInCombat = true;
+                        break;
+                    }
+                }
+            }
+        }
+    }
+
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+    {
+        uint64 guid = m_botmap[i]->m_guid;
+        m_bot = m_botmap[i]->m_creature;
+        if (!m_bot || !m_bot->IsInWorld())
+            continue;
+        //BOT REVIVE SUPPORT
+        //Do not allow bot to be revived if master is in battle
+        if (!partyInCombat)
+        {
+            if (m_botmap[i]->m_reviveTimer > diff)
+            {
+                if (!IsInCombat())
+                    m_botmap[i]->m_reviveTimer -= diff;
+            }
+            else if (m_botmap[i]->m_reviveTimer > 0)
+                m_botmap[i]->m_reviveTimer = 0;
+        }
+        if ((m_bot->isDead() || !m_bot->IsAlive()) && IsAlive() && !IsInCombat() && !InArena() && !IsInFlight() && 
+            !HasFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_FEIGN_DEATH) && 
+            m_botmap[i]->m_reviveTimer == 0 && 
+            !HasInvisibilityAura() && !HasStealthAura())
+        {
+            CreateBot(0, 0, 0, false, true);//revive
+            continue;
+        }
+        //BOT MUST DIE SUPPORT
+        if (IsInFlight() || !GetGroup() || !GetGroup()->IsMember(m_bot->GetGUID()))//even if bot is dead
+        {
+            RemoveBot(guid, !IsInFlight());
+            continue;
+        }
+        //TELEPORT/OUTRUN SUPPORT
+        if (!IsInFlight() && IsAlive() && (m_bot->IsAlive() || m_bot->GetMapId() != GetMapId()))
+        {
+            float maxdist;
+            if (GetMap()->IsDungeon())
+                maxdist = sWorld->GetMaxVisibleDistanceInInstances();
+            else if (GetMap()->IsBattlegroundOrArena())
+                maxdist = sWorld->GetMaxVisibleDistanceInBGArenas();
+            else
+                maxdist = sWorld->GetMaxVisibleDistanceOnContinents();
+
+            maxdist += 20.0f; //allow player to recall it by moving back
+
+            if (abs(m_bot->GetPositionX() - GetPositionX()) > maxdist ||
+                abs(m_bot->GetPositionY() - GetPositionY()) > maxdist ||
+                m_bot->GetMapId() != GetMapId() || RestrictBots())
+            {
+                RemoveBot(guid);
+                continue;
+            }
+        }
+        m_bot = NULL;
+    }//end for botmap
+    //BOT CREATION/RECREATION SUPPORT
+    if (!IsInFlight() && IsAlive()/* && !GetTransport()*/ && GetBotMustBeCreated() && !RestrictBots())
+        for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+            if (m_botmap[pos]->m_entry != 0 && m_botmap[pos]->m_guid == 0)
+                CreateBot(m_botmap[pos]->m_entry, m_botmap[pos]->m_race, m_botmap[pos]->m_class, m_botmap[pos]->tank);
+}
+
+void Player::SetBotMustBeCreated(uint32 m_entry, uint8 m_race, uint8 m_class, bool istank)
+{
+    if (m_enableNpcBots == false)
+    {
+        ChatHandler ch(GetSession());
+        ch.SendSysMessage("NpcBot system currently disabled. Please contact your administration.");
+        ClearBotMustBeCreated(0, 0, true);
+        return;
+    }
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+    {
+        if (m_botmap[pos]->m_entry == 0)
+        {
+            m_botmap[pos]->m_guid = 0;//we need it to make sure Player::CreateBot will find this slot
+            m_botmap[pos]->m_entry = m_entry;
+            m_botmap[pos]->m_race = m_race;
+            m_botmap[pos]->m_class = m_class;
+            m_botmap[pos]->tank = istank;
+            break;
+        }
+    }
+}
+
+bool Player::GetBotMustBeCreated()
+{
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+    {
+        if (m_botmap[pos]->m_entry != 0 && 
+            (m_botmap[pos]->m_guid == 0 || !sObjectAccessor->FindUnit(m_botmap[pos]->m_guid)))
+        {
+            m_botmap[pos]->m_guid = 0;
+            return true;
+        }
+    }
+    return false;
+}
+
+void Player::ClearBotMustBeCreated(uint64 guidOrSlot, bool guid, bool fully)
+{
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+    {
+        if ((guid == true && m_botmap[pos]->m_guid == guidOrSlot) || 
+            (guid == false && pos == guidOrSlot) || 
+            fully)
+        {
+            m_botmap[pos]->m_guid = 0;
+            m_botmap[pos]->m_entry = 0;
+            m_botmap[pos]->m_race = 0;
+            m_botmap[pos]->m_class = 0;
+            m_botmap[pos]->m_creature = NULL;
+            m_botmap[pos]->tank = false;
+            if (!fully)
+                break;
+        }
+    }
+}
+
+void Player::RemoveBot(uint64 guid, bool final, bool eraseFromDB)
+{
+    if (guid == 0) return;
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+    {
+        if (m_botmap[i]->m_guid == guid)
+        {
+            m_bot = m_botmap[i]->m_creature;
+            break;
+        }
+    }
+    if (!m_bot)
+        m_bot = sObjectAccessor->GetObjectInWorld(guid, (Creature*)NULL);
+    if (m_bot)
+    {
+        //do not disband group unless not in dungeon or forced or on logout (Check WorldSession::LogoutPlayer())
+        Group* gr = GetGroup();
+        if (gr && gr->IsMember(guid))
+        {
+            if (gr->GetMembersCount() > 2 || /*!GetMap()->Instanceable() || */(final && eraseFromDB))
+                gr->RemoveMember(guid);
+            else //just cleanup
+            {
+                PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_GROUP_MEMBER);
+                stmt->setUInt32(0, GUID_LOPART(guid));
+                CharacterDatabase.Execute(stmt);
+            }
+        }
+
+        m_bot->SetBotsPetDied();
+        m_bot->SetCharmerGUID(0);
+        //m_bot->SetBotOwner(NULL);
+        m_bot->SetIAmABot(false);
+        SetMinion((Minion*)m_bot, false);
+        m_bot->CleanupsBeforeDelete();
+        m_bot->AddObjectToRemoveList();
+
+        if (final)//on logout or by command
+        {
+            ClearBotMustBeCreated(guid);
+            if (eraseFromDB)//by command
+            {
+                PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_NPCBOT);
+                stmt->setUInt32(0, GetGUIDLow());
+                stmt->setUInt32(1, m_bot->GetEntry());
+                CharacterDatabase.Execute(stmt);
+                //CharacterDatabase.PExecute("DELETE FROM `character_npcbot` WHERE `owner` = '%u' AND `entry` = '%u'", GetGUIDLow(), m_bot->GetEntry());
+            }
+        }
+        else
+        {
+            ModifyMoney(int64(GetNpcBotCost())); //temp restore money before retake
+
+            for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+            {
+                if (m_botmap[pos]->m_guid == guid)
+                {
+                    m_botmap[pos]->m_guid = 0;//reset guid so it can be set during recreation
+                    m_botmap[pos]->m_creature = NULL;
+                }
+            }
+        }
+        m_bot = NULL;
+    }
+}
+
+void Player::CreateBot(uint32 botentry, uint8 botrace, uint8 botclass, bool istank, bool revive)
+{
+    if (IsBeingTeleported() || IsInFlight()) return; //don't create bot yet
+    if (isDead() && !revive) return; //not to revive by command so abort
+    if (IsInCombat()) return;
+
+    if (m_bot != NULL && revive)
+    {
+        m_bot->SetHealth(m_bot->GetCreateHealth() / 6);//~15% of base health
+        if (m_bot->getPowerType() == POWER_MANA)
+            m_bot->SetPower(POWER_MANA, m_bot->GetCreateMana());
+        m_bot->setDeathState(ALIVE);
+        m_bot->SetBotCommandState(COMMAND_FOLLOW, true);
+        return;
+    }
+    if (m_enableNpcBots == false && revive == false)
+    {
+        ChatHandler ch(GetSession());
+        ch.SendSysMessage("NpcBot system currently disabled. Please contact administration.");
+        for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+            if (m_botmap[pos]->m_entry == botentry)
+                ClearBotMustBeCreated(pos, false);
+        return;
+    }
+    if (!botentry || !botrace || !botclass)
+    {
+        TC_LOG_ERROR(LOG_FILTER_PLAYER, "ERROR! CreateBot(): player %s (%u) trying to create bot with entry = %u, race = %u, class = %u, ignored", GetName().c_str(), GetGUIDLow(), botentry, botrace, botclass);
+        for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+            if (m_botmap[pos]->m_entry == botentry)
+                ClearBotMustBeCreated(pos, false);
+        return;
+    }
+    //npcbot counter is already increased in SetBotMustBeCreated()
+    if (GetNpcBotsCount() > GetMaxNpcBots())
+    {
+        ChatHandler ch(GetSession());
+        for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+            if (m_botmap[pos]->m_entry == botentry)
+                ClearBotMustBeCreated(pos, false);
+        ch.PSendSysMessage("Youre exceed max npcbots");
+        ch.SetSentErrorMessage(true);
+        return;
+    }
+    //instance limit check
+    if ((m_limitNpcBotsDungeons && GetMap()->IsNonRaidDungeon()) || (m_limitNpcBotsRaids && GetMap()->IsRaid()))
+    {
+        InstanceMap* map = (InstanceMap*)GetMap();
+        uint32 count = 0;
+        Map::PlayerList const& plMap = map->GetPlayers();
+        for (Map::PlayerList::const_iterator itr = plMap.begin(); itr != plMap.end(); ++itr)
+            if (Player* player = itr->GetSource())
+                count += (1 + player->GetNpcBotsCount());
+
+        //check "more" cuz current bot is queued and we are to choose to remove it or not
+        if (count > map->GetMaxPlayers())
+        {
+            ChatHandler ch(GetSession());
+            for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+                if (m_botmap[pos]->m_entry == botentry)
+                    ClearBotMustBeCreated(pos, false);
+            ch.PSendSysMessage("Instance players limit exceed");
+            ch.SetSentErrorMessage(true);
+            return;
+        }
+    }
+    if (GetGroup() && GetGroup()->isRaidGroup() && GetGroup()->IsFull())
+    {
+        ChatHandler ch(GetSession());
+        ch.PSendSysMessage("Your group is Full!");
+        ch.SetSentErrorMessage(true);
+        return;
+    }
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+        if (m_botmap[pos]->m_entry == botentry)
+            if (m_botmap[pos]->m_reviveTimer != 0)
+                return;
+
+    m_bot = SummonCreature(botentry, *this);
+
+    //check if we have free slot
+    bool _set = false;
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+    {
+        if (m_botmap[pos]->m_entry == botentry && m_botmap[pos]->m_guid == 0)
+        {
+            m_botmap[pos]->m_guid = m_bot->GetGUID();
+            m_botmap[pos]->m_creature = m_bot;//this will save some time but we need guid as well
+            m_botmap[pos]->tank = istank;
+            _set = true;
+            break;
+        }
+    }
+    if (!_set)
+    {
+        TC_LOG_ERROR(LOG_FILTER_PLAYER, "character %s (%u) is failed to create npcbot! Removing all bots", GetName().c_str(), GetGUIDLow());
+
+        m_bot->CombatStop();
+        m_bot->CleanupsBeforeDelete();
+        m_bot->AddObjectToRemoveList();
+        for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+            RemoveBot(m_botmap[pos]->m_guid, true);
+        ClearBotMustBeCreated(0, false, true);
+        return;
+    }
+
+    m_bot->SetBotOwner(this);
+    m_bot->SetUInt64Value(UNIT_FIELD_CREATEDBY, GetGUID());
+    SetMinion((Minion*)m_bot, true);
+    m_bot->CombatStop();
+    m_bot->DeleteThreatList();
+    m_bot->AddUnitTypeMask(UNIT_MASK_MINION);
+
+    m_bot->SetByteValue(UNIT_FIELD_BYTES_0, 0, botrace);
+    m_bot->setFaction(getFaction());
+    m_bot->SetLevel(getLevel());
+    m_bot->SetBotClass(botclass);
+    m_bot->AIM_Initialize();
+    m_bot->InitBotAI();
+    m_bot->SetBotCommandState(COMMAND_FOLLOW, true);
+
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+    //entry is unique for each master's bot so clean it up just in case
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_NPCBOT);
+    stmt->setUInt32(0, GetGUIDLow());
+    stmt->setUInt32(1, botentry);
+    trans->Append(stmt);
+    //CharacterDatabase.Execute(stmt);
+    //CharacterDatabase.PExecute("DELETE FROM `character_npcbot` WHERE `owner` = '%u' AND `entry` = '%u'", GetGUIDLow(), botentry);
+    //add the new entry
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_NPCBOT);
+    stmt->setUInt32(0, GetGUIDLow());
+    stmt->setUInt32(1, botentry);
+    stmt->setUInt8(2, botrace);
+    stmt->setUInt8(3, botclass);
+    stmt->setUInt8(4, uint8(istank));
+    trans->Append(stmt);
+    CharacterDatabase.CommitTransaction(trans);
+    //CharacterDatabase.Execute(stmt);
+    //CharacterDatabase.PExecute("INSERT INTO `character_npcbot` (owner,entry,race,class,istank) VALUES ('%u','%u','%u','%u','%u')", GetGUIDLow(), botentry, botrace, botclass, uint8(istank));
+    //If we have a group, just add bot
+    if (Group* gr = GetGroup())
+    {
+        if (!gr->IsFull())
+        {
+            if (!gr->AddMember((Player*)m_bot))
+                RemoveBot(m_bot->GetGUID(), true);
+        }
+        else if (!gr->isRaidGroup()) //non-raid group is full
+        {
+            gr->ConvertToRaid();
+            if (!gr->AddMember((Player*)m_bot))
+                RemoveBot(m_bot->GetGUID(), true);
+        }
+        else //raid group is full
+            RemoveBot(m_bot->GetGUID(), true);
+    }
+    else
+    {
+        gr = new Group;
+        if (!gr->Create(this))
+        {
+            delete gr;
+            return;
+        }
+        sGroupMgr->AddGroup(gr);
+        if (!gr->AddMember((Player*)m_bot))
+            RemoveBot(m_bot->GetGUID(), true);
+    }
+
+    if (uint32 cost = GetNpcBotCost())
+        ModifyMoney(-(int32(cost)));
+
+
+    if (Group* gr = GetGroup())
+    {
+        Group::MemberSlotList const a = gr->GetMemberSlots();
+        //try to remove 'absent' bots
+        for (Group::member_citerator itr = a.begin(); itr != a.end(); ++itr)
+        {
+            if (itr->guid == 0)
+                continue;
+            if (IS_PLAYER_GUID(itr->guid))
+                continue;
+            if (!sObjectAccessor->FindUnit(itr->guid))
+                gr->RemoveMember(itr->guid);
+        }
+    }
+
+} //end Player::CreateBot
+
+uint8 Player::GetNpcBotsCount() const
+{
+    uint8 bots = 0;
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+        if (m_botmap[pos]->m_entry != 0)
+            ++bots;
+    return bots;
+}
+
+uint8 Player::GetMaxNpcBots() const
+{
+    return (GetSession()->GetSecurity() == SEC_PLAYER) ?  m_maxNpcBots : MAX_NPCBOTS;
+}
+
+bool Player::HaveBot() const
+{
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+        if (m_botmap[i]->m_entry != 0)
+            return true;
+    return false;
+}
+
+void Player::SendBotCommandState(Creature* cre, CommandStates state)
+{
+    if (!cre) return;
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+        if (m_botmap[i]->m_creature == cre)
+            cre->SetBotCommandState(state, true);
+}
+//finds bot's slot into master's botmap
+uint8 Player::GetNpcBotSlot(uint64 guid) const
+{
+    if (guid)
+        for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+            if (m_botmap[i]->m_guid == guid)
+                return i;
+    return 0;
+}
+
+void Player::SetBotTank(uint64 guid)
+{
+    m_botTankGuid = guid;
+    if (guid == 0 || !IS_CREATURE_GUID(guid)) //reset tank or set player - remove from all npcbots
+    {
+        for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+        {
+            if (m_botmap[i]->tank == true)
+            {
+                PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_TANK);
+                stmt->setUInt8(0, uint8(0));
+                stmt->setUInt32(1, GetGUIDLow());
+                stmt->setUInt32(2, m_botmap[i]->m_entry);
+                CharacterDatabase.Execute(stmt);
+                //CharacterDatabase.PExecute("UPDATE `character_npcbot` SET `istank` = '0' WHERE `owner` = '%u' AND `entry` = '%u'", GetGUIDLow(), m_botmap[i]->m_entry);
+                m_botmap[i]->tank = false;
+            }
+        }
+        return;
+    }
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+    {
+        if (m_botmap[i]->tank == true)
+        {
+            if (m_botmap[i]->m_guid != guid)
+            {
+                m_botmap[i]->tank = false;
+                PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_TANK);
+                stmt->setUInt8(0, uint8(0));
+                stmt->setUInt32(1, GetGUIDLow());
+                stmt->setUInt32(2, m_botmap[i]->m_entry);
+                CharacterDatabase.Execute(stmt);
+                //CharacterDatabase.PExecute("UPDATE `character_npcbot` SET `istank` = '0' WHERE `owner` = '%u' AND `entry` = '%u'", GetGUIDLow(), m_botmap[i]->m_entry);
+            }
+        }
+        else if (m_botmap[i]->m_guid == guid)
+        {
+            m_botmap[i]->tank = true;
+            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_TANK);
+            stmt->setUInt8(0, uint8(1));
+            stmt->setUInt32(1, GetGUIDLow());
+            stmt->setUInt32(2, m_botmap[i]->m_entry);
+            CharacterDatabase.Execute(stmt);
+            //CharacterDatabase.PExecute("UPDATE `character_npcbot` SET `istank` = '1' WHERE `owner` = '%u' AND `entry` = '%u'", GetGUIDLow(), m_botmap[i]->m_entry);
+            break;
+        }
+    }
+}
+
+Unit* Player::GetBotTank(uint32 entry)
+{
+    if (!entry) return NULL;
+
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+        if (m_botmap[i]->m_entry == entry && m_botmap[i]->tank == true)
+            return m_botmap[i]->m_creature;
+
+    return NULL;
+}
+
+void Player::SetNpcBotDied(uint64 guid)
+{
+    if (!guid) return;
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+        if (m_botmap[pos]->m_guid == guid)
+        {
+            m_botmap[pos]->m_reviveTimer = 15000;
+            break;
+        }
+}
+
+bool Player::RestrictBots() const
+{
+    return
+        (!m_enableNpcBotsBGs && GetMap()->IsBattleground()) ||
+        (!m_enableNpcBotsArenas && GetMap()->IsBattleArena()) ||
+        (!m_enableNpcBotsDungeons && GetMap()->IsNonRaidDungeon()) ||
+        (!m_enableNpcBotsRaids && GetMap()->IsRaid());
+}
+
+uint32 Player::GetNpcBotCost() const
+{
+    return m_NpcBotsCost ? uint32((m_NpcBotsCost / 85.f) * getLevel()) : 0;
+}
+
+std::string Player::GetNpcBotCostStr() const
+{
+    std::ostringstream money;
+
+    if (uint32 cost = GetNpcBotCost())
+    {
+        uint32 gold = uint32(cost / 10000);
+        cost -= (gold * 10000);
+        uint32 silver = uint32(cost / 100);
+        cost -= (silver * 100);
+
+        if (gold != 0)
+            money << gold << " |TInterface\\Icons\\INV_Misc_Coin_01:8|t";
+        if (silver != 0)
+            money << silver << " |TInterface\\Icons\\INV_Misc_Coin_03:8|t";
+        money << cost << " |TInterface\\Icons\\INV_Misc_Coin_05:8|t";
+    }
+    return money.str();
+}
+
+//NPCbot base setup
+void Player::CreateNPCBot(uint8 bot_class)
+{
+    //check if we have too many bots of that class
+    if (HaveBot())
+    {
+        uint8 count = 0;
+        for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+            if (m_botmap[i]->m_class == bot_class)
+                ++count;
+        if (count >= m_maxClassNpcBots)
+        {
+            //SendBuyError(BUY_ERR_NOT_ENOUGHT_MONEY, 0, 0, 0);
+            ChatHandler ch(GetSession());
+            ch.PSendSysMessage("You cannot have more bots of that class! %u of %u", count, m_maxClassNpcBots);
+            ch.SetSentErrorMessage(true);
+            return;
+        }
+    }
+
+    //check if not allowed class is chosen
+    if (!m_enableAllNpcBots &&
+        (bot_class != CLASS_WARRIOR &&
+        bot_class != CLASS_PALADIN &&
+        bot_class != CLASS_PRIEST &&
+        bot_class != CLASS_MAGE &&
+        bot_class != CLASS_DRUID &&
+        bot_class != CLASS_WARLOCK &&
+        bot_class != CLASS_ROGUE))
+    {
+        ChatHandler ch(GetSession());
+        const char* bclass;
+        switch (bot_class)
+        {
+            case CLASS_DEATH_KNIGHT:    bclass = "DeathKnight"; break;
+            case CLASS_SHAMAN:          bclass = "Shaman"; break;
+            case CLASS_HUNTER:          bclass = "Hunter"; break;
+            default:                    bclass = "Unknown Class"; break;
+        }
+        TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player::CreateNPCBot(): Character %u tried to create npcbot of class %s, which is not allowed on your server!", GetGUIDLow(), bclass);
+        ch.PSendSysMessage("You've tried to create npcbot of class %s, which is not allowed on this server!", bclass);
+        ch.SetSentErrorMessage(true);
+        return;
+    }
+
+    //check if player cannot afford a bot
+    if (GetMoney() < GetNpcBotCost())
+    {
+        ChatHandler ch(GetSession());
+        std::string str = "You don't have enough money (";
+        str += GetNpcBotCostStr();
+        str += ")!";
+        ch.SendSysMessage(str.c_str());
+        ch.SetSentErrorMessage(true);
+        return;
+    }
+
+    PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_NPCBOT_TEMPLATE);
+    std::ostringstream classStr;
+
+    switch (bot_class)
+    {
+        case CLASS_ROGUE:
+            classStr << "rogue_bot";    break;
+        case CLASS_PRIEST:
+            classStr << "priest_bot";   break;
+        case CLASS_DRUID:
+            classStr << "druid_bot";    break;
+        case CLASS_SHAMAN:
+            classStr << "shaman_bot";   break;
+        case CLASS_MAGE:
+            classStr << "mage_bot";     break;
+        case CLASS_WARLOCK:
+            classStr << "warlock_bot";  break;
+        case CLASS_WARRIOR:
+            classStr << "warrior_bot";  break;
+        case CLASS_PALADIN:
+            classStr << "paladin_bot";  break;
+        case CLASS_HUNTER:
+            classStr << "hunter_bot";   break;
+        //case CLASS_DEATH_KNIGHT:
+        //    classStr << "dk_bot";       break;
+        default:
+            ChatHandler ch(GetSession());
+            ch.PSendSysMessage("ERROR! unknown bot_class %u", bot_class);
+            ch.SetSentErrorMessage(true);
+            TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player::CreateNPCBot() player %u(%s) tried to create bot of unknown/unsupported class %u!", GetGUIDLow(), GetName().c_str(), bot_class);
+            return;
+    }
+
+    stmt->setString(0, classStr.str());
+    stmt->setUInt8(1, bot_class);
+
+    //maybe we should remove this check? ;
+    switch (getRace())
+    {
+        case RACE_NONE:
+        case RACE_HUMAN:
+        case RACE_DWARF:
+        case RACE_NIGHTELF:
+        case RACE_GNOME:
+        case RACE_DRAENEI:
+        case RACE_WORGEN:
+            stmt->setUInt8(2, uint8(1));
+            stmt->setUInt8(3, uint8(3));
+            stmt->setUInt8(4, uint8(4));
+            stmt->setUInt8(5, uint8(7));
+            stmt->setUInt8(6, uint8(11));
+            break;
+
+        case RACE_ORC:
+        case RACE_UNDEAD_PLAYER:
+        case RACE_TAUREN:
+        case RACE_TROLL:
+        case RACE_BLOODELF:
+        case RACE_GOBLIN:
+            stmt->setUInt8(2, uint8(2));
+            stmt->setUInt8(3, uint8(5));
+            stmt->setUInt8(4, uint8(6));
+            stmt->setUInt8(5, uint8(8));
+            stmt->setUInt8(6, uint8(10));
+            break;
+    }
+
+    PreparedQueryResult result = WorldDatabase.Query(stmt);
+    if (!result)
+    {
+        TC_LOG_FATAL(LOG_FILTER_PLAYER, "Player::CreateNPCBot() CANNOT create bot of class %u, not found in DB", bot_class);
+        return;
+    }
+
+    uint32 entry = 0;
+    uint32 bot_race = 0;
+
+    //find a bot to add
+    //first check randomly selected bot, second check any bot we can add
+    typedef std::list< std::pair<uint32, uint8> > NpcBotsDataTemplate;
+    NpcBotsDataTemplate npcBotsData;
+    do
+    {
+        Field* fields = result->Fetch();
+        uint32 temp_entry = fields[0].GetUInt32();
+        uint8 temp_race = fields[1].GetUInt8();
+        npcBotsData.push_back(std::pair<uint32, uint8>(temp_entry, temp_race));
+    } while (result->NextRow());
+
+    uint32 m_rand = urand(1, uint32(result->GetRowCount()));
+    uint32 tmp_rand = 1;
+    std::list< std::pair<uint32, uint8> >::const_iterator itr = npcBotsData.begin();
+    bool haveSameBot = false;
+    bool moveback = false;
+    bool forcedCheck = false;
+    bool secondCheck = false;
+    while (true)
+    {
+        if (itr == npcBotsData.end()) //end of list is reached (selected bot is checked)
+        {
+            moveback = true;
+            --itr; //tmp_rand is not needed anymore
+            continue;
+        }
+        if (moveback && itr == npcBotsData.begin()) //search is finished, nothing found
+            break;
+        if (tmp_rand == m_rand || haveSameBot)
+        {
+            bool canAdd = true;
+            for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+            {
+                if (m_botmap[i]->m_entry == itr->first)
+                {
+                    haveSameBot = true;
+                    canAdd = false;
+                    if (!secondCheck)
+                        forcedCheck = true;
+                    secondCheck = true;
+                    break;
+                }
+            }
+            if (canAdd)
+            {
+                entry = itr->first;
+                bot_race = itr->second;
+                break;
+            }
+            if (forcedCheck)
+            {
+                itr = npcBotsData.begin(); //reset searcher pos
+                forcedCheck = false;
+                continue;
+            }
+        }
+        //move through
+        if (moveback)
+            --itr;
+        else
+        {
+            ++itr;
+            ++tmp_rand;
+        }
+    }
+
+    if (!entry || !bot_race)
+    {
+        ChatHandler ch(GetSession());
+        ch.SendSysMessage("No more bots of this class available");
+        ch.SetSentErrorMessage(true);
+        return;
+    }
+
+    SetBotMustBeCreated(entry, bot_race, bot_class);
+}
+
 void Player::RegenerateAll()
 {
     //if (m_regenTimer <= 500)
@@ -3010,6 +3840,26 @@ void Player::RemoveFromGroup(Group* group, uint64 guid, RemoveMethod method /* =
 {
     if (group)
     {
+        if (Player* player = ObjectAccessor::FindPlayer(guid))
+        {
+            if (player->HaveBot())
+            {
+                uint8 players = 0;
+                Group::MemberSlotList const& members = group->GetMemberSlots();
+                for (Group::member_citerator itr = members.begin(); itr!= members.end(); ++itr)
+                {
+                    if (Player* pl = ObjectAccessor::FindPlayer(itr->guid))
+                        ++players;
+                }
+
+                //remove npcbots so group will be disbanded if only 1 player
+                for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
+                    player->RemoveBot(player->GetBotMap(i)->m_guid, players <= 1);
+                group = player->GetGroup();
+                if (!group)
+                    return; //group has been disbanded
+            }
+        }
         group->RemoveMember(guid, method, kicker, reason);
         group = NULL;
     }
@@ -5037,6 +5887,13 @@ void Player::DeleteFromDB(uint64 playerguid, uint32 accountId, bool updateRealmC
             stmt->setUInt32(0, guid);
             trans->Append(stmt);
 
+            //npcbot - erase npcbots
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_NPCBOTS);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+            //CharacterDatabase.PExecute("DELETE FROM `character_npcbot` WHERE `owner` = '%u'", guid);
+            //end npcbot
+
             CharacterDatabase.CommitTransaction(trans);
             break;
         }
diff --git a/src/server/game/Entities/Player/Player.h b/src/server/game/Entities/Player/Player.h
index 8a1f09b..ab2e474 100644
--- a/src/server/game/Entities/Player/Player.h
+++ b/src/server/game/Entities/Player/Player.h
@@ -57,6 +57,11 @@ class SpellCastTargets;
 class UpdateMask;
 class PhaseMgr;
 
+// NpcBot mod
+struct NpcBotMap;
+#define MAX_NPCBOTS 40
+class BotHelper;
+
 typedef std::deque<Mail*> PlayerMails;
 
 #define PLAYER_MAX_SKILLS           128
@@ -2524,6 +2529,39 @@ class Player : public Unit, public GridObject<Player>
         VoidStorageItem* GetVoidStorageItem(uint8 slot) const;
         VoidStorageItem* GetVoidStorageItem(uint64 id, uint8& slot) const;
 
+        /*********************************************************/
+        /***                     BOT SYSTEM                    ***/
+        /*********************************************************/
+        void SetBotHelper(BotHelper* hlpr) { ASSERT (!_botHlpr); _botHlpr = hlpr; }
+        BotHelper* GetBotHelper() const { return _botHlpr; }
+        void RefreshBot(uint32 p_time);
+        void CreateBot(uint32 botentry, uint8 botrace, uint8 botclass, bool istank = false, bool revive = false);
+        void CreateNPCBot(uint8 botclass);
+        uint8 GetNpcBotSlot(uint64 guid) const;
+        void SendBotCommandState(Creature* cre, CommandStates state);
+        bool HaveBot() const;
+        void RemoveBot(uint64 guid, bool final = false, bool eraseFromDB = true);
+        void SetBot(Creature* cre) { m_bot = cre; }
+        uint8 GetNpcBotsCount() const;
+        void SetBotMustBeCreated(uint32 m_entry, uint8 m_race, uint8 m_class, bool istank = false);
+        void ClearBotMustBeCreated(uint64 value, bool guid = true, bool fully = false);
+        bool GetBotMustBeCreated();
+        uint64 GetBotTankGuid() const { return m_botTankGuid; }
+        void SetBotTank(uint64 guid);
+        Unit* GetBotTank(uint32 entry);
+        uint8 GetBotFollowDist() const { return m_followdist; }
+        void SetBotFollowDist(int8 dist) { m_followdist = dist; }
+        void SetNpcBotDied(uint64 guid);
+        NpcBotMap const* GetBotMap(uint8 pos) const { return m_botmap[pos]; }
+        uint8 GetMaxNpcBots() const;
+        uint8 GetNpcBotXpReduction() const { return m_xpReductionNpcBots; }
+        bool RestrictBots() const;
+        uint32 GetNpcBotCost() const;
+        std::string GetNpcBotCostStr() const;
+        /*********************************************************/
+        /***                 END BOT SYSTEM                    ***/
+        /*********************************************************/
+
     protected:
         // Gamemaster whisper whitelist
         WhisperListContainer WhisperList;
@@ -2806,6 +2844,31 @@ class Player : public Unit, public GridObject<Player>
         CUFProfile* _CUFProfiles[MAX_CUF_PROFILES];
 
     private:
+        /*********************************************************/
+        /***                     BOT SYSTEM                    ***/
+        /*********************************************************/
+        BotHelper* _botHlpr;
+        Creature* m_bot;
+        int8 m_followdist;
+        uint64 m_botTankGuid;
+        uint8 m_maxNpcBots;
+        uint8 m_maxClassNpcBots;
+        uint8 m_xpReductionNpcBots;
+        bool m_enableNpcBots;
+        bool m_enableAllNpcBots;
+        bool m_enableNpcBotsArenas;
+        bool m_enableNpcBotsBGs;
+        bool m_enableNpcBotsDungeons;
+        bool m_enableNpcBotsRaids;
+        bool m_limitNpcBotsDungeons;
+        bool m_limitNpcBotsRaids;
+        uint32 m_NpcBotsCost;
+        uint32 m_botTimer;
+        NpcBotMap* m_botmap[MAX_NPCBOTS];
+        /*********************************************************/
+        /***                END BOT SYSTEM                     ***/
+        /*********************************************************/
+
         // internal common parts for CanStore/StoreItem functions
         InventoryResult CanStoreItem_InSpecificSlot(uint8 bag, uint8 slot, ItemPosCountVec& dest, ItemTemplate const* pProto, uint32& count, bool swap, Item* pSrcItem) const;
         InventoryResult CanStoreItem_InBag(uint8 bag, ItemPosCountVec& dest, ItemTemplate const* pProto, uint32& count, bool merge, bool non_specialized, Item* pSrcItem, uint8 skip_bag, uint8 skip_slot) const;
diff --git a/src/server/game/Entities/Unit/StatSystem.cpp b/src/server/game/Entities/Unit/StatSystem.cpp
index e319f45..7cca507 100644
--- a/src/server/game/Entities/Unit/StatSystem.cpp
+++ b/src/server/game/Entities/Unit/StatSystem.cpp
@@ -167,6 +167,10 @@ bool Player::UpdateAllStats()
     for (int i = SPELL_SCHOOL_NORMAL; i < MAX_SPELL_SCHOOL; ++i)
         UpdateResistances(i);
 
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+        if (Creature* bot = GetBotMap(i)->_Cre())
+            bot->SetBotShouldUpdateStats();
+
     return true;
 }
 
diff --git a/src/server/game/Entities/Unit/Unit.cpp b/src/server/game/Entities/Unit/Unit.cpp
index 79267c9..6bea040 100644
--- a/src/server/game/Entities/Unit/Unit.cpp
+++ b/src/server/game/Entities/Unit/Unit.cpp
@@ -346,6 +346,17 @@ void Unit::Update(uint32 p_time)
                 m_CombatTimer -= p_time;
         }
     }
+    // update combat timer also for npcbots
+    if (IsInCombat() && GetTypeId() == TYPEID_UNIT && !GetVictim() && (ToCreature()->GetIAmABot() || ToCreature()->GetIAmABotsPet()))
+    {
+        if (m_HostileRefManager.isEmpty())
+        {
+            if (m_CombatTimer <= p_time)
+                ClearInCombat();
+            else
+                m_CombatTimer -= p_time;
+        }
+    }
 
     // not implemented before 3.0.2
     if (uint32 base_att = getAttackTimer(BASE_ATTACK))
@@ -579,6 +590,12 @@ uint32 Unit::DealDamage(Unit* victim, uint32 damage, CleanDamage const* cleanDam
         if (pet && pet->IsAlive())
             pet->AI()->OwnerAttackedBy(this);
 
+        // NpcBot mod: also signal owned npcbots
+        for (ControlList::const_iterator itr = victim->ToPlayer()->m_Controlled.begin(); itr != victim->ToPlayer()->m_Controlled.end(); ++itr)
+            if (Creature* cre = (*itr)->ToCreature())
+                if (cre->GetIAmABot() && cre->IsAIEnabled)
+                    cre->AI()->OwnerAttackedBy(this);
+
         if (victim->ToPlayer()->GetCommandStatus(CHEAT_GOD))
             return 0;
     }
@@ -971,6 +988,11 @@ void Unit::CalculateSpellDamageTaken(SpellNonMeleeDamage* damageInfo, int32 dama
         case SPELL_DAMAGE_CLASS_RANGED:
         case SPELL_DAMAGE_CLASS_MELEE:
         {
+            //Npcbot mod: apply bot damage mods
+            if (Creature* bot = ToCreature())
+                if (bot->GetIAmABot() || bot->GetIAmABotsPet())
+                    bot->ApplyBotDamageMultiplierMelee(damage, *damageInfo, spellInfo, attackType, crit);
+
             // Physical Damage
             if (damageSchoolMask & SPELL_SCHOOL_MASK_NORMAL)
             {
@@ -1021,6 +1043,11 @@ void Unit::CalculateSpellDamageTaken(SpellNonMeleeDamage* damageInfo, int32 dama
         case SPELL_DAMAGE_CLASS_NONE:
         case SPELL_DAMAGE_CLASS_MAGIC:
         {
+            //Npcbot mod: apply bot damage mods
+            if (Creature* bot = ToCreature())
+                if (bot->GetIAmABot() || bot->GetIAmABotsPet())
+                    bot->ApplyBotDamageMultiplierSpell(damage, *damageInfo, spellInfo, attackType, crit);
+
             // If crit add critical bonus
             if (crit)
             {
@@ -1137,6 +1164,11 @@ void Unit::CalculateMeleeDamage(Unit* victim, uint32 damage, CalcDamageInfo* dam
     // Script Hook For CalculateMeleeDamage -- Allow scripts to change the Damage pre class mitigation calculations
     sScriptMgr->ModifyMeleeDamage(damageInfo->target, damageInfo->attacker, damage);
 
+    //Npcbot mod: apply bot damage mods
+    if (Creature* bot = ToCreature())
+        if (bot->GetIAmABot() || bot->GetIAmABotsPet())
+            bot->ApplyBotDamageMultiplierMelee(damage, *damageInfo);
+
     // Calculate armor reduction
     if (IsDamageReducedByArmor((SpellSchoolMask)(damageInfo->damageSchoolMask)))
     {
@@ -8788,6 +8820,7 @@ bool Unit::isSpellCrit(Unit* victim, SpellInfo const* spellProto, SpellSchoolMas
     //! Mobs can't crit with spells. Player Totems can
     //! Fire Elemental (from totem) can too - but this part is a hack and needs more research
     if (IS_CREATURE_GUID(GetGUID()) && !(IsTotem() && IS_PLAYER_GUID(GetOwnerGUID())) && GetEntry() != 15438)
+        if (!ToCreature()->GetIAmABot())
         return false;
 
     // not critting spell
@@ -10945,6 +10978,13 @@ float Unit::ApplyEffectModifiers(SpellInfo const* spellProto, uint8 effect_index
                 break;
         }
     }
+
+    //bot: effect modifiers
+    Creature const* cre = ToCreature();
+    if (cre && (cre->GetIAmABot() || cre->GetIAmABotsPet()))
+        cre->ApplyBotDamageMultiplierEffect(spellProto, effect_index, value);
+    //end bot
+
     return value;
 }
 
@@ -11335,6 +11375,11 @@ bool Unit::HandleStatModifier(UnitMods unitMod, UnitModifierType modifierType, f
             break;
     }
 
+    if (Player* master = ToPlayer())
+        for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
+            if (Creature* bot = master->GetBotMap(i)->_Cre())
+                bot->SetBotShouldUpdateStats();
+
     return true;
 }
 
@@ -11640,6 +11685,10 @@ uint32 Unit::GetPowerIndex(uint32 powerType) const
     if (ToPet() && ToPet()->getPetType() == HUNTER_PET)
         classId = CLASS_HUNTER;
 
+    //Bot: another hack is for npcbots
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->GetIAmABot())
+        classId = ToCreature()->GetBotClass();
+
     return GetPowerIndexByClass(powerType, classId);
 }
 
@@ -14931,6 +14980,181 @@ uint32 Unit::GetModelForForm(ShapeshiftForm form) const
                 break;
         }
     }
+    else if (ToCreature() && ToCreature()->GetIAmABot())
+    {
+        Player const *player = ToCreature()->GetBotOwner();
+        //let's make druids alike for each player
+        switch (form)
+        {
+            case FORM_CAT:
+                // Based on master's Hair color
+                if (player->getRace() == RACE_NIGHTELF)
+                {
+                    uint8 hairColor = player->GetByteValue(PLAYER_BYTES, 3);
+                    switch (hairColor)
+                    {
+                        case 7: // Violet
+                        case 8:
+                            return 29405;
+                        case 3: // Light Blue
+                            return 29406;
+                        case 0: // Green
+                        case 1: // Light Green
+                        case 2: // Dark Green
+                            return 29407;
+                        case 4: // White
+                            return 29408;
+                        default: // original - Dark Blue
+                            return 892;
+                    }
+                }
+                // Based on master's Skin color
+                else if (player->getRace() == RACE_TAUREN)
+                {
+                    uint8 skinColor = player->GetByteValue(PLAYER_BYTES, 0);
+                    // Male master
+                    if (player->getGender() == GENDER_MALE)
+                    {
+                        switch (skinColor)
+                        {
+                            case 12: // White
+                            case 13:
+                            case 14:
+                            case 18: // Completly White
+                                return 29409;
+                            case 9: // Light Brown
+                            case 10:
+                            case 11:
+                                return 29410;
+                            case 6: // Brown
+                            case 7:
+                            case 8:
+                                return 29411;
+                            case 0: // Dark
+                            case 1:
+                            case 2:
+                            case 3: // Dark Grey
+                            case 4:
+                            case 5:
+                                return 29412;
+                            default: // original - Grey
+                                return 8571;
+                        }
+                    }
+                    // Female master
+                    else switch (skinColor)
+                    {
+                        case 10: // White
+                            return 29409;
+                        case 6: // Light Brown
+                        case 7:
+                            return 29410;
+                        case 4: // Brown
+                        case 5:
+                            return 29411;
+                        case 0: // Dark
+                        case 1:
+                        case 2:
+                        case 3:
+                            return 29412;
+                        default: // original - Grey
+                            return 8571;
+                    }
+                }
+                else if (Player::TeamForRace(player->getRace()) == ALLIANCE)
+                    return 892;
+                else
+                    return 8571;
+            case FORM_BEAR:
+                // Based on Hair color
+                if (player->getRace() == RACE_NIGHTELF)
+                {
+                    uint8 hairColor = player->GetByteValue(PLAYER_BYTES, 3);
+                    switch (hairColor)
+                    {
+                        case 0: // Green
+                        case 1: // Light Green
+                        case 2: // Dark Green
+                            return 29413; // 29415?
+                        case 6: // Dark Blue
+                            return 29414;
+                        case 4: // White
+                            return 29416;
+                        case 3: // Light Blue
+                            return 29417;
+                        default: // original - Violet
+                            return 2281;
+                    }
+                }
+                // Based on Skin color
+                else if (player->getRace() == RACE_TAUREN)
+                {
+                    uint8 skinColor = player->GetByteValue(PLAYER_BYTES, 0);
+                    // Male
+                    if (player->getGender() == GENDER_MALE)
+                    {
+                        switch (skinColor)
+                        {
+                            case 0: // Dark (Black)
+                            case 1:
+                            case 2:
+                                return 29418;
+                            case 3: // White
+                            case 4:
+                            case 5:
+                            case 12:
+                            case 13:
+                            case 14:
+                                return 29419;
+                            case 9: // Light Brown/Grey
+                            case 10:
+                            case 11:
+                            case 15:
+                            case 16:
+                            case 17:
+                                return 29420;
+                            case 18: // Completly White
+                                return 29421;
+                            default: // original - Brown
+                                return 2289;
+                        }
+                    }
+                    // Female
+                    else switch (skinColor)
+                    {
+                        case 0: // Dark (Black)
+                        case 1:
+                            return 29418;
+                        case 2: // White
+                        case 3:
+                            return 29419;
+                        case 6: // Light Brown/Grey
+                        case 7:
+                        case 8:
+                        case 9:
+                            return 29420;
+                        case 10: // Completly White
+                            return 29421;
+                        default: // original - Brown
+                            return 2289;
+                    }
+                }
+                else if (Player::TeamForRace(player->getRace()) == ALLIANCE)
+                    return 2281;
+                else
+                    return 2289;
+            case FORM_FLIGHT:
+                if (Player::TeamForRace(player->getRace()) == ALLIANCE)
+                    return 20857;
+                return 20872;
+            case FORM_FLIGHT_EPIC:
+                if (Player::TeamForRace(player->getRace()) == ALLIANCE)
+                    return 21243;
+                return 21244;
+            default:
+                break;
+        }
+    }
 
     uint32 modelid = 0;
     SpellShapeshiftFormEntry const* formEntry = sSpellShapeshiftFormStore.LookupEntry(form);
diff --git a/src/server/game/Groups/Group.cpp b/src/server/game/Groups/Group.cpp
index 03bfe56..67a9abd 100644
--- a/src/server/game/Groups/Group.cpp
+++ b/src/server/game/Groups/Group.cpp
@@ -110,6 +110,9 @@ bool Group::Create(Player* leader)
     if (m_groupType & GROUPTYPE_RAID)
         _initRaidSubGroupsCounter();
 
+    if (leader->HaveBot()) //player + npcbot so set to free-for-all on create
+        m_lootMethod = FREE_FOR_ALL;
+    else
     if (!isLFGGroup())
         m_lootMethod = GROUP_LOOT;
 
@@ -396,6 +399,8 @@ bool Group::AddMember(Player* player)
 
     SubGroupCounterIncrease(subGroup);
 
+    if (IS_PLAYER_GUID(player->GetGUID()))
+    {
     player->SetGroupInvite(NULL);
     if (player->GetGroup())
     {
@@ -411,6 +416,7 @@ bool Group::AddMember(Player* player)
     InstanceGroupBind* bind = GetBoundInstance(player);
     if (bind && bind->save->GetInstanceId() == player->GetInstanceId())
         player->m_InstanceValid = true;
+    }
 
     if (!isRaidGroup())                                      // reset targetIcons for non-raid-groups
     {
@@ -436,6 +442,8 @@ bool Group::AddMember(Player* player)
     SendUpdate();
     sScriptMgr->OnGroupAddMember(this, player->GetGUID());
 
+    if (IS_PLAYER_GUID(player->GetGUID()))
+    {
     if (!IsLeader(player->GetGUID()) && !isBGGroup() && !isBFGroup())
     {
         // reset the new member's instances, unless he is currently in one of them
@@ -511,6 +519,7 @@ bool Group::AddMember(Player* player)
 
     if (m_maxEnchantingLevel < player->GetSkillValue(SKILL_ENCHANTING))
         m_maxEnchantingLevel = player->GetSkillValue(SKILL_ENCHANTING);
+    }
 
     return true;
 }
@@ -634,6 +643,9 @@ bool Group::RemoveMember(uint64 guid, const RemoveMethod& method /*= GROUP_REMOV
         }
 
         if (m_memberMgr.getSize() < ((isLFGGroup() || isBGGroup()) ? 1u : 2u))
+        //npcbot
+        if (GetMembersCount() < ((isBGGroup() || isLFGGroup()) ? 1u : 2u))
+        //end npcbot
             Disband();
 
         return true;
diff --git a/src/server/game/Groups/Group.h b/src/server/game/Groups/Group.h
index 8bc52e1..4f91b01 100644
--- a/src/server/game/Groups/Group.h
+++ b/src/server/game/Groups/Group.h
@@ -313,6 +313,9 @@ class Group
         // FG: evil hacks
         void BroadcastGroupUpdate(void);
 
+        //Bot
+        uint64 const *GetTargetIcons() const { return m_targetIcons; }
+
     protected:
         bool _setMembersGroup(uint64 guid, uint8 group);
         void _homebindIfInstance(Player* player);
diff --git a/src/server/game/Handlers/CharacterHandler.cpp b/src/server/game/Handlers/CharacterHandler.cpp
index 92864a0..a06bf8f 100644
--- a/src/server/game/Handlers/CharacterHandler.cpp
+++ b/src/server/game/Handlers/CharacterHandler.cpp
@@ -48,6 +48,9 @@
 #include "WorldPacket.h"
 #include "WorldSession.h"
 
+//bot
+#include "Config.h"
+
 class LoginQueryHolder : public SQLQueryHolder
 {
     private:
@@ -1131,6 +1134,28 @@ void WorldSession::HandlePlayerLogin(LoginQueryHolder* holder)
 
     m_playerLoading = false;
 
+    //the only place where we check if it has NPC bots
+    if (sConfigMgr->GetBoolDefault("Bot.EnableNpcBots", true))
+    {
+        if (QueryResult result = CharacterDatabase.PQuery("SELECT entry,race,class,istank FROM `character_npcbot` WHERE `owner` = '%u'", pCurrChar->GetGUIDLow()))
+        {
+            uint32 m_bot_entry = 0;
+            uint8 m_bot_race = 0;
+            uint8 m_bot_class = 0;
+            uint8 Tank = 0;
+            do
+            {
+                Field* fields = result->Fetch();
+                m_bot_entry = fields[0].GetUInt32();
+                m_bot_race = fields[1].GetUInt8();
+                m_bot_class = fields[2].GetInt8();
+                Tank = fields[3].GetInt8();
+                if (m_bot_entry && m_bot_race && m_bot_class)
+                    pCurrChar->SetBotMustBeCreated(m_bot_entry, m_bot_race, m_bot_class, bool(Tank));
+            } while (result->NextRow());
+        }
+    }
+
     sScriptMgr->OnPlayerLogin(pCurrChar);
     delete holder;
 }
diff --git a/src/server/game/Handlers/MiscHandler.cpp b/src/server/game/Handlers/MiscHandler.cpp
index 6b3959a..b2b3f90 100644
--- a/src/server/game/Handlers/MiscHandler.cpp
+++ b/src/server/game/Handlers/MiscHandler.cpp
@@ -57,6 +57,9 @@
 #include "BattlefieldMgr.h"
 #include "DB2Stores.h"
 
+//Bot
+#include "bothelper.h"
+
 void WorldSession::HandleRepopRequestOpcode(WorldPacket& recvData)
 {
     TC_LOG_DEBUG(LOG_FILTER_NETWORKIO, "WORLD: Recvd CMSG_REPOP_REQUEST Message");
@@ -112,6 +115,16 @@ void WorldSession::HandleGossipSelectOptionOpcode(WorldPacket& recvData)
             return;
         }
     }
+    //Bot
+    else if (IS_PLAYER_GUID(guid))
+    {
+        if (guid != _player->GetGUID())
+        {
+            TC_LOG_ERROR(LOG_FILTER_NETWORKIO, "WORLD: HandleGossipSelectOptionOpcode - Player (GUID: %u) not found.", uint32(GUID_LOPART(guid)));
+            return;
+        }
+    }
+    //end Bot
     else if (IS_GAMEOBJECT_GUID(guid))
     {
         go = _player->GetMap()->GetGameObject(guid);
@@ -149,6 +162,17 @@ void WorldSession::HandleGossipSelectOptionOpcode(WorldPacket& recvData)
             if (!sScriptMgr->OnGossipSelectCode(_player, unit, _player->PlayerTalkClass->GetGossipOptionSender(gossipListId), _player->PlayerTalkClass->GetGossipOptionAction(gossipListId), code.c_str()))
                 _player->OnGossipSelect(unit, gossipListId, menuId);
         }
+        //Bot
+        else if (guid == _player->GetGUID())
+        {
+            if (!_player->GetBotHelper())
+            {
+                TC_LOG_ERROR(LOG_FILTER_NETWORKIO, "WORLD: HandleGossipSelectOptionOpcode - Player (GUID: %u) do not have a helper on gossip select.", uint32(GUID_LOPART(guid)));
+                return;
+            }
+            //_player->GetBotHelper()->OnCodedGossipSelect(_player, _player->PlayerTalkClass->GetGossipOptionSender(gossipListId), _player->PlayerTalkClass->GetGossipOptionAction(gossipListId), code.c_str());
+        }
+        //end Bot
         else
         {
             go->AI()->GossipSelectCode(_player, menuId, gossipListId, code.c_str());
@@ -163,6 +187,17 @@ void WorldSession::HandleGossipSelectOptionOpcode(WorldPacket& recvData)
             if (!sScriptMgr->OnGossipSelect(_player, unit, _player->PlayerTalkClass->GetGossipOptionSender(gossipListId), _player->PlayerTalkClass->GetGossipOptionAction(gossipListId)))
                 _player->OnGossipSelect(unit, gossipListId, menuId);
         }
+        //Bot
+        else if (guid == _player->GetGUID())
+        {
+            if (!_player->GetBotHelper())
+            {
+                TC_LOG_ERROR(LOG_FILTER_NETWORKIO, "WORLD: HandleGossipSelectOptionOpcode - Player (GUID: %u) do not have a helper on gossip select.", uint32(GUID_LOPART(guid)));
+                return;
+            }
+            _player->GetBotHelper()->OnGossipSelect(_player, _player->PlayerTalkClass->GetGossipOptionSender(gossipListId), _player->PlayerTalkClass->GetGossipOptionAction(gossipListId));
+        }
+        //end Bot
         else
         {
             go->AI()->GossipSelect(_player, menuId, gossipListId);
diff --git a/src/server/game/Handlers/NPCHandler.cpp b/src/server/game/Handlers/NPCHandler.cpp
index ad7cb11..001be16 100644
--- a/src/server/game/Handlers/NPCHandler.cpp
+++ b/src/server/game/Handlers/NPCHandler.cpp
@@ -38,6 +38,9 @@
 #include "CreatureAI.h"
 #include "SpellInfo.h"
 
+//Bot
+#include "bothelper.h"
+
 enum StableResultCode
 {
     STABLE_ERR_MONEY        = 0x01,                         // "you don't have enough money"
@@ -320,6 +323,19 @@ void WorldSession::HandleGossipHelloOpcode(WorldPacket& recvData)
     uint64 guid;
     recvData >> guid;
 
+    //Bot
+    if (guid == _player->GetGUID())
+    {
+        if (!_player->GetBotHelper())
+        {
+            TC_LOG_ERROR(LOG_FILTER_NETWORKIO, "WORLD: HandleGossipSelectOptionOpcode - Player (GUID: %u) do not have a helper on gossip hello.", uint32(GUID_LOPART(guid)));
+            return;
+        }
+        _player->GetBotHelper()->OnGossipHello(_player);
+        return;
+    }
+    //end Bot
+
     Creature* unit = GetPlayer()->GetNPCIfCanInteractWith(guid, UNIT_NPC_FLAG_NONE);
     if (!unit)
     {
diff --git a/src/server/game/Maps/Map.cpp b/src/server/game/Maps/Map.cpp
index fb0f6d0..532cea7 100644
--- a/src/server/game/Maps/Map.cpp
+++ b/src/server/game/Maps/Map.cpp
@@ -2183,7 +2183,10 @@ uint32 Map::GetPlayersCountExceptGMs() const
     uint32 count = 0;
     for (MapRefManager::const_iterator itr = m_mapRefManager.begin(); itr != m_mapRefManager.end(); ++itr)
         if (!itr->GetSource()->IsGameMaster())
+        {
             ++count;
+            count += itr->GetSource()->GetNpcBotsCount();
+        }
     return count;
 }
 
diff --git a/src/server/game/Scripting/ScriptLoader.cpp b/src/server/game/Scripting/ScriptLoader.cpp
index 5b535fc..4879d2b 100644
--- a/src/server/game/Scripting/ScriptLoader.cpp
+++ b/src/server/game/Scripting/ScriptLoader.cpp
@@ -1302,6 +1302,17 @@ void AddBattlegroundScripts()
 
 #ifdef SCRIPTS
 /* This is where custom scripts' loading functions should be declared. */
+//Bots
+void AddSC_druid_bot();
+void AddSC_hunter_bot();
+void AddSC_mage_bot();
+void AddSC_paladin_bot();
+void AddSC_priest_bot();
+void AddSC_rogue_bot();
+void AddSC_shaman_bot();
+void AddSC_warlock_bot();
+void AddSC_warrior_bot();
+void AddSC_script_bot_commands();
 
 #endif
 
@@ -1309,6 +1320,17 @@ void AddCustomScripts()
 {
 #ifdef SCRIPTS
     /* This is where custom scripts should be added. */
+    //Bots
+    AddSC_druid_bot();
+    AddSC_hunter_bot();
+    AddSC_mage_bot();
+    AddSC_paladin_bot();
+    AddSC_priest_bot();
+    AddSC_rogue_bot();
+    AddSC_shaman_bot();
+    AddSC_warlock_bot();
+    AddSC_warrior_bot();
+    AddSC_script_bot_commands();
 
 #endif
 }
diff --git a/src/server/game/Server/WorldSession.cpp b/src/server/game/Server/WorldSession.cpp
index 42cf980..b8a9381 100644
--- a/src/server/game/Server/WorldSession.cpp
+++ b/src/server/game/Server/WorldSession.cpp
@@ -450,6 +450,20 @@ bool WorldSession::Update(uint32 diff, PacketFilter& updater)
 /// %Log the player out
 void WorldSession::LogoutPlayer(bool save)
 {
+    uint8 nBotCount = 0;
+    if (_player)
+    {
+        //remove npcbots but do not delete from DB so they can be reacqured on next login
+        for (uint8 i = 0; i != _player->GetMaxNpcBots(); ++i)
+        {
+            if (_player->GetBotMap(i)->_Guid())
+            {
+                _player->RemoveBot(_player->GetBotMap(i)->_Guid(), true, false);
+                ++nBotCount;
+            }
+        }
+    }
+
     // finish pending transfers before starting the logout
     while (_player && _player->IsBeingTeleportedFar())
         HandleMoveWorldportAckOpcode();
@@ -543,6 +557,9 @@ void WorldSession::LogoutPlayer(bool save)
         // remove player from the group if he is:
         // a) in group; b) not in raid group; c) logging out normally (not being kicked or disconnected)
         if (_player->GetGroup() && !_player->GetGroup()->isRaidGroup() && m_Socket)
+            //bot d) if has no NpcBots or not in instance (trying to save instance)
+            if (nBotCount == 0 || !_player->GetMap()->Instanceable())
+            //end bot
             _player->RemoveFromGroup();
 
         //! Send update to group and reset stored max enchanting level
diff --git a/src/server/game/Server/WorldSession.h b/src/server/game/Server/WorldSession.h
index 646007a..b56f008 100644
--- a/src/server/game/Server/WorldSession.h
+++ b/src/server/game/Server/WorldSession.h
@@ -194,6 +194,25 @@ class CharacterCreateInfo
         uint8 CharCount;
 };
 
+//npcbot
+struct NpcBotMap
+{
+    friend class Player;
+    protected:
+        NpcBotMap() : m_guid(0), m_entry(0), m_race(0), m_class(0), m_creature(NULL), m_reviveTimer(0), tank(false) {}
+        uint64 m_guid;
+        uint32 m_entry;
+        uint8  m_race;
+        uint8  m_class;
+        Creature* m_creature;
+        uint32 m_reviveTimer;
+        bool tank;
+    public:
+        uint64 _Guid() const { return m_guid; }
+        Creature* _Cre() const { return m_creature; }
+};
+//end bot mods
+
 /// Player session in the World
 class WorldSession
 {
diff --git a/src/server/scripts/Spells/spell_priest.cpp b/src/server/scripts/Spells/spell_priest.cpp
index 67439cf..2373ff2 100644
--- a/src/server/scripts/Spells/spell_priest.cpp
+++ b/src/server/scripts/Spells/spell_priest.cpp
@@ -620,6 +620,7 @@ class spell_pri_penance : public SpellScriptLoader
 
             bool Load() OVERRIDE
             {
+                if (GetCaster() && GetCaster()->GetTypeId() == TYPEID_UNIT && GetCaster()->ToCreature()->GetIAmABot()) return true;
                 return GetCaster()->GetTypeId() == TYPEID_PLAYER;
             }
 
@@ -662,6 +663,8 @@ class spell_pri_penance : public SpellScriptLoader
             SpellCastResult CheckCast()
             {
                 Player* caster = GetCaster()->ToPlayer();
+                if (!caster && GetCaster()->GetTypeId() == TYPEID_UNIT && GetCaster()->ToCreature()->GetIAmABot())
+                    caster = (Player*)GetCaster();
                 if (Unit* target = GetExplTargetUnit())
                     if (!caster->IsFriendlyTo(target) && !caster->IsValidAttackTarget(target))
                         return SPELL_FAILED_BAD_TARGETS;
@@ -844,6 +847,7 @@ class spell_pri_renew : public SpellScriptLoader
 
             bool Load() OVERRIDE
             {
+                if (GetCaster() && GetCaster()->GetTypeId() == TYPEID_UNIT && GetCaster()->ToCreature()->GetIAmABot()) return true;
                 return GetCaster() && GetCaster()->GetTypeId() == TYPEID_PLAYER;
             }
 
diff --git a/src/server/shared/Database/Implementation/CharacterDatabase.cpp b/src/server/shared/Database/Implementation/CharacterDatabase.cpp
index e203341..89eacd6 100644
--- a/src/server/shared/Database/Implementation/CharacterDatabase.cpp
+++ b/src/server/shared/Database/Implementation/CharacterDatabase.cpp
@@ -629,4 +629,11 @@ void CharacterDatabaseConnection::DoPrepareStatements()
     PrepareStatement(CHAR_UPD_CHAR_PET_SLOT_BY_ID, "UPDATE character_pet SET slot = ? WHERE owner = ? AND id = ?", CONNECTION_ASYNC);
     PrepareStatement(CHAR_DEL_CHAR_PET_BY_ID, "DELETE FROM character_pet WHERE id = ?", CONNECTION_ASYNC);
     PrepareStatement(CHAR_DEL_CHAR_PET_BY_SLOT, "DELETE FROM character_pet WHERE owner = ? AND (slot = ? OR slot > ?)", CONNECTION_ASYNC);
+
+    // Bot
+    PrepareStatement(CHAR_DEL_NPCBOT, "DELETE FROM character_npcbot WHERE owner = ? AND entry = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_DEL_NPCBOTS, "DELETE FROM character_npcbot WHERE owner = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_INS_NPCBOT, "INSERT INTO character_npcbot (owner, entry, race, class, istank) VALUES (?, ?, ?, ?, ?)", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_SEL_MAINTANK, "SELECT memberGuid, memberFlags FROM group_member WHERE guid = ?", CONNECTION_SYNCH);
+    PrepareStatement(CHAR_UPD_NPCBOT_TANK, "UPDATE character_npcbot SET istank = ? WHERE owner = ? AND entry = ?", CONNECTION_ASYNC);
 }
diff --git a/src/server/shared/Database/Implementation/CharacterDatabase.h b/src/server/shared/Database/Implementation/CharacterDatabase.h
index 53c309f..a84b921 100755
--- a/src/server/shared/Database/Implementation/CharacterDatabase.h
+++ b/src/server/shared/Database/Implementation/CharacterDatabase.h
@@ -556,6 +556,13 @@ enum CharacterDatabaseStatements
     CHAR_DEL_ITEMCONTAINER_MONEY,
     CHAR_INS_ITEMCONTAINER_MONEY,
 
+    // Bot
+    CHAR_DEL_NPCBOT,
+    CHAR_DEL_NPCBOTS,
+    CHAR_INS_NPCBOT,
+    CHAR_SEL_MAINTANK,
+    CHAR_UPD_NPCBOT_TANK,
+
     MAX_CHARACTERDATABASE_STATEMENTS
 };
 
diff --git a/src/server/shared/Database/Implementation/WorldDatabase.cpp b/src/server/shared/Database/Implementation/WorldDatabase.cpp
index 75bafb5..4922bc6 100644
--- a/src/server/shared/Database/Implementation/WorldDatabase.cpp
+++ b/src/server/shared/Database/Implementation/WorldDatabase.cpp
@@ -93,4 +93,8 @@ void WorldDatabaseConnection::DoPrepareStatements()
     PrepareStatement(WORLD_DEL_DISABLES, "DELETE FROM disables WHERE entry = ? AND sourceType = ?", CONNECTION_ASYNC);
     // 0: uint8
     PrepareStatement(WORLD_SEL_REQ_XP, "SELECT xp_for_next_level FROM player_xp_for_level WHERE lvl = ?", CONNECTION_SYNCH);
+
+    // Bot
+    PrepareStatement(WORLD_SEL_NPCBOT_TEMPLATE, "SELECT entry, trainer_race FROM creature_template WHERE scriptname = ? and trainer_class = ? and trainer_race IN (?, ?, ?, ?, ?)", CONNECTION_SYNCH);
+    PrepareStatement(WORLD_SEL_NPCBOT_PET_LEVELSTATS, "SELECT hp, mana, armor, str, agi, sta, inte, spi FROM pet_levelstats WHERE creature_entry = ? AND level = ?", CONNECTION_SYNCH);
 }
diff --git a/src/server/shared/Database/Implementation/WorldDatabase.h b/src/server/shared/Database/Implementation/WorldDatabase.h
index 171627b..05ae43e 100644
--- a/src/server/shared/Database/Implementation/WorldDatabase.h
+++ b/src/server/shared/Database/Implementation/WorldDatabase.h
@@ -114,6 +114,10 @@ enum WorldDatabaseStatements
     WORLD_DEL_DISABLES,
     WORLD_SEL_REQ_XP,
 
+    // Bot
+    WORLD_SEL_NPCBOT_TEMPLATE,
+    WORLD_SEL_NPCBOT_PET_LEVELSTATS,
+
     MAX_WORLDDATABASE_STATEMENTS
 };
 
diff --git a/src/server/worldserver/worldserver.conf.dist b/src/server/worldserver/worldserver.conf.dist
index ce43126..30ac331 100644
--- a/src/server/worldserver/worldserver.conf.dist
+++ b/src/server/worldserver/worldserver.conf.dist
@@ -2910,3 +2910,109 @@ Currency.ConquestPointsArenaReward = 180
 
 #
 ###################################################################################################
+
+
+###################################################################################################
+# NPCBOT CONFIGURATION
+#
+#     Bot.EnableNpcBots
+#        Enable NpcBot system
+#        Default: 1 - enable
+#                       0 - disable
+
+Bot.EnableNpcBots = 1
+
+#    Bot.MaxNpcBots
+#        Maximum number of Npc Bots allowed per character (disabled for GM accounts)
+#        Default: 1
+#        Recomended: 4
+#        Max: 9
+#        Absolute Max: 39
+
+Bot.MaxNpcBots = 1
+
+#    Bot.MaxNpcBotsPerClass
+#        Maximum Npc Bots of each class allowed per character
+#        If set to 0, no restriction
+#        Default: 1
+
+Bot.MaxNpcBotsPerClass = 1
+
+#    Bot.BaseFollowDistance
+#        Default follow distance set at login
+#        Default: 30
+
+Bot.BaseFollowDistance = 30
+
+#    Bot.XpReductionPercent
+#        Since bot party can be pretty large, it can become an exploit to farm xp so you can reduce xp gain here
+#        PERCENT of  'XP.KILL'  reward reduction from each Npc Bots used (Starting with second)
+#        Example:
+#            You have 3 bots, xp reduction is 20 then reduction will be ((3-1)*20) = 40%; 60% exp gained only
+#        Note: Minimum xp rate will be 10%
+#        Min: 0
+#        Max: 90
+#        Default: 0
+
+Bot.XpReductionPercent = 0
+
+#    Bot.HealTargetIconsMask
+#        Icon number bitmask which bots are using to search for additional targets to heal (out of party)
+#        1 - Star
+#        2 - Circle
+#        4 - Diamond
+#        8 - Triangle
+#        16 - Moon
+#        32 - Square
+#        64 - Cross
+#        128 - Skull
+#        Example: to check Star, Triangle and Square we need 1+8+32 = 41
+#        Note that many creatures cannot accept heal
+#        Min: 0 (Disable)
+#        Max: 255 (Any Icon)
+#        Default: 8 (Triangle)
+
+Bot.HealTargetIconsMask = 8
+
+#    Bot.DamageMult
+#        Myltiplier for bot's damage dealt. Allows to balance bots' compared to players' damage
+#        Any damage done by bots will be modified
+#        Range: 0.01 - 10.0
+#        Default: 1.0
+
+Bot.DamageMult.Melee = 1.0
+Bot.DamageMult.Spell = 1.0
+
+#    Bot.EnableIn... Arenas/BGs/Dungeons/Raids
+#        Allows to restrict bots usage in PvE and/or PvP
+#        Default: true for all
+
+Bot.EnableInArenas = 1
+Bot.EnableInBGs = 1
+Bot.EnableInDungeons = 1
+Bot.EnableInRaids = 1
+
+#    Bot.InstanceLimit... Dungeons/Raids
+#        If set to 1 will apply instance players limitation to bots
+#        Default: false for all
+
+Bot.InstanceLimit.Dungeons = 0
+Bot.InstanceLimit.Raids = 0
+
+#    Bot.Cost
+#        Bot recruitment cost (in copper)
+#        Note: this value is set for lvl 85 characters. Cost will be reduced for lower levels
+#        Default: 0
+
+Bot.Cost = 0
+
+#    Bot.AllowAllClasses
+#        If set to 0 will not allow to create bots (through command) with classes which not yet implemented (in development)
+#        and not shown in botgiver's dialog
+#        Warning: Enabling this can cause crashes!
+#        Default: 0
+
+Bot.AllowAllClasses = 0
+
+#
+###################################################################################################
-- 
1.7.6.msysgit.0

